<TMU|<tuple|1.1.0|2025.0.14>>

<style|<tuple|book|number-europe|preview-ref|smart-ref>>

<\body>
  <\hide-preamble>
    <assign|LS|<macro|<with|math-font-family|tt|line_search>>>

    <assign|mI|<macro|<math-up|I>>><assign|mB|<macro|<math-up|B>>><assign|conv|<macro|<math-up|conv>>><assign|inte|<macro|<math-up|int>>><assign|tg|<macro|<wide|g|~>>><assign|tx|<macro|<wide|x|~>>><assign|ty|<macro|<wide|y|~>>><assign|tz|<macro|<wide|z|~>>><assign|id|<macro|<math-up|id>>><assign|K|<macro|<math-up|KL>>><assign|kl|<macro|<math-up|kl>>><assign|bp|<macro|\<b-p\>>><assign|phi|<macro|\<varphi\>>><assign|a|<macro|\<alpha\>>><assign|tr|<macro|<math-up|Tr>>><assign|Â|<macro|ű>>\<bbb-P\>

    <assign|E|<macro|\<bbb-E\>>><assign|N|<macro|\<bbb-N\>>><assign|R|<macro|\<bbb-R\>>><assign|Q|<macro|\<bbb-Q\>>><assign|KL|<macro|<math-up|KL>>><assign|LG|<macro|<wide|log|\<bar\>>(K)>><assign|ocP|<macro|<wide|\<cal-P\>|\<bar\>>>><assign|cZ|<macro|\<cal-Z\>>><assign|cA|<macro|\<cal-A\>>><assign|cR|<macro|\<cal-R\>>><assign|cB|<macro|\<cal-B\>>><assign|cN|<macro|\<cal-N\>>><assign|cM|<macro|\<cal-M\>>><assign|cF|<macro|\<cal-F\>>><assign|cL|<macro|\<cal-L\>>><assign|cX|<macro|\<cal-X\>>><assign|cI|<macro|\<cal-I\>>><assign|cJ|<macro|\<cal-J\>>><assign|cY|<macro|\<cal-Y\>>><assign|cH|<macro|\<cal-H\>>><assign|cP|<macro|\<cal-P\>>><assign|cT|<macro|\<cal-T\>>><assign|cC|<macro|\<cal-C\>>><assign|cS|<macro|\<cal-S\>>><assign|cE|<macro|\<cal-E\>>><assign|cK|<macro|\<cal-K\>>><assign|cD|<macro|\<cal-D\>>><assign|oD|<macro|<wide|\<cal-D\>|\<bar\>>>><assign|oR|<macro|<wide|R|\<bar\>>>><assign|ds|<macro|<with|math-font|Bbb****|1>>><assign|epsilon|<macro|\<varepsilon\>>><assign|wh|<macro|1|<wide|<arg|1>|^>>><assign|argmax|<macro|<math-up|argmax>>><assign|argmin|<macro|<math-up|argmin>>><assign|mod|<macro|1|2|[<arg|1> <space|0.17em><space|0.17em> <math-up|mod> <space|0.17em><space|0.17em> <arg|2>]>><assign|todo|<macro|<with|font-series|bold|TO DO > >><assign|tilde|<macro|1|<wide|<arg|1>|~>>><newlength|<minipagewidth>> } }

    <assign|bookbox|<\macro|1>
      <vspace*|1fn><no-indent><frame|[>tex-text-width]<minipage|f|<minipagewidth>| <arg|1>>
    </macro>><assign|Ber|<macro|<math-up|Ber>>><assign|beq|<macro|>><assign|eeq|<macro|>><assign|beqa|<macro|>><assign|eeqa|<macro|>><assign|beqan|<macro|>><assign|eeqan|<macro|>><assign|ba|<\macro|1>
      <\align*>
        <tformat|<table|<row|<cell|<arg|1>>>>>
      </align*>
    </macro>><assign|banum|<\macro|1>
      <\align>
        <tformat|<table|<row|<cell|<arg|1><eq-number>>>>>
      </align>
    </macro>><assign|charfct|<macro|<ds>1>><assign|Fcal|<macro|\<cal-F\>>><assign|Xcal|<macro|\<cal-X\>>><assign|Hcal|<macro|\<cal-H\>>><assign|Gcal|<macro|\<cal-G\>>><assign|Nat|<macro|\<bbb-N\>>>
  </hide-preamble>

  <doc-data|<doc-title|<assign|bookbox|<\macro|1>
    <vspace*|1fn><no-indent><frame|[>tex-text-width]<minipage|f|<minipagewidth>| <arg|1>>
  </macro>><assign|Ber|<macro|<math-up|Ber>>><assign|beq|<macro|>><assign|eeq|<macro|>><assign|beqa|<macro|>><assign|eeqa|<macro|>><assign|beqan|<macro|>><assign|eeqan|<macro|>><assign|ba|<\macro|1>
    <\align*>
      <tformat|<table|<row|<cell|<arg|1>>>>>
    </align*>
  </macro>><assign|banum|<\macro|1>
    <\align>
      <tformat|<table|<row|<cell|<arg|1><eq-number>>>>>
    </align>
  </macro>><assign|charfct|<macro|<ds>1>><assign|Fcal|<macro|\<cal-F\>>><assign|Xcal|<macro|\<cal-X\>>><assign|Hcal|<macro|\<cal-H\>>><assign|Gcal|<macro|\<cal-G\>>><assign|Nat|<macro|\<bbb-N\>>>Convex Optimization: Algorithms and Complexity>|<doc-author|<author-data|<author-name|Sébastien Bubeck>|<\author-affiliation>
    Theory Group, Microsoft Research
  </author-affiliation>|<author-email|sebubeck@microsoft.com>>>>

  <\table-of-contents|toc>
    <vspace*|1fn><with|font-series|bold|math-font-series|bold|Abstract> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-1><vspace|0.5fn>

    <vspace*|1fn><with|font-series|bold|math-font-series|bold|1<space|2spc>Introduction> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-2><vspace|0.5fn>

    1.1<space|2spc>Some convex optimization problems in machine learning <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-3>

    1.2<space|2spc>Basic properties of convexity <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-4>

    1.3<space|2spc>Why convexity? <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-5>

    1.4<space|2spc>Black-box model <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-6>

    1.5<space|2spc>Structured optimization <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-7>

    1.6<space|2spc>Overview of the results and disclaimer <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-8>

    <vspace*|1fn><with|font-series|bold|math-font-series|bold|2<space|2spc>Convex optimization in finite dimension> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-10><vspace|0.5fn>

    2.1<space|2spc>The center of gravity method <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-11>

    2.2<space|2spc>The ellipsoid method <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-12>

    2.3<space|2spc>Vaidya's cutting plane method <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-13>

    <with|par-left|1tab|2.3.1<space|2spc>The volumetric barrier <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-14>>

    <with|par-left|1tab|2.3.2<space|2spc>Vaidya's algorithm <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-15>>

    <with|par-left|1tab|2.3.3<space|2spc>Analysis of Vaidya's method <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-16>>

    <with|par-left|1tab|2.3.4<space|2spc>Constraints and the volumetric barrier <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-17>>

    2.4<space|2spc>Conjugate gradient <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-18>

    <vspace*|1fn><with|font-series|bold|math-font-series|bold|3<space|2spc>Dimension-free convex optimization> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-19><vspace|0.5fn>

    3.1<space|2spc>Projected subgradient descent for Lipschitz functions <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-21>

    3.2<space|2spc>Gradient descent for smooth functions <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-23>

    <with|par-left|1tab|The constrained case <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-24>>

    3.3<space|2spc>Conditional gradient descent, aka Frank-Wolfe <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-25>

    <with|par-left|1tab|An application of conditional gradient descent: Least-squares regression with structured sparsity <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-27>>

    3.4<space|2spc>Strong convexity <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-28>

    <with|par-left|1tab|3.4.1<space|2spc>Strongly convex and Lipschitz functions <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-29>>

    <with|par-left|1tab|3.4.2<space|2spc>Strongly convex and smooth functions <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-30>>

    3.5<space|2spc>Lower bounds <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-31>

    3.6<space|2spc>Geometric descent <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-32>

    <with|par-left|1tab|3.6.1<space|2spc>Warm-up: a geometric alternative to gradient descent <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-33>>

    <with|par-left|1tab|3.6.2<space|2spc>Acceleration <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-35>>

    <with|par-left|1tab|3.6.3<space|2spc>The geometric descent method <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-37>>

    3.7<space|2spc>Nesterov's accelerated gradient descent <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-38>

    <with|par-left|1tab|3.7.1<space|2spc>The smooth and strongly convex case <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-39>>

    <with|par-left|1tab|3.7.2<space|2spc>The smooth case <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-41>>

    <vspace*|1fn><with|font-series|bold|math-font-series|bold|4<space|2spc>Almost dimension-free convex optimization in non-Euclidean spaces> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-42><vspace|0.5fn>

    4.1<space|2spc>Mirror maps <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-43>

    4.2<space|2spc>Mirror descent <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-44>

    4.3<space|2spc>Standard setups for mirror descent <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-46>

    4.4<space|2spc>Lazy mirror descent, aka Nesterov's dual averaging <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-47>

    4.5<space|2spc>Mirror prox <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-48>

    4.6<space|2spc>The vector field point of view on MD, DA, and MP <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-50>

    <vspace*|1fn><with|font-series|bold|math-font-series|bold|5<space|2spc>Beyond the black-box model> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-51><vspace|0.5fn>

    5.1<space|2spc>Sum of a smooth and a simple non-smooth term <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-52>

    <with|par-left|1tab|ISTA (Iterative Shrinkage-Thresholding Algorithm) <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-53>>

    <with|par-left|1tab|FISTA (Fast ISTA) <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-54>>

    <with|par-left|1tab|CMD and RDA <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-55>>

    5.2<space|2spc>Smooth saddle-point representation of a non-smooth function <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-56>

    <with|par-left|1tab|5.2.1<space|2spc>Saddle point computation <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-57>>

    <with|par-left|1tab|5.2.2<space|2spc>Saddle Point Mirror Descent (SP-MD) <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-58>>

    <with|par-left|1tab|5.2.3<space|2spc>Saddle Point Mirror Prox (SP-MP) <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-59>>

    <with|par-left|1tab|5.2.4<space|2spc>Applications <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-60>>

    <with|par-left|2tab|5.2.4.1<space|2spc>Minimizing a maximum of smooth functions <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-61>>

    <with|par-left|2tab|5.2.4.2<space|2spc>Matrix games <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-62>>

    <with|par-left|2tab|5.2.4.3<space|2spc>Linear classification <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-63>>

    5.3<space|2spc>Interior point methods <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-64>

    <with|par-left|1tab|5.3.1<space|2spc>The barrier method <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-65>>

    <with|par-left|1tab|5.3.2<space|2spc>Traditional analysis of Newton's method <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-66>>

    <with|par-left|1tab|5.3.3<space|2spc>Self-concordant functions <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-67>>

    <with|par-left|1tab|5.3.4<space|2spc><with|mode|math|\<nu\>>-self-concordant barriers <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-68>>

    <with|par-left|1tab|5.3.5<space|2spc>Path-following scheme <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-69>>

    <with|par-left|1tab|5.3.6<space|2spc>IPMs for LPs and SDPs <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-70>>

    <vspace*|1fn><with|font-series|bold|math-font-series|bold|6<space|2spc>Convex optimization and randomness> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-71><vspace|0.5fn>

    6.1<space|2spc>Non-smooth stochastic optimization <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-72>

    6.2<space|2spc>Smooth stochastic optimization and mini-batch SGD <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-73>

    6.3<space|2spc>Sum of smooth and strongly convex functions <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-74>

    6.4<space|2spc>Random coordinate descent <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-75>

    <with|par-left|1tab|6.4.1<space|2spc>RCD for coordinate-smooth optimization <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-76>>

    <with|par-left|1tab|6.4.2<space|2spc>RCD for smooth and strongly convex optimization <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-77>>

    6.5<space|2spc>Acceleration by randomization for saddle points <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-78>

    6.6<space|2spc>Convex relaxation and randomized rounding <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-79>

    6.7<space|2spc>Random walk based methods <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-80>

    <vspace*|1fn><with|font-series|bold|math-font-series|bold|Appendix<space|2spc>Acknowledgements> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-81><vspace|0.5fn>

    <vspace*|1fn><with|font-series|bold|math-font-series|bold|Bibliography> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-82><vspace|0.5fn>
  </table-of-contents>

  \;

  <\abstract>
    This monograph presents the main complexity theorems in convex optimization and their corresponding algorithms. Starting from the fundamental theory of black-box optimization, the material progresses towards recent advances in structural optimization and stochastic optimization. Our presentation of black-box optimization, strongly influenced by Nesterov's seminal book and Nemirovski's lecture notes, includes the analysis of cutting plane methods, as well as (accelerated) gradient descent schemes. We also pay special attention to non-Euclidean settings (relevant algorithms include Frank-Wolfe, mirror descent, and dual averaging) and discuss their relevance in machine learning. We provide a gentle introduction to structural optimization with FISTA (to optimize a sum of a smooth and a simple non-smooth term), saddle-point mirror prox (Nemirovski's alternative to Nesterov's smoothing), and a concise description of interior point methods. In stochastic optimization we discuss stochastic gradient descent, mini-batches, random coordinate descent, and sublinear algorithms. We also briefly touch upon convex relaxation of combinatorial problems and the use of randomness to round solutions, as well as random walks based methods.
  </abstract>

  <chapter|Introduction><label|intro>

  The central objects of our study are convex functions and convex sets in <math|<R><rsup|n>>.

  <\definition>
    <dueto|Convex sets and convex functions>A set <math|<cX>\<subset\><R><rsup|n>> is said to be convex if it contains all of its segments, that is

    <\equation*>
      \<forall\><around|(|x,y,\<gamma\>|)>\<in\><cX>\<times\><cX>\<times\><around|[|0,1|]>,<space|0.27em><around|(|1-\<gamma\>|)>*x+\<gamma\>*y\<in\>\<cal-X\>.
    </equation*>

    A function <math|f:\<cal-X\>\<rightarrow\><R>> is said to be convex if it always lies below its chords, that is

    <\equation*>
      \<forall\><around|(|x,y,\<gamma\>|)>\<in\><cX>\<times\><cX>\<times\><around|[|0,1|]>,<space|0.27em>f*<around|(|<around|(|1-\<gamma\>|)>*x+\<gamma\>*y|)>\<leq\><around|(|1-\<gamma\>|)>*f<around|(|x|)>+\<gamma\>*f<around|(|y|)>.
    </equation*>
  </definition>

  We are interested in algorithms that take as input a convex set <math|<cX>> and a convex function <math|f> and output an approximate minimum of <math|f> over <math|<cX>>. We write compactly the problem of finding the minimum of <math|f> over <math|<cX>> as

  <\align*>
    <tformat|<table|<row|<cell|>|<cell|<with|math-font-family|rm|min.>*<space|0.27em>f<around|(|x|)>>>|<row|<cell|>|<cell|<text|s.t.><space|0.27em>x\<in\><cX>.>>>>
  </align*>

  In the following we will make more precise how the set of constraints <math|<cX>> and the objective function <math|f> are specified to the algorithm. Before that we proceed to give a few important examples of convex optimization problems in machine learning.

  <section|Some convex optimization problems in machine learning><label|sec:mlapps>

  Many fundamental convex optimization problems in machine learning take the following form:

  <\equation>
    <label|eq:veryfirst><below|<with|math-font-family|rm|min.>|x\<in\><R><rsup|n>><space|0.27em><big|sum><rsub|i=1><rsup|m>f<rsub|i><around|(|x|)>+\<lambda\>*<cR><around|(|x|)>,
  </equation>

  where the functions <math|f<rsub|1>,\<ldots\>,f<rsub|m>,<cR>> are convex and <math|\<lambda\>\<geq\>0> is a fixed parameter. The interpretation is that <math|f<rsub|i><around|(|x|)>> represents the cost of using <math|x> on the <math|i<rsup|t*h>> element of some data set, and <math|<cR><around|(|x|)>> is a regularization term which enforces some “simplicity” in <math|x>. We discuss now major instances of <eqref|eq:veryfirst>. In all cases one has a data set of the form <math|<around|(|w<rsub|i>,y<rsub|i>|)>\<in\><R><rsup|n>\<times\><cY>,i=1,\<ldots\>,m> and the cost function <math|f<rsub|i>> depends only on the pair <math|<around|(|w<rsub|i>,y<rsub|i>|)>>. We refer to <cite|HTF01|SS02|SSS14> for more details on the origin of these important problems. The mere objective of this section is to expose the reader to a few concrete convex optimization problems which are routinely solved.

  In classification one has <math|<cY>=<around|{|-1,1|}>>. Taking <math|f<rsub|i><around|(|x|)>=max <around|(|0,1-y<rsub|i>*x<rsup|\<top\>>*w<rsub|i>|)>> (the so-called hinge loss) and <math|<cR><around|(|x|)>=<around|\<\|\|\>|x|\<\|\|\>><rsub|2><rsup|2>> one obtains the SVM problem. On the other hand taking <math|f<rsub|i><around|(|x|)>=log <around|(|1+exp <around|(|-y<rsub|i>*x<rsup|\<top\>>*w<rsub|i>|)>|)>> (the logistic loss) and again <math|<cR><around|(|x|)>=<around|\<\|\|\>|x|\<\|\|\>><rsub|2><rsup|2>> one obtains the (regularized) logistic regression problem.

  In regression one has <math|<cY>=<R>>. Taking <math|f<rsub|i><around|(|x|)>=<around|(|x<rsup|\<top\>>*w<rsub|i>-y<rsub|i>|)><rsup|2>> and <math|<cR><around|(|x|)>=0> one obtains the vanilla least-squares problem which can be rewritten in vector notation as

  <\equation*>
    <below|<with|math-font-family|rm|min.>|x\<in\><R><rsup|n>><space|0.27em><around|\<\|\|\>|W*x-Y|\<\|\|\>><rsub|2><rsup|2>,
  </equation*>

  where <math|W\<in\><R><rsup|m\<times\>n>> is the matrix with <math|w<rsub|i><rsup|\<top\>>> on the <math|i<rsup|t*h>> row and <math|Y=<around|(|y<rsub|1>,\<ldots\>,y<rsub|n>|)><rsup|\<top\>>>. With <math|<cR><around|(|x|)>=<around|\<\|\|\>|x|\<\|\|\>><rsub|2><rsup|2>> one obtains the ridge regression problem, while with <math|<cR><around|(|x|)>=<around|\<\|\|\>|x|\<\|\|\>><rsub|1>> this is the LASSO problem <cite|Tib96>.

  Our last two examples are of a slightly different flavor. In particular the design variable <math|x> is now best viewed as a matrix, and thus we denote it by a capital letter <math|X>. The sparse inverse covariance estimation problem can be written as follows, given some empirical covariance matrix <math|Y>,

  <\align*>
    <tformat|<table|<row|<cell|>|<cell|<with|math-font-family|rm|min.><space|0.27em><math-up|Tr><around|(|X*Y|)>-<math-up|logdet><around|(|X|)>+\<lambda\><around|\<\|\|\>|X|\<\|\|\>><rsub|1>>>|<row|<cell|>|<cell|<text|s.t.><space|0.27em>X\<in\><R><rsup|n\<times\>n>,X<rsup|\<top\>>=X,X\<succeq\>0.>>>>
  </align*>

  Intuitively the above problem is simply a regularized maximum likelihood estimator (under a Gaussian assumption).

  Finally we introduce the convex version of the matrix completion problem. Here our data set consists of observations of some of the entries of an unknown matrix <math|Y>, and we want to “complete" the unobserved entries of <math|Y> in such a way that the resulting matrix is “simple" (in the sense that it has low rank). After some massaging (see <cite|CR09>) the (convex) matrix completion problem can be formulated as follows:

  <\align*>
    <tformat|<table|<row|<cell|>|<cell|<with|math-font-family|rm|min.><space|0.27em><math-up|Tr><around|(|X|)>>>|<row|<cell|>|<cell|<text|s.t.><space|0.27em>X\<in\><R><rsup|n\<times\>n>,X<rsup|\<top\>>=X,X\<succeq\>0,X<rsub|i,j>=Y<rsub|i,j><space|0.27em><text|for><space|0.27em><around|(|i,j|)>\<in\>\<Omega\>,>>>>
  </align*>

  where <math|\<Omega\>\<subset\><around|[|n|]><rsup|2>> and <math|<around|(|Y<rsub|i,j>|)><rsub|<around|(|i,j|)>\<in\>\<Omega\>>> are given.

  <section|Basic properties of convexity>

  A basic result about convex sets that we shall use extensively is the Separation Theorem.

  <\theorem>
    <dueto|Separation Theorem>Let <math|\<cal-X\>\<subset\><R><rsup|n>> be a closed convex set, and <math|x<rsub|0>\<in\><R><rsup|n>\<setminus\>\<cal-X\>>. Then, there exists <math|w\<in\><R><rsup|n>> and <math|t\<in\><R>> such that

    <\equation*>
      w<rsup|\<top\>>*x<rsub|0>\<less\>t,<space|0.27em><text|and><space|0.27em>\<forall\>x\<in\>\<cal-X\>,w<rsup|\<top\>>*x\<geq\>t.
    </equation*>
  </theorem>

  Note that if <math|\<cal-X\>> is not closed then one can only guarantee that <math|w<rsup|\<top\>>*x<rsub|0>\<leq\>w<rsup|\<top\>>*x,\<forall\>x\<in\>\<cal-X\>> (and <math|w\<neq\>0>). This immediately implies the Supporting Hyperplane Theorem (<math|\<partial\><cX>> denotes the boundary of <math|<cX>>, that is the closure without the interior):

  <\theorem>
    <dueto|Supporting Hyperplane Theorem>Let <math|\<cal-X\>\<subset\><R><rsup|n>> be a convex set, and <math|x<rsub|0>\<in\>\<partial\>*\<cal-X\>>. Then, there exists <math|w\<in\><R><rsup|n>,w\<neq\>0> such that

    <\equation*>
      \<forall\>x\<in\>\<cal-X\>,w<rsup|\<top\>>*x\<geq\>w<rsup|\<top\>>*x<rsub|0>.
    </equation*>
  </theorem>

  We introduce now the key notion of <with|font-shape|italic|subgradients>.

  <\definition>
    <dueto|Subgradients>Let <math|\<cal-X\>\<subset\><R><rsup|n>>, and <math|f:\<cal-X\>\<rightarrow\><R>>. Then <math|g\<in\><R><rsup|n>> is a subgradient of <math|f> at <math|x\<in\>\<cal-X\>> if for any <math|y\<in\>\<cal-X\>> one has

    <\equation*>
      f<around|(|x|)>-f<around|(|y|)>\<leq\>g<rsup|\<top\>>*<around|(|x-y|)>.
    </equation*>

    The set of subgradients of <math|f> at <math|x> is denoted <math|\<partial\>*f<around|(|x|)>>.
  </definition>

  To put it differently, for any <math|x\<in\><cX>> and <math|g\<in\>\<partial\>*f<around|(|x|)>>, <math|f> is above the linear function <math|y\<mapsto\>f<around|(|x|)>+g<rsup|\<top\>>*<around|(|y-x|)>>. The next result shows (essentially) that a convex functions always admit subgradients.

  <\proposition>
    <dueto|Existence of subgradients><label|prop:existencesubgradients>Let <math|\<cal-X\>\<subset\><R><rsup|n>> be convex, and <math|f:\<cal-X\>\<rightarrow\><R>>. If <math|\<forall\>x\<in\>\<cal-X\>,\<partial\>*f<around|(|x|)>\<neq\>\<emptyset\>> then <math|f> is convex. Conversely if <math|f> is convex then for any <math|x\<in\><math-up|int><around|(|\<cal-X\>|)>,\<partial\>*f<around|(|x|)>\<neq\>\<emptyset\>>. Furthermore if <math|f> is convex and differentiable at <math|x> then <math|\<nabla\>*f<around|(|x|)>\<in\>\<partial\>*f<around|(|x|)>>.
  </proposition>

  Before going to the proof we recall the definition of the epigraph of a function <math|f:\<cal-X\>\<rightarrow\><R>>:

  <\equation*>
    <math-up|epi><around|(|f|)>=<around|{|<around|(|x,t|)>\<in\>\<cal-X\>\<times\><R>:t\<geq\>f<around|(|x|)>|}>.
  </equation*>

  It is obvious that a function is convex if and only if its epigraph is a convex set.

  <\proof>
    The first claim is almost trivial: let <math|g\<in\>\<partial\>*f*<around|(|<around|(|1-\<gamma\>|)>*x+\<gamma\>*y|)>>, then by definition one has

    <\eqnarray*>
      <tformat|<table|<row|<cell|>|<cell|>|<cell|f*<around|(|<around|(|1-\<gamma\>|)>*x+\<gamma\>*y|)>\<leq\>f<around|(|x|)>+\<gamma\>*g<rsup|\<top\>>*<around|(|y-x|)>,>>|<row|<cell|>|<cell|>|<cell|f*<around|(|<around|(|1-\<gamma\>|)>*x+\<gamma\>*y|)>\<leq\>f<around|(|y|)>+<around|(|1-\<gamma\>|)>*g<rsup|\<top\>>*<around|(|x-y|)>,>>>>
    </eqnarray*>

    which clearly shows that <math|f> is convex by adding the two (appropriately rescaled) inequalities.

    Now let us prove that a convex function <math|f> has subgradients in the interior of <math|\<cal-X\>>. We build a subgradient by using a supporting hyperplane to the epigraph of the function. Let <math|x\<in\>\<cal-X\>>. Then clearly <math|<around|(|x,f<around|(|x|)>|)>\<in\>\<partial\><math-up|epi><around|(|f|)>>, and <math|<math-up|epi><around|(|f|)>> is a convex set. Thus by using the Supporting Hyperplane Theorem, there exists <math|<around|(|a,b|)>\<in\><R><rsup|n>\<times\><R>> such that

    <\equation>
      <label|eq:supphyp>a<rsup|\<top\>>*x+b*f<around|(|x|)>\<geq\>a<rsup|\<top\>>*y+b*t,\<forall\><around|(|y,t|)>\<in\><math-up|epi><around|(|f|)>.
    </equation>

    Clearly, by letting <math|t> tend to infinity, one can see that <math|b\<leq\>0>. Now let us assume that <math|x> is in the interior of <math|\<cal-X\>>. Then for <math|\<epsilon\>\<gtr\>0> small enough, <math|y=x+\<epsilon\>*a\<in\>\<cal-X\>>, which implies that <math|b> cannot be equal to <math|0> (recall that if <math|b=0> then necessarily <math|a\<neq\>0> which allows to conclude by contradiction). Thus rewriting <eqref|eq:supphyp> for <math|t=f<around|(|y|)>> one obtains

    <\equation*>
      f<around|(|x|)>-f<around|(|y|)>\<leq\><frac|1|<around|\||b|\|>>*a<rsup|\<top\>>*<around|(|x-y|)>.
    </equation*>

    Thus <math|a/<around|\||b|\|>\<in\>\<partial\>*f<around|(|x|)>> which concludes the proof of the second claim.

    Finally let <math|f> be a convex and differentiable function. Then by definition:

    <\eqnarray*>
      <tformat|<table|<row|<cell|f<around|(|y|)>>|<cell|\<geq\>>|<cell|<frac|f*<around|(|<around|(|1-\<gamma\>|)>*x+\<gamma\>*y|)>-<around|(|1-\<gamma\>|)>*f<around|(|x|)>|\<gamma\>>>>|<row|<cell|>|<cell|=>|<cell|f<around|(|x|)>+<frac|f*<around|(|x+\<gamma\>*<around|(|y-x|)>|)>-f<around|(|x|)>|\<gamma\>>>>|<row|<cell|>|<cell|<below|\<to\>|\<gamma\>\<to\>0>>|<cell|f<around|(|x|)>+\<nabla\>*f<around|(|x|)><rsup|\<top\>>*<around|(|y-x|)>,>>>>
    </eqnarray*>

    which shows that <math|\<nabla\>*f<around|(|x|)>\<in\>\<partial\>*f<around|(|x|)>>.
  </proof>

  In several cases of interest the set of contraints can have an empty interior, in which case the above proposition does not yield any information. However it is easy to replace <math|<math-up|int><around|(|<cX>|)>> by <math|<math-up|ri><around|(|<cX>|)>> -the relative interior of <math|<cX>>- which is defined as the interior of <math|<cX>> when we view it as subset of the affine subspace it generates. Other notions of convex analysis will prove to be useful in some parts of this text. In particular the notion of <with|font-shape|italic|closed convex functions> is convenient to exclude pathological cases: these are the convex functions with closed epigraphs. Sometimes it is also useful to consider the extension of a convex function <math|f:<cX>\<rightarrow\><R>> to a function from <math|<R><rsup|n>> to <math|<wide|<R>|\<bar\>>> by setting <math|f<around|(|x|)>=+\<infty\>> for <math|x\<nin\><cX>>. In convex analysis one uses the term <with|font-shape|italic|proper convex function> to denote a convex function with values in <math|<R>\<cup\><around|{|+\<infty\>|}>> such that there exists <math|x\<in\><R><rsup|n>> with <math|f<around|(|x|)>\<less\>+\<infty\>>. <with|font-series|bold|From now on all convex functions will be closed, and if necessary we consider also their proper extension.> We refer the reader to <cite|Roc70> for an extensive discussion of these notions.

  <section|Why convexity?>

  The key to the algorithmic success in minimizing convex functions is that these functions exhibit a <with|font-shape|italic|local to global> phenomenon. We have already seen one instance of this in Proposition <reference|prop:existencesubgradients>, where we showed that <math|\<nabla\>*f<around|(|x|)>\<in\>\<partial\>*f<around|(|x|)>>: the gradient <math|\<nabla\>*f<around|(|x|)>> contains a priori only local information about the function <math|f> around <math|x> while the subdifferential <math|\<partial\>*f<around|(|x|)>> gives a global information in the form of a linear lower bound on the entire function. Another instance of this local to global phenomenon is that local minima of convex functions are in fact global minima:

  <\proposition>
    <dueto|Local minima are global minima>Let <math|f> be convex. If <math|x> is a local minimum of <math|f> then <math|x> is a global minimum of <math|f>. Furthermore this happens if and only if <math|0\<in\>\<partial\>*f<around|(|x|)>>.
  </proposition>

  <\proof>
    Clearly <math|0\<in\>\<partial\>*f<around|(|x|)>> if and only if <math|x> is a global minimum of <math|f>. Now assume that <math|x> is local minimum of <math|f>. Then for <math|\<gamma\>> small enough one has for any <math|y>,

    <\equation*>
      f<around|(|x|)>\<leq\>f*<around|(|<around|(|1-\<gamma\>|)>*x+\<gamma\>*y|)>\<leq\><around|(|1-\<gamma\>|)>*f<around|(|x|)>+\<gamma\>*f<around|(|y|)>,
    </equation*>

    which implies <math|f<around|(|x|)>\<leq\>f<around|(|y|)>> and thus <math|x> is a global minimum of <math|f>.
  </proof>

  The nice behavior of convex functions will allow for very fast algorithms to optimize them. This alone would not be sufficient to justify the importance of this class of functions (after all constant functions are pretty easy to optimize). However it turns out that surprisingly many optimization problems admit a convex (re)formulation. The excellent book <cite|BV04> describes in great details the various methods that one can employ to uncover the convex aspects of an optimization problem. We will not repeat these arguments here, but we have already seen that many famous machine learning problems (SVM, ridge regression, logistic regression, LASSO, sparse covariance estimation, and matrix completion) are formulated as convex problems.

  We conclude this section with a simple extension of the optimality condition “<math|0\<in\>\<partial\>*f<around|(|x|)>>” to the case of constrained optimization. We state this result in the case of a differentiable function for sake of simplicity.

  <\proposition>
    <dueto|First order optimality condition><label|prop:firstorder>Let <math|f> be convex and <math|<cX>> a closed convex set on which <math|f> is differentiable. Then

    <\equation*>
      x<rsup|\<ast\>>\<in\><argmin><rsub|x\<in\><cX>>f<around|(|x|)>,
    </equation*>

    if and only if one has

    <\equation*>
      \<nabla\>*f<around|(|x<rsup|\<ast\>>|)><rsup|\<top\>>*<around|(|x<rsup|\<ast\>>-y|)>\<leq\>0,\<forall\>y\<in\><cX>.
    </equation*>
  </proposition>

  <\proof>
    The “if" direction is trivial by using that a gradient is also a subgradient. For the “only if" direction it suffices to note that if <math|\<nabla\>*f<around|(|x|)><rsup|\<top\>>*<around|(|y-x|)>\<less\>0>, then <math|f> is locally decreasing around <math|x> on the line to <math|y> (simply consider <math|h<around|(|t|)>=f*<around|(|x+t*<around|(|y-x|)>|)>> and note that <math|h<rprime|'><around|(|0|)>=\<nabla\>*f<around|(|x|)><rsup|\<top\>>*<around|(|y-x|)>>).
  </proof>

  <section|Black-box model><label|sec:blackbox>

  We now describe our first model of “input" for the objective function and the set of constraints. In the black-box model we assume that we have unlimited computational resources, the set of constraint <math|<cX>> is known, and the objective function <math|f:<cX>\<rightarrow\><R>> is unknown but can be accessed through queries to <with|font-shape|italic|oracles>:

  <\itemize>
    <item>A zeroth order oracle takes as input a point <math|x\<in\><cX>> and outputs the value of <math|f> at <math|x>.

    <item>A first order oracle takes as input a point <math|x\<in\><cX>> and outputs a subgradient of <math|f> at <math|x>.
  </itemize>

  In this context we are interested in understanding the <with|font-shape|italic|oracle complexity> of convex optimization, that is how many queries to the oracles are necessary and sufficient to find an <math|\<epsilon\>>-approximate minima of a convex function. To show an upper bound on the sample complexity we need to propose an algorithm, while lower bounds are obtained by information theoretic reasoning (we need to argue that if the number of queries is “too small" then we don't have enough information about the function to identify an <math|\<epsilon\>>-approximate solution).

  From a mathematical point of view, the strength of the black-box model is that it will allow us to derive a <with|font-shape|italic|complete> theory of convex optimization, in the sense that we will obtain matching upper and lower bounds on the oracle complexity for various subclasses of interesting convex functions. While the model by itself does not limit our computational resources (for instance any operation on the constraint set <math|<cX>> is allowed) we will of course pay special attention to the algorithms' <with|font-shape|italic|computational complexity> (i.e., the number of elementary operations that the algorithm needs to do). We will also be interested in the situation where the set of constraint <math|<cX>> is unknown and can only be accessed through a <with|font-shape|italic|separation oracle>: given <math|x\<in\><R><rsup|n>>, it outputs either that <math|x> is in <math|\<cal-X\>>, or if <math|x\<nin\>\<cal-X\>> then it outputs a separating hyperplane between <math|x> and <math|\<cal-X\>>.

  The black-box model was essentially developed in the early days of convex optimization (in the Seventies) with <cite|NY83> being still an important reference for this theory (see also <cite|Nem95>). In the recent years this model and the corresponding algorithms have regained a lot of popularity, essentially for two reasons:

  <\itemize>
    <item>It is possible to develop algorithms with dimension-free oracle complexity which is quite attractive for optimization problems in very high dimension.

    <item>Many algorithms developed in this model are robust to noise in the output of the oracles. This is especially interesting for stochastic optimization, and very relevant to machine learning applications. We will explore this in details in Chapter <reference|rand>.
  </itemize>

  Chapter <reference|finitedim>, Chapter <reference|dimfree> and Chapter <reference|mirror> are dedicated to the study of the black-box model (noisy oracles are discussed in Chapter <reference|rand>). We do not cover the setting where only a zeroth order oracle is available, also called derivative free optimization, and we refer to <cite|CSV09|ABM11> for further references on this.

  <section|Structured optimization><label|sec:structured>

  The black-box model described in the previous section seems extremely wasteful for the applications we discussed in Section <reference|sec:mlapps>. Consider for instance the LASSO objective: <math|x\<mapsto\><around|\<\|\|\>|W*x-y|\<\|\|\>><rsub|2><rsup|2>+<around|\<\|\|\>|x|\<\|\|\>><rsub|1>>. We know this function <with|font-shape|italic|globally>, and assuming that we can only make local queries through oracles seem like an artificial constraint for the design of algorithms. Structured optimization tries to address this observation. Ultimately one would like to take into account the global structure of both <math|f> and <math|<cX>> in order to propose the most efficient optimization procedure. An extremely powerful hammer for this task are the Interior Point Methods. We will describe this technique in Chapter <reference|beyond> alongside with other more recent techniques such as FISTA or Mirror Prox.

  We briefly describe now two classes of optimization problems for which we will be able to exploit the structure very efficiently, these are the LPs (Linear Programs) and SDPs (Semi-Definite Programs). <cite|BN01> describe a more general class of Conic Programs but we will not go in that direction here.

  The class LP consists of problems where <math|f<around|(|x|)>=c<rsup|\<top\>>*x> for some <math|c\<in\><R><rsup|n>>, and <math|\<cal-X\>=<around|{|x\<in\><R><rsup|n>:A*x\<leq\>b|}>> for some <math|A\<in\><R><rsup|m\<times\>n>> and <math|b\<in\><R><rsup|m>>.

  The class SDP consists of problems where the optimization variable is a symmetric matrix <math|X\<in\><R><rsup|n\<times\>n>>. Let <math|\<bbb-S\><rsup|n>> be the space of <math|n\<times\>n> symmetric matrices (respectively <math|\<bbb-S\><rsup|n><rsub|+>> is the space of positive semi-definite matrices), and let <math|<around|\<langle\>|\<cdummy\>,\<cdummy\>|\<rangle\>>> be the Frobenius inner product (recall that it can be written as <math|<around|\<langle\>|A,B|\<rangle\>>=<tr><around|(|A<rsup|\<top\>>*B|)>>). In the class SDP the problems are of the following form: <math|f<around|(|x|)>=<around|\<langle\>|X,C|\<rangle\>>> for some <math|C\<in\><R><rsup|n\<times\>n>>, and <math|\<cal-X\>=<around|{|X\<in\>\<bbb-S\><rsup|n><rsub|+>:<around|\<langle\>|X,A<rsub|i>|\<rangle\>>\<leq\>b<rsub|i>,i\<in\><around|{|1,\<ldots\>,m|}>|}>> for some <math|A<rsub|1>,\<ldots\>,A<rsub|m>\<in\><R><rsup|n\<times\>n>> and <math|b\<in\><R><rsup|m>>. Note that the matrix completion problem described in Section <reference|sec:mlapps> is an example of an SDP.

  <section|Overview of the results and disclaimer>

  The overarching aim of this monograph is to present the main complexity theorems in convex optimization and the corresponding algorithms. We focus on five major results in convex optimization which give the overall structure of the text: the existence of efficient cutting-plane methods with optimal oracle complexity (Chapter <reference|finitedim>), a complete characterization of the relation between first order oracle complexity and curvature in the objective function (Chapter <reference|dimfree>), first order methods beyond Euclidean spaces (Chapter <reference|mirror>), non-black box methods (such as interior point methods) can give a quadratic improvement in the number of iterations with respect to optimal black-box methods (Chapter <reference|beyond>), and finally noise robustness of first order methods (Chapter <reference|rand>). Table <reference|table> can be used as a quick reference to the results proved in Chapter <reference|finitedim> to Chapter <reference|beyond>, as well as some of the results of Chapter <reference|rand> (this last chapter is the most relevant to machine learning but the results are also slightly more specific which make them harder to summarize).

  An important disclaimer is that the above selection leaves out methods derived from duality arguments, as well as the two most popular research avenues in convex optimization: (i) using convex optimization in non-convex settings, and (ii) practical large-scale algorithms. Entire books have been written on these topics, and new books have yet to be written on the impressive collection of new results obtained for both (i) and (ii) in the past five years.

  A few of the blatant omissions regarding (i) include (a) the theory of submodular optimization (see <cite|Bac13>), (b) convex relaxations of combinatorial problems (a short example is given in Section <reference|sec:convexrelaxation>), and (c) methods inspired from convex optimization for non-convex problems such as low-rank matrix factorization (see e.g. <cite|JNS13> and references therein), neural networks optimization, etc.

  With respect to (ii) the most glaring omissions include (a) heuristics (the only heuristic briefly discussed here is the non-linear conjugate gradient in Section <reference|sec:CG>), (b) methods for distributed systems, and (c) adaptivity to unknown parameters. Regarding (a) we refer to <cite|NW06> where the most practical algorithms are discussed in great details (e.g., quasi-newton methods such as BFGS and L-BFGS, primal-dual interior point methods, etc.). The recent survey <cite|BPCPE11> discusses the alternating direction method of multipliers (ADMM) which is a popular method to address (b). Finally (c) is a subtle and important issue. In the entire monograph the emphasis is on presenting the algorithms and proofs in the simplest way, and thus for sake of convenience we assume that the relevant parameters describing the regularity and curvature of the objective function (Lipschitz constant, smoothness constant, strong convexity parameter) are known and can be used to tune the algorithm's own parameters. Line search is a powerful technique to replace the knowledge of these parameters and it is heavily used in practice, see again <cite|NW06>. We observe however that from a theoretical point of view (c) is only a matter of logarithmic factors as one can always run in parallel several copies of the algorithm with different guesses for the values of the parameters<footnote|Note that this trick does not work in the context of Chapter <reference|rand>.>. Overall the attitude of this text with respect to (ii) is best summarized by a quote of Thomas Cover: “theory is the first term in the Taylor series of practice”, <cite|Cov92>.

  <with|font-series|bold|Notation.> We always denote by <math|x<rsup|\<ast\>>> a point in <math|<cX>> such that <math|f<around|(|x<rsup|\<ast\>>|)>=min<rsub|x\<in\><cX>> f<around|(|x|)>> (note that the optimization problem under consideration will always be clear from the context). In particular we always assume that <math|x<rsup|\<ast\>>> exists. For a vector <math|x\<in\><R><rsup|n>> we denote by <math|x<around|(|i|)>> its <math|i<rsup|t*h>> coordinate. The dual of a norm <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>>> (defined later) will be denoted either <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>><rsub|\<ast\>>> or <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>><rsup|\<ast\>>> (depending on whether the norm already comes with a subscript). Other notation are standard (e.g., <math|<mI><rsub|n>> for the <math|n\<times\>n> identity matrix, <math|\<succeq\>> for the positive semi-definite order on matrices, etc).

  <\padded-center>
    <big-table|<with|font-size|0.71|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|1ln>|<cwith|1|-1|2|2|cell-halign|c>|<cwith|1|-1|2|2|cell-rborder|1ln>|<cwith|1|-1|3|3|cell-halign|c>|<cwith|1|-1|3|3|cell-rborder|1ln>|<cwith|1|-1|4|4|cell-halign|c>|<cwith|1|-1|4|4|cell-rborder|1ln>|<cwith|1|-1|5|5|cell-halign|c>|<cwith|1|-1|5|5|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<cwith|1|1|1|-1|cell-bborder|1ln>|<cwith|2|2|1|-1|cell-bborder|1ln>|<cwith|3|3|1|-1|cell-bborder|1ln>|<cwith|4|4|1|-1|cell-bborder|1ln>|<cwith|5|5|1|-1|cell-bborder|1ln>|<cwith|6|6|1|-1|cell-bborder|1ln>|<cwith|7|7|1|-1|cell-bborder|1ln>|<cwith|8|8|1|-1|cell-bborder|1ln>|<cwith|9|9|1|-1|cell-bborder|1ln>|<cwith|10|10|1|-1|cell-bborder|1ln>|<cwith|11|11|1|-1|cell-bborder|1ln>|<cwith|12|12|1|-1|cell-bborder|1ln>|<cwith|13|13|1|-1|cell-bborder|1ln>|<cwith|14|14|1|-1|cell-bborder|1ln>|<cwith|15|15|1|-1|cell-bborder|1ln>|<cwith|16|16|1|-1|cell-bborder|1ln>|<cwith|17|17|1|-1|cell-bborder|1ln>|<table|<row|<cell|<math|f>>|<cell|Algorithm>|<cell|Rate>|<cell|# Iter>|<cell|Cost/iter>>|<row|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|non-smooth>>>>>>|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|center of>>|<row|<cell|gravity>>>>>>|<cell|<math|exp <around*|(|-<frac|t|n>|)>>>|<cell|<math|n*log <around*|(|<frac|1|\<epsilon\>>|)>>>|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|1 <math|\<nabla\>>,>>|<row|<cell|1 <math|n>-dim <math|<big|int>>>>>>>>>|<row|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|non-smooth>>>>>>|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|ellipsoid>>|<row|<cell|method>>>>>>|<cell|<math|<frac|R|r>*exp <around*|(|-<frac|t|n<rsup|2>>|)>>>|<cell|<math|n<rsup|2>*log <around*|(|<frac|R|r*\<epsilon\>>|)>>>|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|1 <math|\<nabla\>>,>>|<row|<cell|mat-vec <math|\<times\>>>>>>>>>|<row|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|non-smooth>>>>>>|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|Vaidya>>>>>>|<cell|<math|<frac|R*n|r>*exp <around*|(|-<frac|t|n>|)>>>|<cell|<math|n*log <around*|(|<frac|R*n|r*\<epsilon\>>|)>>>|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|1 <math|\<nabla\>>,>>|<row|<cell|mat-mat <math|\<times\>>>>>>>>>|<row|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|quadratic>>>>>>|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|CG>>>>>>|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|exact>>|<row|<cell|<math|exp <around*|(|-<frac|t|\<kappa\>>|)>>>>>>>>|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|<math|n>>>|<row|<cell|<math|\<kappa\>*log <around*|(|<frac|1|\<epsilon\>>|)>>>>>>>>|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|1 <math|\<nabla\>>>>>>>>>|<row|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|non-smooth,>>|<row|<cell|Lipschitz>>>>>>|<cell|PGD>|<cell|<math|R*L/<sqrt|t>>>|<cell|<math|R<rsup|2>*L<rsup|2>/\<epsilon\><rsup|2>>>|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|1 <math|\<nabla\>>,>>|<row|<cell|1 proj.>>>>>>>|<row|<cell|smooth>|<cell|PGD>|<cell|<math|\<beta\>*R<rsup|2>/t>>|<cell|<math|\<beta\>*R<rsup|2>/\<epsilon\>>>|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|1 <math|\<nabla\>>,>>|<row|<cell|1 proj.>>>>>>>|<row|<cell|smooth>|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|AGD>>>>>>|<cell|<math|\<beta\>*R<rsup|2>/t<rsup|2>>>|<cell|<math|R*<sqrt|\<beta\>/\<epsilon\>>>>|<cell|1 <math|\<nabla\>>>>|<row|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|smooth>>|<row|<cell|(any norm)>>>>>>|<cell|FW>|<cell|<math|\<beta\>*R<rsup|2>/t>>|<cell|<math|\<beta\>*R<rsup|2>/\<epsilon\>>>|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|1 <math|\<nabla\>>,>>|<row|<cell|1 LP>>>>>>>|<row|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|strong. conv.,>>|<row|<cell|Lipschitz>>>>>>|<cell|PGD>|<cell|<math|L<rsup|2>/<around|(|\<alpha\>*t|)>>>|<cell|<math|L<rsup|2>/<around|(|\<alpha\>*\<epsilon\>|)>>>|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|1 <math|\<nabla\>> ,>>|<row|<cell|1 proj.>>>>>>>|<row|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|strong. conv.,>>|<row|<cell|smooth>>>>>>|<cell|PGD>|<cell|<math|R<rsup|2>*exp <around*|(|-<frac|t|\<kappa\>>|)>>>|<cell|<math|\<kappa\>*log <around*|(|<frac|R<rsup|2>|\<epsilon\>>|)>>>|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|1 <math|\<nabla\>> ,>>|<row|<cell|1 proj.>>>>>>>|<row|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|strong. conv.,>>|<row|<cell|smooth>>>>>>|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|AGD>>>>>>|<cell|<math|R<rsup|2>*exp <around*|(|-<frac|t|<sqrt|\<kappa\>>>|)>>>|<cell|<math|<sqrt|\<kappa\>>*log <around*|(|<frac|R<rsup|2>|\<epsilon\>>|)>>>|<cell|1 <math|\<nabla\>>>>|<row|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|<math|f+g>,>>|<row|<cell|<math|f> smooth,>>|<row|<cell|<math|g> simple>>>>>>|<cell|FISTA>|<cell|<math|\<beta\>*R<rsup|2>/t<rsup|2>>>|<cell|<math|R*<sqrt|\<beta\>/\<epsilon\>>>>|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|1 <math|\<nabla\>> of <math|f>>>|<row|<cell|Prox of <math|g>>>>>>>>|<row|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|<math|<below|max|y\<in\><cY>>\<phi\>*<around|(|x,y|)>>,>>|<row|<cell|<math|\<phi\>> smooth>>>>>>|<cell|SP-MP>|<cell|<math|\<beta\>*R<rsup|2>/t>>|<cell|<math|\<beta\>*R<rsup|2>/\<epsilon\>>>|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|MD on <math|<cX>>>>|<row|<cell|MD on <math|<cY>>>>>>>>>|<row|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|linear,>>|<row|<cell|<math|<cX>> with <math|F>>>|<row|<cell|<math|\<nu\>>-self-conc.>>>>>>|<cell|IPM>|<cell|<math|\<nu\>*exp <around*|(|-<frac|t|<sqrt|\<nu\>>>|)>>>|<cell|<math|<sqrt|\<nu\>>*log <around*|(|<frac|\<nu\>|\<epsilon\>>|)>>>|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|Newton>>|<row|<cell|step on <math|F>>>>>>>>|<row|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|non-smooth>>>>>>|<cell|SGD>|<cell|<math|B*L/<sqrt|t>>>|<cell|<math|B<rsup|2>*L<rsup|2>/\<epsilon\><rsup|2>>>|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|1 stoch. <math|\<nabla\>>,>>|<row|<cell|1 proj.>>>>>>>|<row|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|non-smooth,>>|<row|<cell|strong. conv.>>>>>>|<cell|SGD>|<cell|<math|B<rsup|2>/<around|(|\<alpha\>*t|)>>>|<cell|<math|B<rsup|2>/<around|(|\<alpha\>*\<epsilon\>|)>>>|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|1 stoch. <math|\<nabla\>>,>>|<row|<cell|1 proj.>>>>>>>|<row|<cell|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|<math|f=<frac|1|m>*<big|sum>f<rsub|i>>>>|<row|<cell|<math|f<rsub|i>> smooth>>|<row|<cell|strong. conv.>>>>>>|<cell|SVRG>|<cell|-->|<cell|<math|<around|(|m+\<kappa\>|)>*log <around*|(|<frac|1|\<epsilon\>>|)>>>|<cell|1 stoch. <math|\<nabla\>>>>>>>><label|table>|Summary of the results proved in Chapter <reference|finitedim> to Chapter <reference|beyond> and some of the results in Chapter <reference|rand>.>
  </padded-center>

  <chapter|Convex optimization in finite dimension><label|finitedim>

  Let <math|\<cal-X\>\<subset\><R><rsup|n>> be a convex body (that is a compact convex set with non-empty interior), and <math|f:\<cal-X\>\<rightarrow\><around|[|-B,B|]>> be a continuous and convex function. Let <math|r,R\<gtr\>0> be such that <math|\<cal-X\>> is contained in an Euclidean ball of radius <math|R> (respectively it contains an Euclidean ball of radius <math|r>). In this chapter we give several black-box algorithms to solve

  <\align*>
    <tformat|<table|<row|<cell|>|<cell|<with|math-font-family|rm|min.>*<space|0.27em>f<around|(|x|)>>>|<row|<cell|>|<cell|<text|s.t.><space|0.27em>x\<in\><cX>.>>>>
  </align*>

  As we will see these algorithms have an oracle complexity which is linear (or quadratic) in the dimension, hence the title of the chapter (in the next chapter the oracle complexity will be <with|font-shape|italic|independent> of the dimension). An interesting feature of the methods discussed here is that they only need a separation oracle for the constraint set <math|<cX>>. In the literature such algorithms are often referred to as <with|font-shape|italic|cutting plane methods>. In particular these methods can be used to <with|font-shape|italic|find> a point <math|x\<in\><cX>> given only a separating oracle for <math|<cX>> (this is also known as the <with|font-shape|italic|feasibility problem>).

  <section|The center of gravity method><label|sec:gravity>

  We consider the following simple iterative algorithm<footnote|As a warm-up we assume in this section that <math|<cX>> is known. It should be clear from the arguments in the next section that in fact the same algorithm would work if initialized with <math|<cS><rsub|1>\<supset\><cX>>.>: let <math|<cS><rsub|1>=<cX>>, and for <math|t\<geq\>1> do the following:

  <\enumerate>
    <item>Compute

    <\equation>
      c<rsub|t>=<frac|1|<math-up|vol><around|(|<cS><rsub|t>|)>>*<big|int><rsub|x\<in\><cS><rsub|t>>x*d*x.
    </equation>

    <item>Query the first order oracle at <math|c<rsub|t>> and obtain <math|w<rsub|t>\<in\>\<partial\>*f<around|(|c<rsub|t>|)>>. Let

    <\equation*>
      <cS><rsub|t+1>=<cS><rsub|t>\<cap\><around|{|x\<in\><R><rsup|n>:<around|(|x-c<rsub|t>|)><rsup|\<top\>>*w<rsub|t>\<leq\>0|}>.
    </equation*>
  </enumerate>

  If stopped after <math|t> queries to the first order oracle then we use <math|t> queries to a zeroth order oracle to output

  <\equation*>
    x<rsub|t>\<in\><argmin><rsub|1\<leq\>r\<leq\>t>f<around|(|c<rsub|r>|)>.
  </equation*>

  This procedure is known as the <with|font-shape|italic|center of gravity method>, it was discovered independently on both sides of the Wall by <cite|Lev65> and <cite|New65>.

  <\theorem>
    <label|th:centerofgravity>The center of gravity method satisfies

    <\equation*>
      f<around|(|x<rsub|t>|)>-min<rsub|x\<in\>\<cal-X\>> f<around|(|x|)>\<leq\>2*B*<around*|(|1-<frac|1|e>|)><rsup|t/n>.
    </equation*>
  </theorem>

  Before proving this result a few comments are in order.

  To attain an <math|\<epsilon\>>-optimal point the center of gravity method requires <math|O<around|(|n*log <around|(|2*B/\<epsilon\>|)>|)>> queries to both the first and zeroth order oracles. It can be shown that this is the best one can hope for, in the sense that for <math|\<epsilon\>> small enough one needs <math|\<Omega\>*<around|(|n*log <around|(|1/\<epsilon\>|)>|)>> calls to the oracle in order to find an <math|\<epsilon\>>-optimal point, see <cite|NY83> for a formal proof.

  The rate of convergence given by Theorem <reference|th:centerofgravity> is exponentially fast. In the optimization literature this is called a <with|font-shape|italic|linear rate> as the (estimated) error at iteration <math|t+1> is linearly related to the error at iteration <math|t>.

  The last and most important comment concerns the computational complexity of the method. It turns out that finding the center of gravity <math|c<rsub|t>> is a very difficult problem by itself, and we do not have computationally efficient procedure to carry out this computation in general. In Section <reference|sec:rwmethod> we will discuss a relatively recent (compared to the 50 years old center of gravity method!) randomized algorithm to approximately compute the center of gravity. This will in turn give a randomized center of gravity method which we will describe in detail.

  We now turn to the proof of Theorem <reference|th:centerofgravity>. We will use the following elementary result from convex geometry:

  <\lemma>
    <dueto|<cite|Gru60>><label|lem:Gru60>Let <math|<cK>> be a centered convex set, i.e., <math|<big|int><rsub|x\<in\><cK>>x*d*x=0>, then for any <math|w\<in\><R><rsup|n>,w\<neq\>0>, one has

    <\equation*>
      <math-up|Vol><around*|(|<cK>\<cap\><around|{|x\<in\><R><rsup|n>:x<rsup|\<top\>>*w\<geq\>0|}>|)>\<geq\><frac|1|e><math-up|Vol><around|(|<cK>|)>.
    </equation*>
  </lemma>

  We now prove Theorem <reference|th:centerofgravity>.

  <\proof>
    Let <math|x<rsup|\<ast\>>> be such that <math|f<around|(|x<rsup|\<ast\>>|)>=min<rsub|x\<in\>\<cal-X\>> f<around|(|x|)>>. Since <math|w<rsub|t>\<in\>\<partial\>*f<around|(|c<rsub|t>|)>> one has

    <\equation*>
      f<around|(|c<rsub|t>|)>-f<around|(|x|)>\<leq\>w<rsub|t><rsup|\<top\>>*<around|(|c<rsub|t>-x|)>.
    </equation*>

    and thus

    <\equation>
      <label|eq:centerofgravity1><cS><rsub|t>\<setminus\><cS><rsub|t+1>\<subset\><around|{|x\<in\><cX>:<around|(|x-c<rsub|t>|)><rsup|\<top\>>*w<rsub|t>\<gtr\>0|}>\<subset\><around|{|x\<in\><cX>:f<around|(|x|)>\<gtr\>f<around|(|c<rsub|t>|)>|}>,
    </equation>

    which clearly implies that one can never remove the optimal point from our sets in consideration, that is <math|x<rsup|\<ast\>>\<in\><cS><rsub|t>> for any <math|t>. Without loss of generality we can assume that we always have <math|w<rsub|t>\<neq\>0>, for otherwise one would have <math|f<around|(|c<rsub|t>|)>=f<around|(|x<rsup|\<ast\>>|)>> which immediately conludes the proof. Now using that <math|w<rsub|t>\<neq\>0> for any <math|t> and Lemma <reference|lem:Gru60> one clearly obtains

    <\equation*>
      <math-up|vol><around|(|<cS><rsub|t+1>|)>\<leq\><around*|(|1-<frac|1|e>|)><rsup|t><math-up|vol><around|(|<cX>|)>.
    </equation*>

    For <math|\<epsilon\>\<in\><around|[|0,1|]>>, let <math|\<cal-X\><rsub|\<epsilon\>>=<around|{|<around|(|1-\<epsilon\>|)>*x<rsup|\<ast\>>+\<epsilon\>*x,x\<in\>\<cal-X\>|}>>. Note that <math|<math-up|vol><around|(|\<cal-X\><rsub|\<epsilon\>>|)>=\<epsilon\><rsup|n><math-up|vol><around|(|\<cal-X\>|)>>. These volume computations show that for <math|\<epsilon\>\<gtr\><around*|(|1-<frac|1|e>|)><rsup|t/n>> one has <math|<math-up|vol><around|(|\<cal-X\><rsub|\<epsilon\>>|)>\<gtr\><math-up|vol><around|(|<cS><rsub|t+1>|)>>. In particular this implies that for <math|\<epsilon\>\<gtr\><around*|(|1-<frac|1|e>|)><rsup|t/n>>, there must exist a time <math|r\<in\><around|{|1,\<ldots\>,t|}>>, and <math|x<rsub|\<epsilon\>>\<in\>\<cal-X\><rsub|\<epsilon\>>>, such that <math|x<rsub|\<epsilon\>>\<in\><cS><rsub|r>> and <math|x<rsub|\<epsilon\>>\<nin\><cS><rsub|r+1>>. In particular by <eqref|eq:centerofgravity1> one has <math|f<around|(|c<rsub|r>|)>\<less\>f<around|(|x<rsub|\<epsilon\>>|)>>. On the other hand by convexity of <math|f> one clearly has <math|f<around|(|x<rsub|\<epsilon\>>|)>\<leq\>f<around|(|x<rsup|\<ast\>>|)>+2*\<epsilon\>*B>. This concludes the proof.
  </proof>

  <section|The ellipsoid method><label|sec:ellipsoid>

  Recall that an ellipsoid is a convex set of the form

  <\equation*>
    \<cal-E\>=<around|{|x\<in\><R><rsup|n>:<around|(|x-c|)><rsup|\<top\>>*H<rsup|-1>*<around|(|x-c|)>\<leq\>1|}>,
  </equation*>

  where <math|c\<in\><R><rsup|n>>, and <math|H> is a symmetric positive definite matrix. Geometrically <math|c> is the center of the ellipsoid, and the semi-axes of <math|<cE>> are given by the eigenvectors of <math|H>, with lengths given by the square root of the corresponding eigenvalues.

  We give now a simple geometric lemma, which is at the heart of the ellipsoid method.

  <\lemma>
    <label|lem:geomellipsoid>Let <math|\<cal-E\><rsub|0>=<around|{|x\<in\><R><rsup|n>:<around|(|x-c<rsub|0>|)><rsup|\<top\>>*H<rsub|0><rsup|-1>*<around|(|x-c<rsub|0>|)>\<leq\>1|}>>. For any <math|w\<in\><R><rsup|n>>, <math|w\<neq\>0>, there exists an ellipsoid <math|\<cal-E\>> such that

    <\equation>
      \<cal-E\>\<supset\><around|{|x\<in\>\<cal-E\><rsub|0>:w<rsup|\<top\>>*<around|(|x-c<rsub|0>|)>\<leq\>0|}>,<label|eq:ellipsoidlemma1>
    </equation>

    and

    <\equation>
      <math-up|vol><around|(|\<cal-E\>|)>\<leq\>exp <around*|(|-<frac|1|2*n>|)><math-up|vol><around|(|\<cal-E\><rsub|0>|)>.<label|eq:ellipsoidlemma2>
    </equation>

    Furthermore for <math|n\<geq\>2> one can take <math|<cE>=<around|{|x\<in\><R><rsup|n>:<around|(|x-c|)><rsup|\<top\>>*H<rsup|-1>*<around|(|x-c|)>\<leq\>1|}>> where

    <\align>
      <tformat|<table|<row|<cell|>|<cell|c=c<rsub|0>-<frac|1|n+1>*<frac|H<rsub|0>*w|<sqrt|w<rsup|\<top\>>*H<rsub|0>*w>>,<eq-number><label|eq:ellipsoidlemma3>>>|<row|<cell|>|<cell|H=<frac|n<rsup|2>|n<rsup|2>-1>*<around*|(|H<rsub|0>-<frac|2|n+1>*<frac|H<rsub|0>*w*w<rsup|\<top\>>*H<rsub|0>|w<rsup|\<top\>>*H<rsub|0>*w>|)>.<eq-number><label|eq:ellipsoidlemma4>>>>>
    </align>
  </lemma>

  <\proof>
    For <math|n=1> the result is obvious, in fact we even have <math|<math-up|vol><around|(|\<cal-E\>|)>\<leq\><frac|1|2><math-up|vol><around|(|\<cal-E\><rsub|0>|)>>.

    For <math|n\<geq\>2> one can simply verify that the ellipsoid given by <eqref|eq:ellipsoidlemma3> and <eqref|eq:ellipsoidlemma4> satisfy the required properties <eqref|eq:ellipsoidlemma1> and <eqref|eq:ellipsoidlemma2>. Rather than bluntly doing these computations we will show how to derive <eqref|eq:ellipsoidlemma3> and <eqref|eq:ellipsoidlemma4>. As a by-product this will also show that the ellipsoid defined by <eqref|eq:ellipsoidlemma3> and <eqref|eq:ellipsoidlemma4> is the unique ellipsoid of minimal volume that satisfy <eqref|eq:ellipsoidlemma1>. Let us first focus on the case where <math|\<cal-E\><rsub|0>> is the Euclidean ball <math|<cB>=<around|{|x\<in\><R><rsup|n>:x<rsup|\<top\>>*x\<leq\>1|}>>. We momentarily assume that <math|w> is a unit norm vector.

    By doing a quick picture, one can see that it makes sense to look for an ellipsoid <math|\<cal-E\>> that would be centered at <math|c=-t*w>, with <math|t\<in\><around|[|0,1|]>> (presumably <math|t> will be small), and such that one principal direction is <math|w> (with inverse squared semi-axis <math|a\<gtr\>0>), and the other principal directions are all orthogonal to <math|w> (with the same inverse squared semi-axes <math|b\<gtr\>0>). In other words we are looking for <math|\<cal-E\>=<around|{|x:<around|(|x-c|)><rsup|\<top\>>*H<rsup|-1>*<around|(|x-c|)>\<leq\>1|}>> with

    <\equation*>
      c=-t*w,<space|0.27em><text|and><space|0.27em>H<rsup|-1>=a*w*w<rsup|\<top\>>+b*<around|(|<mI><rsub|n>-w*w<rsup|\<top\>>|)>.
    </equation*>

    Now we have to express our constraints on the fact that <math|\<cal-E\>> should contain the half Euclidean ball <math|<around|{|x\<in\><cB>:x<rsup|\<top\>>*w\<leq\>0|}>>. Since we are also looking for <math|\<cal-E\>> to be as small as possible, it makes sense to ask for <math|\<cal-E\>> to "touch" the Euclidean ball, both at <math|x=-w>, and at the equator <math|\<partial\><cB>\<cap\>w<rsup|\<perp\>>>. The former condition can be written as:

    <\equation*>
      <around|(|-w-c|)><rsup|\<top\>>*H<rsup|-1>*<around|(|-w-c|)>=1\<Leftrightarrow\><around|(|t-1|)><rsup|2>*a=1,
    </equation*>

    while the latter is expressed as:

    <\equation*>
      \<forall\>y\<in\>\<partial\><cB>\<cap\>w<rsup|\<perp\>>,<around|(|y-c|)><rsup|\<top\>>*H<rsup|-1>*<around|(|y-c|)>=1\<Leftrightarrow\>b+t<rsup|2>*a=1.
    </equation*>

    As one can see from the above two equations, we are still free to choose any value for <math|t\<in\><around|[|0,1/2|)>> (the fact that we need <math|t\<less\>1/2> comes from <math|b=1-<around*|(|<frac|t|t-1>|)><rsup|2>\<gtr\>0>). Quite naturally we take the value that minimizes the volume of the resulting ellipsoid. Note that

    <\equation*>
      <frac|<math-up|vol><around|(|\<cal-E\>|)>|<math-up|vol><around|(|<cB>|)>>=<frac|1|<sqrt|a>><around*|(|<frac|1|<sqrt|b>>|)><rsup|n-1>=<frac|1|<sqrt|<frac|1|<around|(|1-t|)><rsup|2>>*<around*|(|1-<around*|(|<frac|t|1-t>|)><rsup|2>|)><rsup|n-1>>><next-line>=<frac|1|<sqrt|f<around*|(|<frac|1|1-t>|)>>>,
    </equation*>

    where <math|f<around|(|h|)>=h<rsup|2>*<around|(|2*h-h<rsup|2>|)><rsup|n-1>>. Elementary computations show that the maximum of <math|f> (on <math|<around|[|1,2|]>>) is attained at <math|h=1+<frac|1|n>> (which corresponds to <math|t=<frac|1|n+1>>), and the value is

    <\equation*>
      <around*|(|1+<frac|1|n>|)><rsup|2>*<around*|(|1-<frac|1|n<rsup|2>>|)><rsup|n-1>\<geq\>exp <around*|(|<frac|1|n>|)>,
    </equation*>

    where the lower bound follows again from elementary computations. Thus we showed that, for <math|<cE><rsub|0>=<cB>>, <eqref|eq:ellipsoidlemma1> and <eqref|eq:ellipsoidlemma2> are satisfied with the ellipsoid given by the set of points <math|x> satisfying:

    <\equation>
      <label|eq:ellipsoidlemma5><around*|(|x+<frac|w/<around|\<\|\|\>|w|\<\|\|\>><rsub|2>|n+1>|)><rsup|\<top\>>*<around*|(|<frac|n<rsup|2>-1|n<rsup|2>><mI><rsub|n>+<frac|2*<around|(|n+1|)>|n<rsup|2>>*<frac|w*w<rsup|\<top\>>|<around|\<\|\|\>|w|\<\|\|\>><rsub|2><rsup|2>>|)>*<around*|(|x+<frac|w/<around|\<\|\|\>|w|\<\|\|\>><rsub|2>|n+1>|)>\<leq\>1.
    </equation>

    We consider now an arbitrary ellipsoid <math|<cE><rsub|0>=<around|{|x\<in\><R><rsup|n>:<around|(|x-c<rsub|0>|)><rsup|\<top\>>*H<rsub|0><rsup|-1>*<around|(|x-c<rsub|0>|)>\<leq\>1|}>>. Let <math|\<Phi\><around|(|x|)>=c<rsub|0>+H<rsub|0><rsup|1/2>*x>, then clearly <math|<cE><rsub|0>=\<Phi\><around|(|<cB>|)>> and <math|<around|{|x:w<rsup|\<top\>>*<around|(|x-c<rsub|0>|)>\<leq\>0|}>=\<Phi\><around|(|<around|{|x:<around|(|H<rsub|0><rsup|1/2>*w|)><rsup|\<top\>>*x\<leq\>0|}>|)>>. Thus in this case the image by <math|\<Phi\>> of the ellipsoid given in <eqref|eq:ellipsoidlemma5> with <math|w> replaced by <math|H<rsub|0><rsup|1/2>*w> will satisfy <eqref|eq:ellipsoidlemma1> and <eqref|eq:ellipsoidlemma2>. It is easy to see that this corresponds to an ellipsoid defined by

    <\align>
      <tformat|<table|<row|<cell|>|<cell|c=c<rsub|0>-<frac|1|n+1>*<frac|H<rsub|0>*w|<sqrt|w<rsup|\<top\>>*H<rsub|0>*w>>,<eq-number>>>|<row|<cell|>|<cell|H<rsup|-1>=<around*|(|1-<frac|1|n<rsup|2>>|)>*H<rsub|0><rsup|-1>+<frac|2*<around|(|n+1|)>|n<rsup|2>>*<frac|w*w<rsup|\<top\>>|w<rsup|\<top\>>*H<rsub|0>*w>.<eq-number><label|eq:ellipsoidlemma6>>>>>
    </align>

    Applying Sherman-Morrison formula to <eqref|eq:ellipsoidlemma6> one can recover <eqref|eq:ellipsoidlemma4> which concludes the proof.
  </proof>

  We describe now the ellipsoid method, which only assumes a separation oracle for the constraint set <math|<cX>> (in particular it can be used to solve the feasibility problem mentioned at the beginning of the chapter). Let <math|<cE><rsub|0>> be the Euclidean ball of radius <math|R> that contains <math|<cX>>, and let <math|c<rsub|0>> be its center. Denote also <math|H<rsub|0>=R<rsup|2><mI><rsub|n>>. For <math|t\<geq\>0> do the following:

  <\enumerate>
    <item>If <math|c<rsub|t>\<nin\><cX>> then call the separation oracle to obtain a separating hyperplane <math|w<rsub|t>\<in\><R><rsup|n>> such that <math|<cX>\<subset\><around|{|x:<around|(|x-c<rsub|t>|)><rsup|\<top\>>*w<rsub|t>\<leq\>0|}>>, otherwise call the first order oracle at <math|c<rsub|t>> to obtain <math|w<rsub|t>\<in\>\<partial\>*f<around|(|c<rsub|t>|)>>.

    <item>Let <math|<cE><rsub|t+1>=<around|{|x:<around|(|x-c<rsub|t+1>|)><rsup|\<top\>>*H<rsub|t+1><rsup|-1>*<around|(|x-c<rsub|t+1>|)>\<leq\>1|}>> be the ellipsoid given in Lemma <reference|lem:geomellipsoid> that contains <math|<around|{|x\<in\>\<cal-E\><rsub|t>:<around|(|x-c<rsub|t>|)><rsup|\<top\>>*w<rsub|t>\<leq\>0|}>>, that is

    <\align*>
      <tformat|<table|<row|<cell|>|<cell|c<rsub|t+1>=c<rsub|t>-<frac|1|n+1>*<frac|H<rsub|t>*w|<sqrt|w<rsup|\<top\>>*H<rsub|t>*w>>,>>|<row|<cell|>|<cell|H<rsub|t+1>=<frac|n<rsup|2>|n<rsup|2>-1>*<around*|(|H<rsub|t>-<frac|2|n+1>*<frac|H<rsub|t>*w*w<rsup|\<top\>>*H<rsub|t>|w<rsup|\<top\>>*H<rsub|t>*w>|)>.>>>>
    </align*>
  </enumerate>

  If stopped after <math|t> iterations and if <math|<around|{|c<rsub|1>,\<ldots\>,c<rsub|t>|}>\<cap\><cX>\<neq\>\<emptyset\>>, then we use the zeroth order oracle to output

  <\equation*>
    x<rsub|t>\<in\><argmin><rsub|c\<in\><around|{|c<rsub|1>,\<ldots\>,c<rsub|t>|}>\<cap\><cX>>f<around|(|c<rsub|r>|)>.
  </equation*>

  The following rate of convergence can be proved with the exact same argument than for Theorem <reference|th:centerofgravity> (observe that at step <math|t> one can remove a point in <math|<cX>> from the current ellipsoid only if <math|c<rsub|t>\<in\><cX>>).

  <\theorem>
    For <math|t\<geq\>2*n<rsup|2>*log <around|(|R/r|)>> the ellipsoid method satisfies <math|<around|{|c<rsub|1>,\<ldots\>,c<rsub|t>|}>\<cap\><cX>\<neq\>\<emptyset\>> and

    <\equation*>
      f<around|(|x<rsub|t>|)>-min<rsub|x\<in\>\<cal-X\>> f<around|(|x|)>\<leq\><frac|2*B*R|r>*exp <around*|(|-<frac|t|2*n<rsup|2>>|)>.
    </equation*>
  </theorem>

  We observe that the oracle complexity of the ellipsoid method is much worse than the one of the center gravity method, indeed the former needs <math|O<around|(|n<rsup|2>*log <around|(|1/\<epsilon\>|)>|)>> calls to the oracles while the latter requires only <math|O<around|(|n*log <around|(|1/\<epsilon\>|)>|)>> calls. However from a computational point of view the situation is much better: in many cases one can derive an efficient separation oracle, while the center of gravity method is basically always intractable. This is for instance the case in the context of LPs and SDPs: with the notation of Section <reference|sec:structured> the computational complexity of the separation oracle for LPs is <math|O<around|(|m*n|)>> while for SDPs it is <math|O<around|(|max <around|(|m,n|)>*n<rsup|2>|)>> (we use the fact that the spectral decomposition of a matrix can be done in <math|O<around|(|n<rsup|3>|)>> operations). This gives an overall complexity of <math|O<around|(|max <around|(|m,n|)>*n<rsup|3>*log <around|(|1/\<epsilon\>|)>|)>> for LPs and <math|O<around|(|max <around|(|m,n<rsup|2>|)>*n<rsup|6>*log <around|(|1/\<epsilon\>|)>|)>> for SDPs. We note however that the ellipsoid method is almost never used in practice, essentially because the method is too rigid to exploit the potential easiness of real problems (e.g., the volume decrease given by <eqref|eq:ellipsoidlemma2> is essentially always tight).

  <section|Vaidya's cutting plane method>

  We focus here on the feasibility problem (it should be clear from the previous sections how to adapt the argument for optimization). We have seen that for the feasibility problem the center of gravity has a <math|O<around|(|n|)>> oracle complexity and unclear computational complexity (see Section <reference|sec:rwmethod> for more on this), while the ellipsoid method has oracle complexity <math|O<around|(|n<rsup|2>|)>> and computational complexity <math|O<around|(|n<rsup|4>|)>>. We describe here the beautiful algorithm of <cite|Vai89|Vai96> which has oracle complexity <math|O<around|(|n*log <around|(|n|)>|)>> and computational complexity <math|O<around|(|n<rsup|4>|)>>, thus getting the best of both the center of gravity and the ellipsoid method. In fact the computational complexity can even be improved further, and the recent breakthrough <cite|LSW15> shows that it can essentially (up to logarithmic factors) be brought down to <math|O<around|(|n<rsup|3>|)>>.

  This section, while giving a fundamental algorithm, should probably be skipped on a first reading. In particular we use several concepts from the theory of interior point methods which are described in Section <reference|sec:IPM>.

  <subsection|The volumetric barrier>

  Let <math|A\<in\>\<bbb-R\><rsup|m\<times\>n>> where the <math|i<rsup|t*h>> row is <math|a<rsub|i>\<in\>\<bbb-R\><rsup|n>>, and let <math|b\<in\>\<bbb-R\><rsup|m>>. We consider the logarithmic barrier <math|F> for the polytope <math|<around|{|x\<in\>\<bbb-R\><rsup|n>:A*x\<gtr\>b|}>> defined by

  <\equation*>
    F<around|(|x|)>=-<big|sum><rsub|i=1><rsup|m>log <around|(|a<rsub|i><rsup|\<top\>>*x-b<rsub|i>|)>.
  </equation*>

  We also consider the volumetric barrier <math|v> defined by

  <\equation*>
    v<around|(|x|)>=<frac|1|2><math-up|logdet><around|(|\<nabla\><rsup|2>*F<around|(|x|)>|)>.
  </equation*>

  The intuition is clear: <math|v<around|(|x|)>> is equal to the logarithm of the inverse volume of the Dikin ellipsoid (for the logarithmic barrier) at <math|x>. It will be useful to spell out the hessian of the logarithmic barrier:

  <\equation*>
    \<nabla\><rsup|2>*F<around|(|x|)>=<big|sum><rsub|i=1><rsup|m><frac|a<rsub|i>*a<rsub|i><rsup|\<top\>>|<around|(|a<rsub|i><rsup|\<top\>>*x-b<rsub|i>|)><rsup|2>>.
  </equation*>

  Introducing the leverage score

  <\equation*>
    \<sigma\><rsub|i><around|(|x|)>=<frac|<around|(|\<nabla\><rsup|2>*F<around|(|x|)>|)><rsup|-1><around|[|a<rsub|i>,a<rsub|i>|]>|<around|(|a<rsub|i><rsup|\<top\>>*x-b<rsub|i>|)><rsup|2>>,
  </equation*>

  one can easily verify that

  <\equation>
    <label|eq:gradvol>\<nabla\>*v<around|(|x|)>=-<big|sum><rsub|i=1><rsup|m>\<sigma\><rsub|i><around|(|x|)><frac|a<rsub|i>|a<rsub|i><rsup|\<top\>>*x-b<rsub|i>>,
  </equation>

  and

  <\equation>
    <label|eq:hessianvol>\<nabla\><rsup|2>*v<around|(|x|)>\<succeq\><big|sum><rsub|i=1><rsup|m>\<sigma\><rsub|i><around|(|x|)><frac|a<rsub|i>*a<rsub|i><rsup|\<top\>>|<around|(|a<rsub|i><rsup|\<top\>>*x-b<rsub|i>|)><rsup|2>>=:Q<around|(|x|)>.
  </equation>

  <subsection|Vaidya's algorithm>

  We fix <math|\<epsilon\>\<leq\>0.006> a small constant to be specified later. Vaidya's algorithm produces a sequence of pairs <math|<around|(|A<rsup|<around|(|t|)>>,b<rsup|<around|(|t|)>>|)>\<in\>\<bbb-R\><rsup|m<rsub|t>\<times\>n>\<times\>\<bbb-R\><rsup|m<rsub|t>>> such that the corresponding polytope contains the convex set of interest. The initial polytope defined by <math|<around|(|A<rsup|<around|(|0|)>>,b<rsup|<around|(|0|)>>|)>> is a simplex (in particular <math|m<rsub|0>=n+1>). For <math|t\<geq\>0> we let <math|x<rsub|t>> be the minimizer of the volumetric barrier <math|v<rsub|t>> of the polytope given by <math|<around|(|A<rsup|<around|(|t|)>>,b<rsup|<around|(|t|)>>|)>>, and <math|<around|(|\<sigma\><rsub|i><rsup|<around|(|t|)>>|)><rsub|i\<in\><around|[|m<rsub|t>|]>>> the leverage scores (associated to <math|v<rsub|t>>) at the point <math|x<rsub|t>>. We also denote <math|F<rsub|t>> for the logarithmic barrier given by <math|<around|(|A<rsup|<around|(|t|)>>,b<rsup|<around|(|t|)>>|)>>. The next polytope <math|<around|(|A<rsup|<around|(|t+1|)>>,b<rsup|<around|(|t+1|)>>|)>> is defined by either adding or removing a constraint to the current polytope:

  <\enumerate>
    <item>If for some <math|i\<in\><around|[|m<rsub|t>|]>> one has <math|\<sigma\><rsub|i><rsup|<around|(|t|)>>=min<rsub|j\<in\><around|[|m<rsub|t>|]>> \<sigma\><rsub|j><rsup|<around|(|t|)>>\<less\>\<epsilon\>>, then <math|<around|(|A<rsup|<around|(|t+1|)>>,b<rsup|<around|(|t+1|)>>|)>> is defined by removing the <math|i<rsup|t*h>> row in <math|<around|(|A<rsup|<around|(|t|)>>,b<rsup|<around|(|t|)>>|)>> (in particular <math|m<rsub|t+1>=m<rsub|t>-1>).

    <item>Otherwise let <math|c<rsup|<around|(|t|)>>> be the vector given by the separation oracle queried at <math|x<rsub|t>>, and <math|\<beta\><rsup|<around|(|t|)>>\<in\>\<bbb-R\>> be chosen so that

    <\equation*>
      <frac|<around|(|\<nabla\><rsup|2>*F<rsub|t><around|(|x<rsub|t>|)>|)><rsup|-1><around|[|c<rsup|<around|(|t|)>>,c<rsup|<around|(|t|)>>|]>|<around|(|x<rsub|t><rsup|\<top\>>*c<rsup|<around|(|t|)>>-\<beta\><rsup|<around|(|t|)>>|)><rsup|2>>=<frac|1|5>*<sqrt|\<epsilon\>>.
    </equation*>

    Then we define <math|<around|(|A<rsup|<around|(|t+1|)>>,b<rsup|<around|(|t+1|)>>|)>> by adding to <math|<around|(|A<rsup|<around|(|t|)>>,b<rsup|<around|(|t|)>>|)>> the row given by <math|<around|(|c<rsup|<around|(|t|)>>,\<beta\><rsup|<around|(|t|)>>|)>> (in particular <math|m<rsub|t+1>=m<rsub|t>+1>).
  </enumerate>

  It can be shown that the volumetric barrier is a self-concordant barrier, and thus it can be efficiently minimized with Newton's method. In fact it is enough to do <with|font-shape|italic|one step> of Newton's method on <math|v<rsub|t>> initialized at <math|x<rsub|t-1>>, see <cite|Vai89|Vai96> for more details on this.

  <subsection|Analysis of Vaidya's method><label|sec:analysis>

  The construction of Vaidya's method is based on a precise understanding of how the volumetric barrier changes when one adds or removes a constraint to the polytope. This understanding is derived in Section <reference|sec:constraintsvolumetric>. In particular we obtain the following two key inequalities: If case 1 happens at iteration <math|t> then

  <\equation>
    <label|eq:analysis1>v<rsub|t+1><around|(|x<rsub|t+1>|)>-v<rsub|t><around|(|x<rsub|t>|)>\<geq\>-\<epsilon\>,
  </equation>

  while if case 2 happens then

  <\equation>
    <label|eq:analysis2>v<rsub|t+1><around|(|x<rsub|t+1>|)>-v<rsub|t><around|(|x<rsub|t>|)>\<geq\><frac|1|20>*<sqrt|\<epsilon\>>.
  </equation>

  We show now how these inequalities imply that Vaidya's method stops after <math|O<around|(|n*log <around|(|n*R/r|)>|)>> steps. First we claim that after <math|2*t> iterations, case 2 must have happened at least <math|t-1> times. Indeed suppose that at iteration <math|2*t-1>, case 2 has happened <math|t-2> times; then <math|\<nabla\><rsup|2>*F<around|(|x|)>> is singular and the leverage scores are infinite, so case 2 must happen at iteration <math|2*t>. Combining this claim with the two inequalities above we obtain:

  <\equation*>
    v<rsub|2*t><around|(|x<rsub|2*t>|)>\<geq\>v<rsub|0><around|(|x<rsub|0>|)>+<frac|t-1|20>*<sqrt|\<epsilon\>>-<around|(|t+1|)>*\<epsilon\>\<geq\><frac|t|50>*\<epsilon\>-1+v<rsub|0><around|(|x<rsub|0>|)>.
  </equation*>

  The key point now is to recall that by definition one has <math|v<around|(|x|)>=-log <math-up|vol><around|(|<cE><around|(|x,1|)>|)>> where <math|<cE><around|(|x,r|)>=<around|{|y:\<nabla\>*F<rsup|2><around|(|x|)><around|[|y-x,y-x|]>\<leq\>r<rsup|2>|}>> is the Dikin ellipsoid centered at <math|x> and of radius <math|r>. Moreover the logarithmic barrier <math|F> of a polytope with <math|m> constraints is <math|m>-self-concordant, which implies that the polytope is included in the Dikin ellipsoid <math|<cE><around|(|z,2*m|)>> where <math|z> is the minimizer of <math|F> (see [Theorem 4.2.6., <cite|Nes04>]). The volume of <math|<cE><around|(|z,2*m|)>> is equal to <math|<around|(|2*m|)><rsup|n>*exp <around|(|-v<around|(|z|)>|)>>, which is thus always an upper bound on the volume of the polytope. Combining this with the above display we just proved that at iteration <math|2*k> the volume of the current polytope is at most

  <\equation*>
    exp <around*|(|n*log <around|(|2*m<rsub|2*t>|)>+1-v<rsub|0><around|(|x<rsub|0>|)>-<frac|t|50>*\<epsilon\>|)>.
  </equation*>

  Since <math|<cE><around|(|x,1|)>> is always included in the polytope we have that <math|-v<rsub|0><around|(|x<rsub|0>|)>> is at most the logarithm of the volume of the initial polytope which is <math|O<around|(|n*log <around|(|R|)>|)>>. This clearly concludes the proof as the procedure will necessarily stop when the volume is below <math|exp <around|(|n*log <around|(|r|)>|)>> (we also used the trivial bound <math|m<rsub|t>\<leq\>n+1+t>).

  <subsection|Constraints and the volumetric barrier><label|sec:constraintsvolumetric>

  We want to understand the effect on the volumetric barrier of addition/deletion of constraints to the polytope. Let <math|c\<in\>\<bbb-R\><rsup|n>>, <math|\<beta\>\<in\>\<bbb-R\>>, and consider the logarithmic barrier <math|<wide|F|~>> and the volumetric barrier <math|<wide|v|~>> corresponding to the matrix <math|<wide|A|~>\<in\>\<bbb-R\><rsup|<around|(|m+1|)>\<times\>n>> and the vector <math|<wide|b|~>\<in\>\<bbb-R\><rsup|m+1>> which are respectively the concatenation of <math|A> and <math|c>, and the concatenation of <math|b> and <math|\<beta\>>. Let <math|x<rsup|\<ast\>>> and <math|<wide|x|~><rsup|\<ast\>>> be the minimizer of respectively <math|v> and <math|<wide|v|~>>. We recall the definition of leverage scores, for <math|i\<in\><around|[|m+1|]>>, where <math|a<rsub|m+1>=c> and <math|b<rsub|m+1>=\<beta\>>,

  <\equation*>
    \<sigma\><rsub|i><around|(|x|)>=<frac|<around|(|\<nabla\><rsup|2>*F<around|(|x|)>|)><rsup|-1><around|[|a<rsub|i>,a<rsub|i>|]>|<around|(|a<rsub|i><rsup|\<top\>>*x-b<rsub|i>|)><rsup|2>>,<text|and><wide|\<sigma\>|~><rsub|i><around|(|x|)>=<frac|<around|(|\<nabla\><rsup|2>*<wide|F|~><around|(|x|)>|)><rsup|-1><around|[|a<rsub|i>,a<rsub|i>|]>|<around|(|a<rsub|i><rsup|\<top\>>*x-b<rsub|i>|)><rsup|2>>.
  </equation*>

  The leverage scores <math|\<sigma\><rsub|i>> and <math|<wide|\<sigma\>|~><rsub|i>> are closely related:

  <\lemma>
    <label|lem:V1>One has for any <math|i\<in\><around|[|m+1|]>>,

    <\equation*>
      <frac|<wide|\<sigma\>|~><rsub|m+1><around|(|x|)>|1-<wide|\<sigma\>|~><rsub|m+1><around|(|x|)>>\<geq\>\<sigma\><rsub|i><around|(|x|)>\<geq\><wide|\<sigma\>|~><rsub|i><around|(|x|)>\<geq\><around|(|1-\<sigma\><rsub|m+1><around|(|x|)>|)>*\<sigma\><rsub|i><around|(|x|)>.
    </equation*>
  </lemma>

  <\proof>
    First we observe that by Sherman-Morrison's formula <math|<around|(|A+u*v<rsup|\<top\>>|)><rsup|-1>=A<rsup|-1>-<frac|A<rsup|-1>*u*v<rsup|\<top\>>*A<rsup|-1>|1+A<rsup|-1>*<around|[|u,v|]>>> one has

    <\equation>
      <label|eq:SM><around|(|\<nabla\><rsup|2>*<wide|F|~><around|(|x|)>|)><rsup|-1>=<around|(|\<nabla\><rsup|2>*F<around|(|x|)>|)><rsup|-1>-<frac|<around|(|\<nabla\><rsup|2>*F<around|(|x|)>|)><rsup|-1>*c*c<rsup|\<top\>>*<around|(|\<nabla\><rsup|2>*F<around|(|x|)>|)><rsup|-1>|<around|(|c<rsup|\<top\>>*x-\<beta\>|)><rsup|2>+<around|(|\<nabla\><rsup|2>*F<around|(|x|)>|)><rsup|-1><around|[|c,c|]>>,
    </equation>

    This immediately proves <math|<wide|\<sigma\>|~><rsub|i><around|(|x|)>\<leq\>\<sigma\><rsub|i><around|(|x|)>>. It also implies the inequality <math|<wide|\<sigma\>|~><rsub|i><around|(|x|)>\<geq\><around|(|1-\<sigma\><rsub|m+1><around|(|x|)>|)>*\<sigma\><rsub|i><around|(|x|)>> thanks the following fact: <math|A-<frac|A*u*u<rsup|\<top\>>*A|1+A*<around|[|u,u|]>>\<succeq\><around|(|1-A*<around|[|u,u|]>|)>*A>. For the last inequality we use that <math|A+<frac|A*u*u<rsup|\<top\>>*A|1+A*<around|[|u,u|]>>\<preceq\><frac|1|1-A*<around|[|u,u|]>>*A> together with

    <\equation*>
      <around|(|\<nabla\><rsup|2>*F<around|(|x|)>|)><rsup|-1>=<around|(|\<nabla\><rsup|2>*<wide|F|~><around|(|x|)>|)><rsup|-1>+<frac|<around|(|\<nabla\><rsup|2>*<wide|F|~><around|(|x|)>|)><rsup|-1>*c*c<rsup|\<top\>>*<around|(|\<nabla\><rsup|2>*<wide|F|~><around|(|x|)>|)><rsup|-1>|<around|(|c<rsup|\<top\>>*x-\<beta\>|)><rsup|2>-<around|(|\<nabla\><rsup|2>*<wide|F|~><around|(|x|)>|)><rsup|-1><around|[|c,c|]>>.
    </equation*>
  </proof>

  We now assume the following key result, which was first proven by Vaidya. To put the statement in context recall that for a self-concordant barrier <math|f> the suboptimality gap <math|f<around|(|x|)>-min f> is intimately related to the Newton decrement <math|<around|\<\|\|\>|\<nabla\>*f<around|(|x|)>|\<\|\|\>><rsub|<around|(|\<nabla\><rsup|2>*f<around|(|x|)>|)><rsup|-1>>>. Vaidya's inequality gives a similar claim for the volumetric barrier. We use the version given in [Theorem 2.6, <cite|Ans98>] which has slightly better numerical constants than the original bound. Recall also the definition of <math|Q> from <eqref|eq:hessianvol>.

  <\theorem>
    <label|th:V0>Let <math|\<lambda\><around|(|x|)>=<around|\<\|\|\>|\<nabla\>*v<around|(|x|)>|\<\|\|\>><rsub|Q<around|(|x|)><rsup|-1>>> be an approximate Newton decrement, <math|\<epsilon\>=min<rsub|i\<in\><around|[|m|]>> \<sigma\><rsub|i><around|(|x|)>>, and assume that <math|\<lambda\><around|(|x|)><rsup|2>\<leq\><frac|2*<sqrt|\<epsilon\>>-\<epsilon\>|36>>. Then

    <\equation*>
      v<around|(|x|)>-v<around|(|x<rsup|\<ast\>>|)>\<leq\>2*\<lambda\><around|(|x|)><rsup|2>.
    </equation*>
  </theorem>

  We also denote <math|<wide|\<lambda\>|~>> for the approximate Newton decrement of <math|<wide|v|~>>. The goal for the rest of the section is to prove the following theorem which gives the precise understanding of the volumetric barrier we were looking for.

  <\theorem>
    <label|th:V1>Let <math|\<epsilon\>\<assign\>min<rsub|i\<in\><around|[|m|]>> \<sigma\><rsub|i><around|(|x<rsup|\<ast\>>|)>>, <math|\<delta\>\<assign\>\<sigma\><rsub|m+1><around|(|x<rsup|\<ast\>>|)>/<sqrt|\<epsilon\>>> and assume that <math|<frac|<around*|(|\<delta\>*<sqrt|\<epsilon\>>+<sqrt|\<delta\><rsup|3>*<sqrt|\<epsilon\>>>|)><rsup|2>|1-\<delta\>*<sqrt|\<epsilon\>>>\<less\><frac|2*<sqrt|\<epsilon\>>-\<epsilon\>|36>>. Then one has

    <\equation>
      <label|eq:thV11><wide|v|~><around|(|<wide|x|~><rsup|\<ast\>>|)>-v<around|(|x<rsup|\<ast\>>|)>\<geq\><frac|1|2>*log <around|(|1+\<delta\>*<sqrt|\<epsilon\>>|)>-2*<frac|<around*|(|\<delta\>*<sqrt|\<epsilon\>>+<sqrt|\<delta\><rsup|3>*<sqrt|\<epsilon\>>>|)><rsup|2>|1-\<delta\>*<sqrt|\<epsilon\>>>.
    </equation>

    On the other hand assuming that <math|<wide|\<sigma\>|~><rsub|m+1><around|(|<wide|x|~><rsup|\<ast\>>|)>=min<rsub|i\<in\><around|[|m+1|]>> <wide|\<sigma\>|~><rsub|i><around|(|<wide|x|~><rsup|\<ast\>>|)>=:\<epsilon\>> and that <math|\<epsilon\>\<leq\>1/4>, one has

    <\equation>
      <label|eq:thV12><wide|v|~><around|(|<wide|x|~><rsup|\<ast\>>|)>-v<around|(|x<rsup|\<ast\>>|)>\<leq\>-<frac|1|2>*log <around|(|1-\<epsilon\>|)>+<frac|8*\<epsilon\><rsup|2>|<around|(|1-\<epsilon\>|)><rsup|2>>.
    </equation>
  </theorem>

  Before going into the proof let us see briefly how Theorem <reference|th:V1> give the two inequalities stated at the beginning of Section <reference|sec:analysis>. To prove <eqref|eq:analysis2> we use <eqref|eq:thV11> with <math|\<delta\>=1/5> and <math|\<epsilon\>\<leq\>0.006>, and we observe that in this case the right hand side of <eqref|eq:thV11> is lower bounded by <math|<frac|1|20>*<sqrt|\<epsilon\>>>. On the other hand to prove <eqref|eq:analysis1> we use <eqref|eq:thV12>, and we observe that for <math|\<epsilon\>\<leq\>0.006> the right hand side of <eqref|eq:thV12> is upper bounded by <math|\<epsilon\>>.

  <\proof>
    We start with the proof of <eqref|eq:thV11>. First observe that by factoring <math|<around|(|\<nabla\><rsup|2>*F<around|(|x|)>|)><rsup|1/2>> on the left and on the right of <math|\<nabla\><rsup|2>*<wide|F|~><around|(|x|)>> one obtains

    <\align*>
      <tformat|<table|<row|<cell|>|<cell|<math-up|det><around|(|\<nabla\><rsup|2>*<wide|F|~><around|(|x|)>|)>>>|<row|<cell|>|<cell|=<math-up|det><around*|(|\<nabla\><rsup|2>*F<around|(|x|)>+<frac|c*c<rsup|\<top\>>|<around|(|c<rsup|\<top\>>*x-\<beta\>|)><rsup|2>>|)>>>|<row|<cell|>|<cell|=<math-up|det><around|(|\<nabla\><rsup|2>*F<around|(|x|)>|)><math-up|det><around*|(|<math-up|I><rsub|n>+<frac|<around|(|\<nabla\><rsup|2>*F<around|(|x|)>|)><rsup|-1/2>*c*c<rsup|\<top\>>*<around|(|\<nabla\><rsup|2>*F<around|(|x|)>|)><rsup|-1/2>|<around|(|c<rsup|\<top\>>*x-\<beta\>|)><rsup|2>>|)>>>|<row|<cell|>|<cell|=<math-up|det><around|(|\<nabla\><rsup|2>*F<around|(|x|)>|)>*<around|(|1+\<sigma\><rsub|m+1><around|(|x|)>|)>,>>>>
    </align*>

    and thus

    <\equation*>
      <wide|v|~><around|(|x|)>=v<around|(|x|)>+<frac|1|2>*log <around|(|1+\<sigma\><rsub|m+1><around|(|x|)>|)>.
    </equation*>

    In particular we have

    <\equation*>
      <wide|v|~><around|(|<wide|x|~><rsup|\<ast\>>|)>-v<around|(|x<rsup|\<ast\>>|)>=<frac|1|2>*log <around|(|1+\<sigma\><rsub|m+1><around|(|x<rsup|\<ast\>>|)>|)>-<around|(|<wide|v|~><around|(|x<rsup|\<ast\>>|)>-<wide|v|~><around|(|<wide|x|~><rsup|\<ast\>>|)>|)>.
    </equation*>

    To bound the suboptimality gap of <math|x<rsup|\<ast\>>> in <math|<wide|v|~>> we will invoke Theorem <reference|th:V0> and thus we have to upper bound the approximate Newton decrement <math|<wide|\<lambda\>|~>>. Using [<eqref|eq:V21>, Lemma <reference|lem:V2>] below one has

    <\equation*>
      <wide|\<lambda\>|~><around|(|x<rsup|\<ast\>>|)><rsup|2>\<leq\><frac|<around*|(|\<sigma\><rsub|m+1><around|(|x<rsup|\<ast\>>|)>+<sqrt|<frac|\<sigma\><rsub|m+1><rsup|3><around|(|x<rsup|\<ast\>>|)>|min<rsub|i\<in\><around|[|m|]>> \<sigma\><rsub|i><around|(|x<rsup|\<ast\>>|)>>>|)><rsup|2>|1-\<sigma\><rsub|m+1><around|(|x<rsup|\<ast\>>|)>>=<frac|<around*|(|\<delta\>*<sqrt|\<epsilon\>>+<sqrt|\<delta\><rsup|3>*<sqrt|\<epsilon\>>>|)><rsup|2>|1-\<delta\>*<sqrt|\<epsilon\>>>.
    </equation*>

    This concludes the proof of <eqref|eq:thV11>.

    We now turn to the proof of <eqref|eq:thV12>. Following the same steps as above we immediately obtain

    <\eqnarray*>
      <tformat|<table|<row|<cell|<wide|v|~><around|(|<wide|x|~><rsup|\<ast\>>|)>-v<around|(|x<rsup|\<ast\>>|)>>|<cell|=>|<cell|<wide|v|~><around|(|<wide|x|~><rsup|\<ast\>>|)>-v<around|(|<wide|x|~><rsup|\<ast\>>|)>+v<around|(|<wide|x|~><rsup|\<ast\>>|)>-v<around|(|x<rsup|\<ast\>>|)>>>|<row|<cell|>|<cell|=>|<cell|-<frac|1|2>*log <around|(|1-<wide|\<sigma\>|~><rsub|m+1><around|(|<wide|x|~><rsup|\<ast\>>|)>|)>+v<around|(|<wide|x|~><rsup|\<ast\>>|)>-v<around|(|x<rsup|\<ast\>>|)>.>>>>
    </eqnarray*>

    To invoke Theorem <reference|th:V0> it remains to upper bound <math|\<lambda\><around|(|<wide|x|~><rsup|\<ast\>>|)>>. Using [<eqref|eq:V22>, Lemma <reference|lem:V2>] below one has

    <\equation*>
      \<lambda\><around|(|<wide|x|~><rsup|\<ast\>>|)>\<leq\><frac|2*<wide|\<sigma\>|~><rsub|m+1><around|(|<wide|x|~><rsup|\<ast\>>|)>|1-<wide|\<sigma\>|~><rsub|m+1><around|(|<wide|x|~><rsup|\<ast\>>|)>>.
    </equation*>

    We can apply Theorem <reference|th:V0> since the assumption <math|\<epsilon\>\<leq\>1/4> implies that <math|<around*|(|<frac|2*\<epsilon\>|1-\<epsilon\>>|)><rsup|2>\<leq\><frac|2*<sqrt|\<epsilon\>>-\<epsilon\>|36>>. This concludes the proof of <eqref|eq:thV12>.
  </proof>

  <\lemma>
    <label|lem:V2>One has

    <\equation>
      <label|eq:V21><sqrt|1-\<sigma\><rsub|m+1><around|(|x|)>>*<wide|\<lambda\>|~><around|(|x|)>\<leq\><around|\<\|\|\>|\<nabla\>*v<around|(|x|)>|\<\|\|\>><rsub|Q<around|(|x|)><rsup|-1>>+\<sigma\><rsub|m+1><around|(|x|)>+<sqrt|<frac|\<sigma\><rsub|m+1><rsup|3><around|(|x|)>|min<rsub|i\<in\><around|[|m|]>> \<sigma\><rsub|i><around|(|x|)>>>.
    </equation>

    Furthermore if <math|<wide|\<sigma\>|~><rsub|m+1><around|(|x|)>=min<rsub|i\<in\><around|[|m+1|]>> <wide|\<sigma\>|~><rsub|i><around|(|x|)>> then one also has

    <\equation>
      <label|eq:V22>\<lambda\><around|(|x|)>\<leq\><around|\<\|\|\>|\<nabla\>*<wide|v|~><around|(|x|)>|\<\|\|\>><rsub|Q<around|(|x|)><rsup|-1>>+<frac|2*<wide|\<sigma\>|~><rsub|m+1><around|(|x|)>|1-<wide|\<sigma\>|~><rsub|m+1><around|(|x|)>>.
    </equation>
  </lemma>

  <\proof>
    We start with the proof of <eqref|eq:V21>. First observe that by Lemma <reference|lem:V1> one has <math|<wide|Q|~><around|(|x|)>\<succeq\><around|(|1-\<sigma\><rsub|m+1><around|(|x|)>|)>*Q<around|(|x|)>> and thus by definition of the Newton decrement

    <\equation*>
      <wide|\<lambda\>|~><around|(|x|)>=<around|\<\|\|\>|\<nabla\>*<wide|v|~><around|(|x|)>|\<\|\|\>><rsub|<wide|Q|~><around|(|x|)><rsup|-1>>\<leq\><frac|<around|\<\|\|\>|\<nabla\>*<wide|v|~><around|(|x|)>|\<\|\|\>><rsub|Q<around|(|x|)><rsup|-1>>|<sqrt|1-\<sigma\><rsub|m+1><around|(|x|)>>>.
    </equation*>

    Next observe that (recall <eqref|eq:gradvol>)

    <\equation*>
      \<nabla\>*<wide|v|~><around|(|x|)>=\<nabla\>*v<around|(|x|)>+<big|sum><rsub|i=1><rsup|m><around|(|\<sigma\><rsub|i><around|(|x|)>-<wide|\<sigma\>|~><rsub|i><around|(|x|)>|)>*<frac|a<rsub|i>|a<rsub|i><rsup|\<top\>>*x-b<rsub|i>>-<wide|\<sigma\>|~><rsub|m+1><around|(|x|)><frac|c|c<rsup|\<top\>>*x-\<beta\>>.
    </equation*>

    We now use that <math|Q<around|(|x|)>\<succeq\><around|(|min<rsub|i\<in\><around|[|m|]>> \<sigma\><rsub|i><around|(|x|)>|)>*\<nabla\><rsup|2>*F<around|(|x|)>> to obtain

    <\equation*>
      <around*|\||<wide|\<sigma\>|~><rsub|m+1><around|(|x|)><frac|c|c<rsup|\<top\>>*x-\<beta\>>|\|><rsub|Q<around|(|x|)><rsup|-1>><rsup|2>\<leq\><frac|<wide|\<sigma\>|~><rsub|m+1><rsup|2><around|(|x|)>*\<sigma\><rsub|m+1><around|(|x|)>|min<rsub|i\<in\><around|[|m|]>> \<sigma\><rsub|i><around|(|x|)>>.
    </equation*>

    By Lemma <reference|lem:V1> one has <math|<wide|\<sigma\>|~><rsub|m+1><around|(|x|)>\<leq\>\<sigma\><rsub|m+1><around|(|x|)>> and thus we see that it only remains to prove

    <\equation*>
      <around*|\||<big|sum><rsub|i=1><rsup|m><around|(|\<sigma\><rsub|i><around|(|x|)>-<wide|\<sigma\>|~><rsub|i><around|(|x|)>|)>*<frac|a<rsub|i>|a<rsub|i><rsup|\<top\>>*x-b<rsub|i>>|\|><rsub|Q<around|(|x|)><rsup|-1>><rsup|2>\<leq\>\<sigma\><rsub|m+1><rsup|2><around|(|x|)>.
    </equation*>

    The above inequality follows from a beautiful calculation of Vaidya (see [Lemma 12, <cite|Vai96>]), starting from the identity

    <\equation*>
      \<sigma\><rsub|i><around|(|x|)>-<wide|\<sigma\>|~><rsub|i><around|(|x|)>=<frac|<around|(|<around|(|\<nabla\><rsup|2>*F<around|(|x|)>|)><rsup|-1><around|[|a<rsub|i>,c|]>|)><rsup|2>|<around|(|<around|(|c<rsup|\<top\>>*x-\<beta\>|)><rsup|2>+<around|(|\<nabla\><rsup|2>*F<around|(|x|)>|)><rsup|-1><around|[|c,c|]>|)>*<around|(|a<rsub|i><rsup|\<top\>>*x-b<rsub|i>|)><rsup|2>>,
    </equation*>

    which itself follows from <eqref|eq:SM>.

    We now turn to the proof of <eqref|eq:V22>. Following the same steps as above we immediately obtain

    <\equation*>
      \<lambda\><around|(|x|)>=<around|\<\|\|\>|\<nabla\>*v<around|(|x|)>|\<\|\|\>><rsub|Q<around|(|x|)><rsup|-1>>\<leq\><around|\<\|\|\>|\<nabla\>*<wide|v|~><around|(|x|)>|\<\|\|\>><rsub|Q<around|(|x|)><rsup|-1>>+\<sigma\><rsub|m+1><around|(|x|)>+<sqrt|<frac|<wide|\<sigma\>|~><rsub|m+1><rsup|2><around|(|x|)>*\<sigma\><rsub|m+1><around|(|x|)>|min<rsub|i\<in\><around|[|m|]>> \<sigma\><rsub|i><around|(|x|)>>>.
    </equation*>

    Using Lemma <reference|lem:V1> together with the assumption <math|<wide|\<sigma\>|~><rsub|m+1><around|(|x|)>=min<rsub|i\<in\><around|[|m+1|]>> <wide|\<sigma\>|~><rsub|i><around|(|x|)>> yields <eqref|eq:V22>, thus concluding the proof.
  </proof>

  <section|Conjugate gradient><label|sec:CG>

  We conclude this chapter with the special case of unconstrained optimization of a convex quadratic function <math|f<around|(|x|)>=<frac|1|2>*x<rsup|\<top\>>*A*x-b<rsup|\<top\>>*x>, where <math|A\<in\><R><rsup|n\<times\>n>> is a positive definite matrix and <math|b\<in\><R><rsup|n>>. This problem, of paramount importance in practice (it is equivalent to solving the linear system <math|A*x=b>), admits a simple first-order black-box procedure which attains the <with|font-shape|italic|exact> optimum <math|x<rsup|\<ast\>>> in at most <math|n> steps. This method, called the <with|font-shape|italic|conjugate gradient>, is described and analyzed below. What is written below is taken from [Chapter 5, <cite|NW06>].

  Let <math|<around|\<langle\>|\<cdummy\>,\<cdummy\>|\<rangle\>><rsub|A>> be the inner product on <math|<R><rsup|n>> defined by the positive definite matrix <math|A>, that is <math|<around|\<langle\>|x,y|\<rangle\>><rsub|A>=x<rsup|\<top\>>*A*y> (we also denote by <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>><rsub|A>> the corresponding norm). For sake of clarity we denote here <math|<around|\<langle\>|\<cdummy\>,\<cdummy\>|\<rangle\>>> for the standard inner product in <math|<R><rsup|n>>. Given an orthogonal set <math|<around|{|p<rsub|0>,\<ldots\>,p<rsub|n-1>|}>> for <math|<around|\<langle\>|\<cdummy\>,\<cdummy\>|\<rangle\>><rsub|A>> we will minimize <math|f> by sequentially minimizing it along the directions given by this orthogonal set. That is, given <math|x<rsub|0>\<in\><R><rsup|n>>, for <math|t\<geq\>0> let

  <\equation>
    <label|eq:CG1>x<rsub|t+1>\<assign\><argmin><rsub|x\<in\><around|{|x<rsub|t>+\<lambda\>*p<rsub|t>,\<lambda\>\<in\><R>|}>>f<around|(|x|)>.
  </equation>

  Equivalently one can write

  <\equation>
    <label|eq:CG2>x<rsub|t+1>=x<rsub|t>-<around|\<langle\>|\<nabla\>*f<around|(|x<rsub|t>|)>,p<rsub|t>|\<rangle\>><frac|p<rsub|t>|<around|\<\|\|\>|p<rsub|t>|\<\|\|\>><rsub|A><rsup|2>>.
  </equation>

  The latter identity follows by differentiating <math|\<lambda\>\<mapsto\>f*<around|(|x+\<lambda\>*p<rsub|t>|)>>, and using that <math|\<nabla\>*f<around|(|x|)>=A*x-b>. We also make an observation that will be useful later, namely that <math|x<rsub|t+1>> is the minimizer of <math|f> on <math|x<rsub|0>+<math-up|span><around|{|p<rsub|0>,\<ldots\>,p<rsub|t>|}>>, or equivalently

  <\equation>
    <label|eq:CG3prime><around|\<langle\>|\<nabla\>*f<around|(|x<rsub|t+1>|)>,p<rsub|i>|\<rangle\>>=0,\<forall\>0\<leq\>i\<leq\>t.
  </equation>

  Equation <eqref|eq:CG3prime> is true by construction for <math|i=t>, and for <math|i\<leq\>t-1> it follows by induction, assuming <eqref|eq:CG3prime> at <math|t=1> and using the following formula:

  <\equation>
    <label|eq:CG3>\<nabla\>*f<around|(|x<rsub|t+1>|)>=\<nabla\>*f<around|(|x<rsub|t>|)>-<around|\<langle\>|\<nabla\>*f<around|(|x<rsub|t>|)>,p<rsub|t>|\<rangle\>><frac|A*p<rsub|t>|<around|\<\|\|\>|p<rsub|t>|\<\|\|\>><rsub|A><rsup|2>>.
  </equation>

  We now claim that <math|x<rsub|n>=x<rsup|\<ast\>>=<argmin><rsub|x\<in\><R><rsup|n>>f<around|(|x|)>>. It suffices to show that <math|<around|\<langle\>|x<rsub|n>-x<rsub|0>,p<rsub|t>|\<rangle\>><rsub|A>=<around|\<langle\>|x<rsup|\<ast\>>-x<rsub|0>,p<rsub|t>|\<rangle\>><rsub|A>> for any <math|t\<in\><around|{|0,\<ldots\>,n-1|}>>. Note that <math|x<rsub|n>-x<rsub|0>=-<big|sum><rsub|t=0><rsup|n-1><around|\<langle\>|\<nabla\>*f<around|(|x<rsub|t>|)>,p<rsub|t>|\<rangle\>><frac|p<rsub|t>|<around|\<\|\|\>|p<rsub|t>|\<\|\|\>><rsub|A><rsup|2>>>, and thus using that <math|x<rsup|\<ast\>>=A<rsup|-1>*b>,

  <\eqnarray*>
    <tformat|<table|<row|<cell|<around|\<langle\>|x<rsub|n>-x<rsub|0>,p<rsub|t>|\<rangle\>><rsub|A>=-<around|\<langle\>|\<nabla\>*f<around|(|x<rsub|t>|)>,p<rsub|t>|\<rangle\>>=<around|\<langle\>|b-A*x<rsub|t>,p<rsub|t>|\<rangle\>>>|<cell|=>|<cell|<around|\<langle\>|x<rsup|\<ast\>>-x<rsub|t>,p<rsub|t>|\<rangle\>><rsub|A>>>|<row|<cell|>|<cell|=>|<cell|<around|\<langle\>|x<rsup|\<ast\>>-x<rsub|0>,p<rsub|t>|\<rangle\>><rsub|A>,>>>>
  </eqnarray*>

  which concludes the proof of <math|x<rsub|n>=x<rsup|\<ast\>>>.

  In order to have a proper black-box method it remains to describe how to build iteratively the orthogonal set <math|<around|{|p<rsub|0>,\<ldots\>,p<rsub|n-1>|}>> based only on gradient evaluations of <math|f>. A natural guess to obtain a set of orthogonal directions (w.r.t. <math|<around|\<langle\>|\<cdummy\>,\<cdummy\>|\<rangle\>><rsub|A>>) is to take <math|p<rsub|0>=\<nabla\>*f<around|(|x<rsub|0>|)>> and for <math|t\<geq\>1>,

  <\equation>
    <label|eq:CG4>p<rsub|t>=\<nabla\>*f<around|(|x<rsub|t>|)>-<around|\<langle\>|\<nabla\>*f<around|(|x<rsub|t>|)>,p<rsub|t-1>|\<rangle\>><rsub|A><frac|p<rsub|t-1>|<around|\<\|\|\>|p<rsub|t-1>|\<\|\|\>><rsup|2><rsub|A>>.
  </equation>

  Let us first verify by induction on <math|t\<in\><around|[|n-1|]>> that for any <math|i\<in\><around|{|0,\<ldots\>,t-2|}>>, <math|<around|\<langle\>|p<rsub|t>,p<rsub|i>|\<rangle\>><rsub|A>=0> (observe that for <math|i=t-1> this is true by construction of <math|p<rsub|t>>). Using the induction hypothesis one can see that it is enough to show <math|<around|\<langle\>|\<nabla\>*f<around|(|x<rsub|t>|)>,p<rsub|i>|\<rangle\>><rsub|A>=0> for any <math|i\<in\><around|{|0,\<ldots\>,t-2|}>>, which we prove now. First observe that by induction one easily obtains <math|A*p<rsub|i>\<in\><math-up|span><around|{|p<rsub|0>,\<ldots\>,p<rsub|i+1>|}>> from <eqref|eq:CG3> and <eqref|eq:CG4>. Using this fact together with <math|<around|\<langle\>|\<nabla\>*f<around|(|x<rsub|t>|)>,p<rsub|i>|\<rangle\>><rsub|A>=<around|\<langle\>|\<nabla\>*f<around|(|x<rsub|t>|)>,A*p<rsub|i>|\<rangle\>>> and <eqref|eq:CG3prime> thus concludes the proof of orthogonality of the set <math|<around|{|p<rsub|0>,\<ldots\>,p<rsub|n-1>|}>>.

  We still have to show that <eqref|eq:CG4> can be written by making only reference to the gradients of <math|f> at previous points. Recall that <math|x<rsub|t+1>> is the minimizer of <math|f> on <math|x<rsub|0>+<math-up|span><around|{|p<rsub|0>,\<ldots\>,p<rsub|t>|}>>, and thus given the form of <math|p<rsub|t>> we also have that <math|x<rsub|t+1>> is the minimizer of <math|f> on <math|x<rsub|0>+<math-up|span><around|{|\<nabla\>*f<around|(|x<rsub|0>|)>,\<ldots\>,\<nabla\>*f<around|(|x<rsub|t>|)>|}>> (in some sense the conjugate gradient is the <with|font-shape|italic|optimal> first order method for convex quadratic functions). In particular one has <math|<around|\<langle\>|\<nabla\>*f<around|(|x<rsub|t+1>|)>,\<nabla\>*f<around|(|x<rsub|t>|)>|\<rangle\>>=0>. This fact, together with the orthogonality of the set <math|<around|{|p<rsub|t>|}>> and <eqref|eq:CG3>, imply that

  <\equation*>
    <frac|<around|\<langle\>|\<nabla\>*f<around|(|x<rsub|t+1>|)>,p<rsub|t>|\<rangle\>><rsub|A>|<around|\<\|\|\>|p<rsub|t>|\<\|\|\>><rsub|A><rsup|2>>=<around|\<langle\>|\<nabla\>*f<around|(|x<rsub|t+1>|)>,<frac|A*p<rsub|t>|<around|\<\|\|\>|p<rsub|t>|\<\|\|\>><rsub|A><rsup|2>>|\<rangle\>>=-<frac|<around|\<langle\>|\<nabla\>*f<around|(|x<rsub|t+1>|)>,\<nabla\>*f<around|(|x<rsub|t+1>|)>|\<rangle\>>|<around|\<langle\>|\<nabla\>*f<around|(|x<rsub|t>|)>,p<rsub|t>|\<rangle\>>>.
  </equation*>

  Furthermore using the definition <eqref|eq:CG4> and <math|<around|\<langle\>|\<nabla\>*f<around|(|x<rsub|t>|)>,p<rsub|t-1>|\<rangle\>>=0> one also has

  <\equation*>
    <around|\<langle\>|\<nabla\>*f<around|(|x<rsub|t>|)>,p<rsub|t>|\<rangle\>>=<around|\<langle\>|\<nabla\>*f<around|(|x<rsub|t>|)>,\<nabla\>*f<around|(|x<rsub|t>|)>|\<rangle\>>.
  </equation*>

  Thus we arrive at the following rewriting of the (linear) conjugate gradient algorithm, where we recall that <math|x<rsub|0>> is some fixed starting point and <math|p<rsub|0>=\<nabla\>*f<around|(|x<rsub|0>|)>>,

  <\eqnarray>
    <tformat|<table|<row|<cell|x<rsub|t+1>>|<cell|=>|<cell|<argmin><rsub|x\<in\><around*|{|x<rsub|t>+\<lambda\>*p<rsub|t>,\<lambda\>\<in\><R>|}>>f<around|(|x|)>,<eq-number><label|eq:CG5>>>|<row|<cell|p<rsub|t+1>>|<cell|=>|<cell|\<nabla\>*f<around|(|x<rsub|t+1>|)>+<frac|<around|\<langle\>|\<nabla\>*f<around|(|x<rsub|t+1>|)>,\<nabla\>*f<around|(|x<rsub|t+1>|)>|\<rangle\>>|<around|\<langle\>|\<nabla\>*f<around|(|x<rsub|t>|)>,\<nabla\>*f<around|(|x<rsub|t>|)>|\<rangle\>>>*p<rsub|t>.<eq-number><label|eq:CG6>>>>>
  </eqnarray>

  Observe that the algorithm defined by <eqref|eq:CG5> and <eqref|eq:CG6> makes sense for an arbitary convex function, in which case it is called the <with|font-shape|italic|non-linear conjugate gradient>. There are many variants of the non-linear conjugate gradient, and the above form is known as the Fletcher-–Reeves method. Another popular version in practice is the Polak-Ribière method which is based on the fact that for the general non-quadratic case one does not necessarily have <math|<around|\<langle\>|\<nabla\>*f<around|(|x<rsub|t+1>|)>,\<nabla\>*f<around|(|x<rsub|t>|)>|\<rangle\>>=0>, and thus one replaces <eqref|eq:CG6> by

  <\equation*>
    p<rsub|t+1>=\<nabla\>*f<around|(|x<rsub|t+1>|)>+<frac|<around|\<langle\>|\<nabla\>*f<around|(|x<rsub|t+1>|)>-\<nabla\>*f<around|(|x<rsub|t>|)>,\<nabla\>*f<around|(|x<rsub|t+1>|)>|\<rangle\>>|<around|\<langle\>|\<nabla\>*f<around|(|x<rsub|t>|)>,\<nabla\>*f<around|(|x<rsub|t>|)>|\<rangle\>>>*p<rsub|t>.
  </equation*>

  We refer to <cite|NW06> for more details about these algorithms, as well as for advices on how to deal with the line search in <eqref|eq:CG5>.

  Finally we also note that the linear conjugate gradient method can often attain an approximate solution in much fewer than <math|n> steps. More precisely, denoting <math|\<kappa\>> for the condition number of <math|A> (that is the ratio of the largest eigenvalue to the smallest eigenvalue of <math|A>), one can show that linear conjugate gradient attains an <math|\<epsilon\>> optimal point in a number of iterations of order <math|<sqrt|\<kappa\>>*log <around|(|1/\<epsilon\>|)>>. The next chapter will demistify this convergence rate, and in particular we will see that (i) this is the optimal rate among first order methods, and (ii) there is a way to generalize this rate to non-quadratic convex functions (though the algorithm will have to be modified).

  <chapter|Dimension-free convex optimization><label|dimfree>

  We investigate here variants of the <with|font-shape|italic|gradient descent> scheme. This iterative algorithm, which can be traced back to <cite|Cau47>, is the simplest strategy to minimize a differentiable function <math|f> on <math|<R><rsup|n>>. Starting at some initial point <math|x<rsub|1>\<in\><R><rsup|n>> it iterates the following equation:

  <\equation>
    <label|eq:Cau47>x<rsub|t+1>=x<rsub|t>-\<eta\>*\<nabla\>*f<around|(|x<rsub|t>|)>,
  </equation>

  where <math|\<eta\>\<gtr\>0> is a fixed step-size parameter. The rationale behind <eqref|eq:Cau47> is to make a small step in the direction that minimizes the local first order Taylor approximation of <math|f> (also known as the steepest descent direction).

  As we shall see, methods of the type <eqref|eq:Cau47> can obtain an oracle complexity <with|font-shape|italic|independent of the dimension><footnote|Of course the computational complexity remains at least linear in the dimension since one needs to manipulate gradients.>. This feature makes them particularly attractive for optimization in very high dimension.

  Apart from Section <reference|sec:FW>, in this chapter <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>>> denotes the Euclidean norm. The set of constraints <math|<cX>\<subset\><R><rsup|n>> is assumed to be compact and convex. We define the projection operator <math|\<Pi\><rsub|<cX>>> on <math|<cX>> by

  <\equation*>
    \<Pi\><rsub|<cX>><around|(|x|)>=<argmin><rsub|y\<in\>\<cal-X\>><around|\<\|\|\>|x-y|\<\|\|\>>.
  </equation*>

  The following lemma will prove to be useful in our study. It is an easy corollary of Proposition <reference|prop:firstorder>, see also Figure <reference|fig:pythagore>.

  <\lemma>
    <label|lem:todonow>Let <math|x\<in\><cX>> and <math|y\<in\><R><rsup|n>>, then

    <\equation*>
      <around|(|\<Pi\><rsub|<cX>><around|(|y|)>-x|)><rsup|\<top\>>*<around|(|\<Pi\><rsub|<cX>><around|(|y|)>-y|)>\<leq\>0,
    </equation*>

    which also implies <math|<around|\<\|\|\>|\<Pi\><rsub|<cX>><around|(|y|)>-x|\<\|\|\>><rsup|2>+<around|\<\|\|\>|y-\<Pi\><rsub|<cX>><around|(|y|)>|\<\|\|\>><rsup|2>\<leq\><around|\<\|\|\>|y-x|\<\|\|\>><rsup|2>>.
  </lemma>

  <\big-figure>
    <padded-center|<tikzpicture|[scale=4] <clip>(0.4,-0.4) rectangle (-1.2,1.2); <draw*|rotate=30, very thick> (0,0) ellipse (0.5 and 0.7); <node*|tokens=1> (noeud1) at (-0.45,-0.1) [label=right:<math|x>] ; <node*|tokens=1> (noeud2) at (-0.6, 0.8) [label=above left:<math|y>] ; <draw*|\<less\>-\<gtr\>, thick> (noeud1) -- (noeud2) node[midway, below left] <math|<around|\<\|\|\>|y-x|\<\|\|\>>>; <node*|tokens=1> (noeud3) at (-60:-0.7) [label=below right:<math|\<Pi\><rsub|<cX>><around|(|y|)>>] ; <draw*|\<less\>-\<gtr\>, thick> (noeud2) -- (noeud3) node[midway, above right] <math|<around|\<\|\|\>|y-\<Pi\><rsub|<cX>><around|(|y|)>|\<\|\|\>>>; <draw*|\<less\>-\<gtr\>, thick> (noeud1) -- (noeud3) node[midway, right] <math|<around|\<\|\|\>|\<Pi\><rsub|<cX>><around|(|y|)>-x|\<\|\|\>>>; <node>at (0.15,-0.2) <math|<cX>>;>>

    <label|fig:pythagore>
  </big-figure|Illustration of Lemma <reference|lem:todonow>.>

  Unless specified otherwise all the proofs in this chapter are taken from <cite|Nes04> (with slight simplification in some cases).

  <section|Projected subgradient descent for Lipschitz functions><label|sec:psgd>

  In this section we assume that <math|<cX>> is contained in an Euclidean ball centered at <math|x<rsub|1>\<in\><cX>> and of radius <math|R>. Furthermore we assume that <math|f> is such that for any <math|x\<in\><cX>> and any <math|g\<in\>\<partial\>*f<around|(|x|)>> (we assume <math|\<partial\>*f<around|(|x|)>\<neq\>\<emptyset\>>), one has <math|<around|\<\|\|\>|g|\<\|\|\>>\<leq\>L>. Note that by the subgradient inequality and Cauchy-Schwarz this implies that <math|f> is <math|L>-Lipschitz on <math|<cX>>, that is <math|<around|\||f<around|(|x|)>-f<around|(|y|)>|\|>\<leq\>L*<around|\<\|\|\>|x-y|\<\|\|\>>>.

  In this context we make two modifications to the basic gradient descent <eqref|eq:Cau47>. First, obviously, we replace the gradient <math|\<nabla\>*f<around|(|x|)>> (which may not exist) by a subgradient <math|g\<in\>\<partial\>*f<around|(|x|)>>. Secondly, and more importantly, we make sure that the updated point lies in <math|<cX>> by projecting back (if necessary) onto it. This gives the <with|font-shape|italic|projected subgradient descent> algorithm<footnote|In the optimization literature the term ‘‘descent" is reserved for methods such that <math|f<around|(|x<rsub|t+1>|)>\<leq\>f<around|(|x<rsub|t>|)>>. In that sense the projected subgradient descent is not a descent method.> which iterates the following equations for <math|t\<geq\>1>:

  <\align>
    <tformat|<table|<row|<cell|>|<cell|y<rsub|t+1>=x<rsub|t>-\<eta\>*g<rsub|t>,<text|where>g<rsub|t>\<in\>\<partial\>*f<around|(|x<rsub|t>|)>,<eq-number><label|eq:PGD1>>>|<row|<cell|>|<cell|x<rsub|t+1>=\<Pi\><rsub|<cX>><around|(|y<rsub|t+1>|)>.<eq-number><label|eq:PGD2>>>>>
  </align>

  This procedure is illustrated in Figure <reference|fig:pgd>. We prove now a rate of convergence for this method under the above assumptions.

  <\big-figure>
    <padded-center|<tikzpicture|[scale=3] <draw*|rotate=30, very thick> (0,0) ellipse (0.5 and 0.7); <node*|tokens=1> (noeud1) at (-0.25,0.1) [label=below right:<math|x<rsub|t>>] ; <node*|tokens=1> (noeud2) at (-0.8, 0.9) [label=above left:<math|y<rsub|t+1>>] ; <draw*|-\<gtr\>, thick> (noeud1) -- (noeud2) node[midway, left] <tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|>>|<row|<cell|gradient step>>|<row|<cell|<eqref|eq:PGD1>>>>>>; <node*|tokens=1> (noeud3) at (-60:-0.7) [label=below right:<math|x<rsub|t+1>>] ; <draw*|-\<gtr\>, thick> (noeud2) -- (noeud3) node[midway, right] projection <eqref|eq:PGD2>; <node>at (0.3,-0.4) <math|<cX>>;>>

    <label|fig:pgd>
  </big-figure|Illustration of the projected subgradient descent method.>

  <\theorem>
    <label|th:pgd>The projected subgradient descent method with <math|\<eta\>=<frac|R|L*<sqrt|t>>> satisfies

    <\equation*>
      f*<around*|(|<frac|1|t>*<big|sum><rsub|s=1><rsup|t>x<rsub|s>|)>-f<around|(|x<rsup|\<ast\>>|)>\<leq\><frac|R*L|<sqrt|t>>.
    </equation*>
  </theorem>

  <\proof>
    Using the definition of subgradients, the definition of the method, and the elementary identity <math|2*a<rsup|\<top\>>*b=<around|\<\|\|\>|a|\<\|\|\>><rsup|2>+<around|\<\|\|\>|b|\<\|\|\>><rsup|2>-<around|\<\|\|\>|a-b|\<\|\|\>><rsup|2>>, one obtains

    <\eqnarray*>
      <tformat|<table|<row|<cell|f<around|(|x<rsub|s>|)>-f<around|(|x<rsup|\<ast\>>|)>>|<cell|\<leq\>>|<cell|g<rsub|s><rsup|\<top\>>*<around|(|x<rsub|s>-x<rsup|\<ast\>>|)>>>|<row|<cell|>|<cell|=>|<cell|<frac|1|\<eta\>>*<around|(|x<rsub|s>-y<rsub|s+1>|)><rsup|\<top\>>*<around|(|x<rsub|s>-x<rsup|\<ast\>>|)>>>|<row|<cell|>|<cell|=>|<cell|<frac|1|2*\<eta\>>*<around*|(|<around|\<\|\|\>|x<rsub|s>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>+<around|\<\|\|\>|x<rsub|s>-y<rsub|s+1>|\<\|\|\>><rsup|2>-<around|\<\|\|\>|y<rsub|s+1>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>|)>>>|<row|<cell|>|<cell|=>|<cell|<frac|1|2*\<eta\>>*<around*|(|<around|\<\|\|\>|x<rsub|s>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>-<around|\<\|\|\>|y<rsub|s+1>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>|)>+<frac|\<eta\>|2><around|\<\|\|\>|g<rsub|s>|\<\|\|\>><rsup|2>.>>>>
    </eqnarray*>

    Now note that <math|<around|\<\|\|\>|g<rsub|s>|\<\|\|\>>\<leq\>L>, and furthermore by Lemma <reference|lem:todonow>

    <\equation*>
      <around|\<\|\|\>|y<rsub|s+1>-x<rsup|\<ast\>>|\<\|\|\>>\<geq\><around|\<\|\|\>|x<rsub|s+1>-x<rsup|\<ast\>>|\<\|\|\>>.
    </equation*>

    Summing the resulting inequality over <math|s>, and using that <math|<around|\<\|\|\>|x<rsub|1>-x<rsup|\<ast\>>|\<\|\|\>>\<leq\>R> yield

    <\equation*>
      <big|sum><rsub|s=1><rsup|t><around*|(|f<around|(|x<rsub|s>|)>-f<around|(|x<rsup|\<ast\>>|)>|)>\<leq\><frac|R<rsup|2>|2*\<eta\>>+<frac|\<eta\>*L<rsup|2>*t|2>.
    </equation*>

    Plugging in the value of <math|\<eta\>> directly gives the statement (recall that by convexity <math|f*<around|(|<around|(|1/t|)>*<big|sum><rsub|s=1><rsup|t>x<rsub|s>|)>\<leq\><frac|1|t>*<big|sum><rsub|s=1><rsup|t>f<around|(|x<rsub|s>|)>>).
  </proof>

  We will show in Section <reference|sec:chap3LB> that the rate given in Theorem <reference|th:pgd> is unimprovable from a black-box perspective. Thus to reach an <math|\<epsilon\>>-optimal point one needs <math|\<Theta\>*<around|(|1/\<epsilon\><rsup|2>|)>> calls to the oracle. In some sense this is an astonishing result as this complexity is independent<footnote|Observe however that the quantities <math|R> and <math|L> may dependent on the dimension, see Chapter <reference|mirror> for more on this.> of the ambient dimension <math|n>. On the other hand this is also quite disappointing compared to the scaling in <math|log <around|(|1/\<epsilon\>|)>> of the center of gravity and ellipsoid method of Chapter <reference|finitedim>. To put it differently with gradient descent one could hope to reach a reasonable accuracy in very high dimension, while with the ellipsoid method one can reach very high accuracy in reasonably small dimension. A major task in the following sections will be to explore more restrictive assumptions on the function to be optimized in order to have the best of both worlds, that is an oracle complexity independent of the dimension and with a scaling in <math|log <around|(|1/\<epsilon\>|)>>.

  The computational bottleneck of the projected subgradient descent is often the projection step <eqref|eq:PGD2> which is a convex optimization problem by itself. In some cases this problem may admit an analytical solution (think of <math|<cX>> being an Euclidean ball), or an easy and fast combinatorial algorithm to solve it (this is the case for <math|<cX>> being an <math|\<ell\><rsub|1>>-ball, see <cite|MP89>). We will see in Section <reference|sec:FW> a projection-free algorithm which operates under an extra assumption of smoothness on the function to be optimized.

  Finally we observe that the step-size recommended by Theorem <reference|th:pgd> depends on the number of iterations to be performed. In practice this may be an undesirable feature. However using a time-varying step size of the form <math|\<eta\><rsub|s>=<frac|R|L*<sqrt|s>>> one can prove the same rate up to a <math|log t> factor. In any case these step sizes are very small, which is the reason for the slow convergence. In the next section we will see that by assuming <with|font-shape|italic|smoothness> in the function <math|f> one can afford to be much more aggressive. Indeed in this case, as one approaches the optimum the size of the gradients themselves will go to <math|0>, resulting in a sort of “auto-tuning" of the step sizes which does not happen for an arbitrary convex function.

  <section|Gradient descent for smooth functions><label|sec:gdsmooth>

  We say that a continuously differentiable function <math|f> is <math|\<beta\>>-smooth if the gradient <math|\<nabla\>*f> is <math|\<beta\>>-Lipschitz, that is

  <\equation*>
    <around|\<\|\|\>|\<nabla\>*f<around|(|x|)>-\<nabla\>*f<around|(|y|)>|\<\|\|\>>\<leq\>\<beta\>*<around|\<\|\|\>|x-y|\<\|\|\>>.
  </equation*>

  Note that if <math|f> is twice differentiable then this is equivalent to the eigenvalues of the Hessians being smaller than <math|\<beta\>>. In this section we explore potential improvements in the rate of convergence under such a smoothness assumption. In order to avoid technicalities we consider first the unconstrained situation, where <math|f> is a convex and <math|\<beta\>>-smooth function on <math|<R><rsup|n>>. The next theorem shows that <with|font-shape|italic|gradient descent>, which iterates <math|x<rsub|t+1>=x<rsub|t>-\<eta\>*\<nabla\>*f<around|(|x<rsub|t>|)>>, attains a much faster rate in this situation than in the non-smooth case of the previous section.

  <\theorem>
    <label|th:gdsmooth>Let <math|f> be convex and <math|\<beta\>>-smooth on <math|<R><rsup|n>>. Then gradient descent with <math|\<eta\>=<frac|1|\<beta\>>> satisfies

    <\equation*>
      f<around|(|x<rsub|t>|)>-f<around|(|x<rsup|\<ast\>>|)>\<leq\><frac|2*\<beta\>*<around|\<\|\|\>|x<rsub|1>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>|t-1>.
    </equation*>
  </theorem>

  Before embarking on the proof we state a few properties of smooth convex functions.

  <\lemma>
    <label|lem:sand>Let <math|f> be a <math|\<beta\>>-smooth function on <math|<R><rsup|n>>. Then for any <math|x,y\<in\><R><rsup|n>>, one has

    <\equation*>
      <around|\||f<around|(|x|)>-f<around|(|y|)>-\<nabla\>*f<around|(|y|)><rsup|\<top\>>*<around|(|x-y|)>|\|>\<leq\><frac|\<beta\>|2>*<around|\<\|\|\>|x-y|\<\|\|\>><rsup|2>.
    </equation*>
  </lemma>

  <\proof>
    We represent <math|f<around|(|x|)>-f<around|(|y|)>> as an integral, apply Cauchy-Schwarz and then <math|\<beta\>>-smoothness:

    <\align*>
      <tformat|<table|<row|<cell|>|<cell|<around|\||f<around|(|x|)>-f<around|(|y|)>-\<nabla\>*f<around|(|y|)><rsup|\<top\>>*<around|(|x-y|)>|\|>>>|<row|<cell|>|<cell|=<around*|\||<big|int><rsub|0><rsup|1>\<nabla\>*f*<around|(|y+t*<around|(|x-y|)>|)><rsup|\<top\>>*<around|(|x-y|)>*d*t-\<nabla\>*f<around|(|y|)><rsup|\<top\>>*<around|(|x-y|)>|\|>>>|<row|<cell|>|<cell|\<leq\><big|int><rsub|0><rsup|1><around|\<\|\|\>|\<nabla\>*f*<around|(|y+t*<around|(|x-y|)>|)>-\<nabla\>*f<around|(|y|)>|\<\|\|\>>\<cdot\><around|\<\|\|\>|x-y|\<\|\|\>>*d*t>>|<row|<cell|>|<cell|\<leq\><big|int><rsub|0><rsup|1>\<beta\>*t*<around|\<\|\|\>|x-y|\<\|\|\>><rsup|2>*d*t>>|<row|<cell|>|<cell|=<frac|\<beta\>|2>*<around|\<\|\|\>|x-y|\<\|\|\>><rsup|2>.>>>>
    </align*>
  </proof>

  In particular this lemma shows that if <math|f> is convex and <math|\<beta\>>-smooth, then for any <math|x,y\<in\><R><rsup|n>>, one has

  <\equation>
    <label|eq:defaltsmooth>0\<leq\>f<around|(|x|)>-f<around|(|y|)>-\<nabla\>*f<around|(|y|)><rsup|\<top\>>*<around|(|x-y|)>\<leq\><frac|\<beta\>|2>*<around|\<\|\|\>|x-y|\<\|\|\>><rsup|2>.
  </equation>

  This gives in particular the following important inequality to evaluate the improvement in one step of gradient descent:

  <\equation>
    <label|eq:onestepofgd>f*<around*|(|x-<frac|1|\<beta\>>*\<nabla\>*f<around|(|x|)>|)>-f<around|(|x|)>\<leq\>-<frac|1|2*\<beta\>>*<around|\<\|\|\>|\<nabla\>*f<around|(|x|)>|\<\|\|\>><rsup|2>.
  </equation>

  The next lemma, which improves the basic inequality for subgradients under the smoothness assumption, shows that in fact <math|f> is convex and <math|\<beta\>>-smooth if and only if <eqref|eq:defaltsmooth> holds true. In the literature <eqref|eq:defaltsmooth> is often used as a definition of smooth convex functions.

  <\lemma>
    <label|lem:2>Let <math|f> be such that <eqref|eq:defaltsmooth> holds true. Then for any <math|x,y\<in\><R><rsup|n>>, one has

    <\equation*>
      f<around|(|x|)>-f<around|(|y|)>\<leq\>\<nabla\>*f<around|(|x|)><rsup|\<top\>>*<around|(|x-y|)>-<frac|1|2*\<beta\>>*<around|\<\|\|\>|\<nabla\>*f<around|(|x|)>-\<nabla\>*f<around|(|y|)>|\<\|\|\>><rsup|2>.
    </equation*>
  </lemma>

  <\proof>
    Let <math|z=y-<frac|1|\<beta\>>*<around|(|\<nabla\>*f<around|(|y|)>-\<nabla\>*f<around|(|x|)>|)>>. Then one has

    <\align*>
      <tformat|<table|<row|<cell|>|<cell|f<around|(|x|)>-f<around|(|y|)>>>|<row|<cell|>|<cell|=f<around|(|x|)>-f<around|(|z|)>+f<around|(|z|)>-f<around|(|y|)>>>|<row|<cell|>|<cell|\<leq\>\<nabla\>*f<around|(|x|)><rsup|\<top\>>*<around|(|x-z|)>+\<nabla\>*f<around|(|y|)><rsup|\<top\>>*<around|(|z-y|)>+<frac|\<beta\>|2>*<around|\<\|\|\>|z-y|\<\|\|\>><rsup|2>>>|<row|<cell|>|<cell|=\<nabla\>*f<around|(|x|)><rsup|\<top\>>*<around|(|x-y|)>+<around|(|\<nabla\>*f<around|(|x|)>-\<nabla\>*f<around|(|y|)>|)><rsup|\<top\>>*<around|(|y-z|)>+<frac|1|2*\<beta\>>*<around|\<\|\|\>|\<nabla\>*f<around|(|x|)>-\<nabla\>*f<around|(|y|)>|\<\|\|\>><rsup|2>>>|<row|<cell|>|<cell|=\<nabla\>*f<around|(|x|)><rsup|\<top\>>*<around|(|x-y|)>-<frac|1|2*\<beta\>>*<around|\<\|\|\>|\<nabla\>*f<around|(|x|)>-\<nabla\>*f<around|(|y|)>|\<\|\|\>><rsup|2>.>>>>
    </align*>
  </proof>

  We can now prove Theorem <reference|th:gdsmooth>

  <\proof>
    Using <eqref|eq:onestepofgd> and the definition of the method one has

    <\equation*>
      f<around|(|x<rsub|s+1>|)>-f<around|(|x<rsub|s>|)>\<leq\>-<frac|1|2*\<beta\>>*<around|\<\|\|\>|\<nabla\>*f<around|(|x<rsub|s>|)>|\<\|\|\>><rsup|2>.
    </equation*>

    In particular, denoting <math|\<delta\><rsub|s>=f<around|(|x<rsub|s>|)>-f<around|(|x<rsup|\<ast\>>|)>>, this shows:

    <\equation*>
      \<delta\><rsub|s+1>\<leq\>\<delta\><rsub|s>-<frac|1|2*\<beta\>>*<around|\<\|\|\>|\<nabla\>*f<around|(|x<rsub|s>|)>|\<\|\|\>><rsup|2>.
    </equation*>

    One also has by convexity

    <\equation*>
      \<delta\><rsub|s>\<leq\>\<nabla\>*f<around|(|x<rsub|s>|)><rsup|\<top\>>*<around|(|x<rsub|s>-x<rsup|\<ast\>>|)>\<leq\><around|\<\|\|\>|x<rsub|s>-x<rsup|\<ast\>>|\<\|\|\>>\<cdot\><around|\<\|\|\>|\<nabla\>*f<around|(|x<rsub|s>|)>|\<\|\|\>>.
    </equation*>

    We will prove that <math|<around|\<\|\|\>|x<rsub|s>-x<rsup|\<ast\>>|\<\|\|\>>> is decreasing with <math|s>, which with the two above displays will imply

    <\equation*>
      \<delta\><rsub|s+1>\<leq\>\<delta\><rsub|s>-<frac|1|2*\<beta\>*<around|\<\|\|\>|x<rsub|1>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>>*\<delta\><rsub|s><rsup|2>.
    </equation*>

    Let us see how to use this last inequality to conclude the proof. Let <math|\<omega\>=<frac|1|2*\<beta\>*<around|\<\|\|\>|x<rsub|1>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>>>, then<footnote|The last step in the sequence of implications can be improved by taking <math|\<delta\><rsub|1>> into account. Indeed one can easily show with <eqref|eq:defaltsmooth> that <math|\<delta\><rsub|1>\<leq\><frac|1|4*\<omega\>>>. This improves the rate of Theorem <reference|th:gdsmooth> from <math|<frac|2*\<beta\>*<around|\<\|\|\>|x<rsub|1>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>|t-1>> to <math|<frac|2*\<beta\>*<around|\<\|\|\>|x<rsub|1>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>|t+3>>.>

    <\equation*>
      \<omega\>*\<delta\><rsub|s><rsup|2>+\<delta\><rsub|s+1>\<leq\>\<delta\><rsub|s>\<Leftrightarrow\>\<omega\>*<frac|\<delta\><rsub|s>|\<delta\><rsub|s+1>>+<frac|1|\<delta\><rsub|s>>\<leq\><frac|1|\<delta\><rsub|s+1>>\<Rightarrow\><frac|1|\<delta\><rsub|s+1>>-<frac|1|\<delta\><rsub|s>>\<geq\>\<omega\>\<Rightarrow\><frac|1|\<delta\><rsub|t>>\<geq\>\<omega\>*<around|(|t-1|)>.
    </equation*>

    Thus it only remains to show that <math|<around|\<\|\|\>|x<rsub|s>-x<rsup|\<ast\>>|\<\|\|\>>> is decreasing with <math|s>. Using Lemma <reference|lem:2> one immediately gets

    <\equation>
      <label|eq:coercive1><around|(|\<nabla\>*f<around|(|x|)>-\<nabla\>*f<around|(|y|)>|)><rsup|\<top\>>*<around|(|x-y|)>\<geq\><frac|1|\<beta\>>*<around|\<\|\|\>|\<nabla\>*f<around|(|x|)>-\<nabla\>*f<around|(|y|)>|\<\|\|\>><rsup|2>.
    </equation>

    We use this as follows (together with <math|\<nabla\>*f<around|(|x<rsup|\<ast\>>|)>=0>)

    <\eqnarray*>
      <tformat|<table|<row|<cell|<around|\<\|\|\>|x<rsub|s+1>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>>|<cell|=>|<cell|<around|\<\|\|\>|x<rsub|s>-<frac|1|\<beta\>>*\<nabla\>*f<around|(|x<rsub|s>|)>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>>>|<row|<cell|>|<cell|=>|<cell|<around|\<\|\|\>|x<rsub|s>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>-<frac|2|\<beta\>>*\<nabla\>*f<around|(|x<rsub|s>|)><rsup|\<top\>>*<around|(|x<rsub|s>-x<rsup|\<ast\>>|)>+<frac|1|\<beta\><rsup|2>>*<around|\<\|\|\>|\<nabla\>*f<around|(|x<rsub|s>|)>|\<\|\|\>><rsup|2>>>|<row|<cell|>|<cell|\<leq\>>|<cell|<around|\<\|\|\>|x<rsub|s>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>-<frac|1|\<beta\><rsup|2>>*<around|\<\|\|\>|\<nabla\>*f<around|(|x<rsub|s>|)>|\<\|\|\>><rsup|2>>>|<row|<cell|>|<cell|\<leq\>>|<cell|<around|\<\|\|\>|x<rsub|s>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>,>>>>
    </eqnarray*>

    which concludes the proof.
  </proof>

  <subsection*|The constrained case>

  We now come back to the constrained problem

  <\align*>
    <tformat|<table|<row|<cell|>|<cell|<with|math-font-family|rm|min.>*<space|0.27em>f<around|(|x|)>>>|<row|<cell|>|<cell|<text|s.t.><space|0.27em>x\<in\><cX>.>>>>
  </align*>

  Similarly to what we did in Section <reference|sec:psgd> we consider the projected gradient descent algorithm, which iterates <math|x<rsub|t+1>=\<Pi\><rsub|<cX>>*<around|(|x<rsub|t>-\<eta\>*\<nabla\>*f<around|(|x<rsub|t>|)>|)>>.

  The key point in the analysis of gradient descent for unconstrained smooth optimization is that a step of gradient descent started at <math|x> will decrease the function value by at least <math|<frac|1|2*\<beta\>>*<around|\<\|\|\>|\<nabla\>*f<around|(|x|)>|\<\|\|\>><rsup|2>>, see <eqref|eq:onestepofgd>. In the constrained case we cannot expect that this would still hold true as a step may be cut short by the projection. The next lemma defines the “right" quantity to measure progress in the constrained case.

  <\lemma>
    <label|lem:smoothconst>Let <math|x,y\<in\><cX>>, <math|x<rsup|+>=\<Pi\><rsub|<cX>>*<around*|(|x-<frac|1|\<beta\>>*\<nabla\>*f<around|(|x|)>|)>>, and <math|g<rsub|<cX>><around|(|x|)>=\<beta\>*<around|(|x-x<rsup|+>|)>>. Then the following holds true:

    <\equation*>
      f<around|(|x<rsup|+>|)>-f<around|(|y|)>\<leq\>g<rsub|<cX>><around|(|x|)><rsup|\<top\>>*<around|(|x-y|)>-<frac|1|2*\<beta\>><around|\<\|\|\>|g<rsub|<cX>><around|(|x|)>|\<\|\|\>><rsup|2>.
    </equation*>
  </lemma>

  <\proof>
    We first observe that

    <\equation>
      <label|eq:chap3eq1>\<nabla\>*f<around|(|x|)><rsup|\<top\>>*<around|(|x<rsup|+>-y|)>\<leq\>g<rsub|<cX>><around|(|x|)><rsup|\<top\>>*<around|(|x<rsup|+>-y|)>.
    </equation>

    Indeed the above inequality is equivalent to

    <\equation*>
      <around*|(|x<rsup|+>-<around*|(|x-<frac|1|\<beta\>>*\<nabla\>*f<around|(|x|)>|)>|)><rsup|\<top\>>*<around|(|x<rsup|+>-y|)>\<leq\>0,
    </equation*>

    which follows from Lemma <reference|lem:todonow>. Now we use <eqref|eq:chap3eq1> as follows to prove the lemma (we also use <eqref|eq:defaltsmooth> which still holds true in the constrained case)

    <\align*>
      <tformat|<table|<row|<cell|>|<cell|f<around|(|x<rsup|+>|)>-f<around|(|y|)>>>|<row|<cell|>|<cell|=f<around|(|x<rsup|+>|)>-f<around|(|x|)>+f<around|(|x|)>-f<around|(|y|)>>>|<row|<cell|>|<cell|\<leq\>\<nabla\>*f<around|(|x|)><rsup|\<top\>>*<around|(|x<rsup|+>-x|)>+<frac|\<beta\>|2>\<\|\|\>x<rsup|+>-x\<\|\|\><rsup|2>+\<nabla\>*f<around|(|x|)><rsup|\<top\>>*<around|(|x-y|)>>>|<row|<cell|>|<cell|=\<nabla\>*f<around|(|x|)><rsup|\<top\>>*<around|(|x<rsup|+>-y|)>+<frac|1|2*\<beta\>><around|\<\|\|\>|g<rsub|<cX>><around|(|x|)>|\<\|\|\>><rsup|2>>>|<row|<cell|>|<cell|\<leq\>g<rsub|<cX>><around|(|x|)><rsup|\<top\>>*<around|(|x<rsup|+>-y|)>+<frac|1|2*\<beta\>><around|\<\|\|\>|g<rsub|<cX>><around|(|x|)>|\<\|\|\>><rsup|2>>>|<row|<cell|>|<cell|=g<rsub|<cX>><around|(|x|)><rsup|\<top\>>*<around|(|x-y|)>-<frac|1|2*\<beta\>><around|\<\|\|\>|g<rsub|<cX>><around|(|x|)>|\<\|\|\>><rsup|2>.>>>>
    </align*>
  </proof>

  We can now prove the following result.

  <\theorem>
    <label|th:gdsmoothconstrained>Let <math|f> be convex and <math|\<beta\>>-smooth on <math|<cX>>. Then projected gradient descent with <math|\<eta\>=<frac|1|\<beta\>>> satisfies

    <\equation*>
      f<around|(|x<rsub|t>|)>-f<around|(|x<rsup|\<ast\>>|)>\<leq\><frac|3*\<beta\>\<\|\|\>x<rsub|1>-x<rsup|\<ast\>>\<\|\|\><rsup|2>+f<around|(|x<rsub|1>|)>-f<around|(|x<rsup|\<ast\>>|)>|t>.
    </equation*>
  </theorem>

  <\proof>
    Lemma <reference|lem:smoothconst> immediately gives

    <\equation*>
      f<around|(|x<rsub|s+1>|)>-f<around|(|x<rsub|s>|)>\<leq\>-<frac|1|2*\<beta\>><around|\<\|\|\>|g<rsub|<cX>><around|(|x<rsub|s>|)>|\<\|\|\>><rsup|2>,
    </equation*>

    and

    <\equation*>
      f<around|(|x<rsub|s+1>|)>-f<around|(|x<rsup|\<ast\>>|)>\<leq\><around|\<\|\|\>|g<rsub|<cX>><around|(|x<rsub|s>|)>|\<\|\|\>>\<cdot\><around|\<\|\|\>|x<rsub|s>-x<rsup|\<ast\>>|\<\|\|\>>.
    </equation*>

    We will prove that <math|<around|\<\|\|\>|x<rsub|s>-x<rsup|\<ast\>>|\<\|\|\>>> is decreasing with <math|s>, which with the two above displays will imply

    <\equation*>
      \<delta\><rsub|s+1>\<leq\>\<delta\><rsub|s>-<frac|1|2*\<beta\>*<around|\<\|\|\>|x<rsub|1>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>>*\<delta\><rsub|s+1><rsup|2>.
    </equation*>

    An easy induction shows that

    <\equation*>
      \<delta\><rsub|s>\<leq\><frac|3*\<beta\>\<\|\|\>x<rsub|1>-x<rsup|\<ast\>>\<\|\|\><rsup|2>+f<around|(|x<rsub|1>|)>-f<around|(|x<rsup|\<ast\>>|)>|s>.
    </equation*>

    Thus it only remains to show that <math|<around|\<\|\|\>|x<rsub|s>-x<rsup|\<ast\>>|\<\|\|\>>> is decreasing with <math|s>. Using Lemma <reference|lem:smoothconst> one can see that <math|g<rsub|<cX>><around|(|x<rsub|s>|)><rsup|\<top\>>*<around|(|x<rsub|s>-x<rsup|\<ast\>>|)>\<geq\><frac|1|2*\<beta\>><around|\<\|\|\>|g<rsub|<cX>><around|(|x<rsub|s>|)>|\<\|\|\>><rsup|2>> which implies

    <\eqnarray*>
      <tformat|<table|<row|<cell|<around|\<\|\|\>|x<rsub|s+1>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>>|<cell|=>|<cell|<around|\<\|\|\>|x<rsub|s>-<frac|1|\<beta\>>*g<rsub|<cX>><around|(|x<rsub|s>|)>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>>>|<row|<cell|>|<cell|=>|<cell|<around|\<\|\|\>|x<rsub|s>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>-<frac|2|\<beta\>>*g<rsub|<cX>><around|(|x<rsub|s>|)><rsup|\<top\>>*<around|(|x<rsub|s>-x<rsup|\<ast\>>|)>+<frac|1|\<beta\><rsup|2>><around|\<\|\|\>|g<rsub|<cX>><around|(|x<rsub|s>|)>|\<\|\|\>><rsup|2>>>|<row|<cell|>|<cell|\<leq\>>|<cell|<around|\<\|\|\>|x<rsub|s>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>.>>>>
    </eqnarray*>
  </proof>

  <section|Conditional gradient descent, aka Frank-Wolfe><label|sec:FW>

  We describe now an alternative algorithm to minimize a smooth convex function <math|f> over a compact convex set <math|\<cal-X\>>. The <with|font-shape|italic|conditional gradient descent>, introduced in <cite|FW56>, performs the following update for <math|t\<geq\>1>, where <math|<around|(|\<gamma\><rsub|s>|)><rsub|s\<geq\>1>> is a fixed sequence,

  <\align>
    <tformat|<table|<row|<cell|>|<cell|y<rsub|t>\<in\><math-up|argmin><rsub|y\<in\>\<cal-X\>>\<nabla\>*f<around|(|x<rsub|t>|)><rsup|\<top\>>*y<eq-number><label|eq:FW1>>>|<row|<cell|>|<cell|x<rsub|t+1>=<around|(|1-\<gamma\><rsub|t>|)>*x<rsub|t>+\<gamma\><rsub|t>*y<rsub|t>.<eq-number><label|eq:FW2>>>>>
  </align>

  In words conditional gradient descent makes a step in the steepest descent direction <with|font-shape|italic|given the constraint set <math|<cX>>>, see Figure <reference|fig:FW> for an illustration. From a computational perspective, a key property of this scheme is that it replaces the projection step of projected gradient descent by a linear optimization over <math|<cX>>, which in some cases can be a much simpler problem.

  <\big-figure>
    <padded-center|<tikzpicture|[scale=3] <node*|tokens=1> (noeud1) at (0.1,-0.1) [label=below right:<math|x<rsub|t>>] ; <node*|tokens=1> (noeud2) at (-0.38,0.65) [label=above left:<math|y<rsub|t>>] ; <draw*|-\<gtr\>, thick> (noeud1) -- (-0.05, 0.4) node[midway, right] <math|-\<nabla\>*f<around|(|x<rsub|t>|)>>; <node*|tokens=1> (noeud3) at (-0.065,0.15) [label=below left:<math|x<rsub|t+1>>] ; <draw*|thick, dashed> (noeud1) -- (noeud2) ; <node>at (0.3,-0.55) <math|<cX>>; <node>(S) [very thick, regular polygon, regular polygon sides=6, draw, inner sep=40] at (0,0) ;>>

    <label|fig:FW>
  </big-figure|Illustration of conditional gradient descent.>

  We now turn to the analysis of this method. A major advantage of conditional gradient descent over projected gradient descent is that the former can adapt to smoothness in an arbitrary norm. Precisely let <math|f> be <math|\<beta\>>-smooth in some norm <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>>>, that is <math|<around|\<\|\|\>|\<nabla\>*f<around|(|x|)>-\<nabla\>*f<around|(|y|)>|\<\|\|\>><rsub|\<ast\>>\<leq\>\<beta\>*<around|\<\|\|\>|x-y|\<\|\|\>>> where the dual norm <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>><rsub|\<ast\>>> is defined as <math|<around|\<\|\|\>|g|\<\|\|\>><rsub|\<ast\>>=sup<rsub|x\<in\>\<bbb-R\><rsup|n>:<around|\<\|\|\>|x|\<\|\|\>>\<leq\>1> g<rsup|\<top\>>*x>. The following result is extracted from <cite|Jag13> (see also <cite|DH78>).

  <\theorem>
    Let <math|f> be a convex and <math|\<beta\>>-smooth function w.r.t. some norm <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>>>, <math|R=sup<rsub|x,y\<in\>\<cal-X\>><around|\<\|\|\>|x-y|\<\|\|\>>>, and <math|\<gamma\><rsub|s>=<frac|2|s+1>> for <math|s\<geq\>1>. Then for any <math|t\<geq\>2>, one has

    <\equation*>
      f<around|(|x<rsub|t>|)>-f<around|(|x<rsup|\<ast\>>|)>\<leq\><frac|2*\<beta\>*R<rsup|2>|t+1>.
    </equation*>
  </theorem>

  <\proof>
    The following inequalities hold true, using respectively <math|\<beta\>>-smoothness (it can easily be seen that <eqref|eq:defaltsmooth> holds true for smoothness in an arbitrary norm), the definition of <math|x<rsub|s+1>>, the definition of <math|y<rsub|s>>, and the convexity of <math|f>:

    <\eqnarray*>
      <tformat|<table|<row|<cell|f<around|(|x<rsub|s+1>|)>-f<around|(|x<rsub|s>|)>>|<cell|\<leq\>>|<cell|\<nabla\>*f<around|(|x<rsub|s>|)><rsup|\<top\>>*<around|(|x<rsub|s+1>-x<rsub|s>|)>+<frac|\<beta\>|2>*<around|\<\|\|\>|x<rsub|s+1>-x<rsub|s>|\<\|\|\>><rsup|2>>>|<row|<cell|>|<cell|\<leq\>>|<cell|\<gamma\><rsub|s>*\<nabla\>*f<around|(|x<rsub|s>|)><rsup|\<top\>>*<around|(|y<rsub|s>-x<rsub|s>|)>+<frac|\<beta\>|2>*\<gamma\><rsub|s><rsup|2>*R<rsup|2>>>|<row|<cell|>|<cell|\<leq\>>|<cell|\<gamma\><rsub|s>*\<nabla\>*f<around|(|x<rsub|s>|)><rsup|\<top\>>*<around|(|x<rsup|\<ast\>>-x<rsub|s>|)>+<frac|\<beta\>|2>*\<gamma\><rsub|s><rsup|2>*R<rsup|2>>>|<row|<cell|>|<cell|\<leq\>>|<cell|\<gamma\><rsub|s>*<around|(|f<around|(|x<rsup|\<ast\>>|)>-f<around|(|x<rsub|s>|)>|)>+<frac|\<beta\>|2>*\<gamma\><rsub|s><rsup|2>*R<rsup|2>.>>>>
    </eqnarray*>

    Rewriting this inequality in terms of <math|\<delta\><rsub|s>=f<around|(|x<rsub|s>|)>-f<around|(|x<rsup|\<ast\>>|)>> one obtains

    <\equation*>
      \<delta\><rsub|s+1>\<leq\><around|(|1-\<gamma\><rsub|s>|)>*\<delta\><rsub|s>+<frac|\<beta\>|2>*\<gamma\><rsub|s><rsup|2>*R<rsup|2>.
    </equation*>

    A simple induction using that <math|\<gamma\><rsub|s>=<frac|2|s+1>> finishes the proof (note that the initialization is done at step <math|2> with the above inequality yielding <math|\<delta\><rsub|2>\<leq\><frac|\<beta\>|2>*R<rsup|2>>).
  </proof>

  In addition to being projection-free and “norm-free", the conditional gradient descent satisfies a perhaps even more important property: it produces <with|font-shape|italic|sparse iterates>. More precisely consider the situation where <math|<cX>\<subset\><R><rsup|n>> is a polytope, that is the convex hull of a finite set of points (these points are called the vertices of <math|<cX>>). Then Carathéodory's theorem states that any point <math|x\<in\><cX>> can be written as a convex combination of at most <math|n+1> vertices of <math|<cX>>. On the other hand, by definition of the conditional gradient descent, one knows that the <math|t<rsup|t*h>> iterate <math|x<rsub|t>> can be written as a convex combination of <math|t> vertices (assuming that <math|x<rsub|1>> is a vertex). Thanks to the dimension-free rate of convergence one is usually interested in the regime where <math|t\<ll\>n>, and thus we see that the iterates of conditional gradient descent are very sparse in their vertex representation.

  We note an interesting corollary of the sparsity property together with the rate of convergence we proved: smooth functions on the simplex <math|<around|{|x\<in\>\<bbb-R\><rsub|+><rsup|n>:<big|sum><rsub|i=1><rsup|n>x<rsub|i>=1|}>> always admit sparse approximate minimizers. More precisely there must exist a point <math|x> with only <math|t> non-zero coordinates and such that <math|f<around|(|x|)>-f<around|(|x<rsup|\<ast\>>|)>=O<around|(|1/t|)>>. Clearly this is the best one can hope for in general, as it can be seen with the function <math|f<around|(|x|)>=<around|\<\|\|\>|x|\<\|\|\>><rsup|2><rsub|2>> since by Cauchy-Schwarz one has <math|<around|\<\|\|\>|x|\<\|\|\>><rsub|1>\<leq\><sqrt|<around|\<\|\|\>|x|\<\|\|\>><rsub|0>><around|\<\|\|\>|x|\<\|\|\>><rsub|2>> which implies on the simplex <math|<around|\<\|\|\>|x|\<\|\|\>><rsub|2><rsup|2>\<geq\>1/<around|\<\|\|\>|x|\<\|\|\>><rsub|0>>.

  Next we describe an application where the three properties of conditional gradient descent (projection-free, norm-free, and sparse iterates) are critical to develop a computationally efficient procedure.

  <subsection*|An application of conditional gradient descent: Least-squares regression with structured sparsity>

  This example is inspired by <cite|Lug10> (see also <cite|Jon92>). Consider the problem of approximating a signal <math|Y\<in\>\<bbb-R\><rsup|n>> by a “small" combination of dictionary elements <math|d<rsub|1>,\<ldots\>,d<rsub|N>\<in\>\<bbb-R\><rsup|n>>. One way to do this is to consider a LASSO type problem in dimension <math|N> of the following form (with <math|\<lambda\>\<in\><R>> fixed)

  <\equation*>
    min<rsub|x\<in\>\<bbb-R\><rsup|N>><mid|\|>Y-<big|sum><rsub|i=1><rsup|N>x<around|(|i|)>*d<rsub|i><mid|\|><rsub|2><rsup|2>+\<lambda\><around|\<\|\|\>|x|\<\|\|\>><rsub|1>.
  </equation*>

  Let <math|D\<in\>\<bbb-R\><rsup|n\<times\>N>> be the dictionary matrix with <math|i<rsup|t*h>> column given by <math|d<rsub|i>>. Instead of considering the penalized version of the problem one could look at the following constrained problem (with <math|s\<in\><R>> fixed) on which we will now focus, see e.g. <cite|FT07>,

  <\eqnarray>
    <tformat|<table|<row|<cell|min<rsub|x\<in\>\<bbb-R\><rsup|N>><around|\<\|\|\>|Y-D*x|\<\|\|\>><rsub|2><rsup|2>>|<cell|<space|2em>\<Leftrightarrow\><space|2em>>|<cell|min<rsub|x\<in\>\<bbb-R\><rsup|N>><around|\<\|\|\>|Y/s-D*x|\<\|\|\>><rsub|2><rsup|2><eq-number><label|eq:structuredsparsity>>>|<row|<cell|<text|subject to><space|0.27em><around|\<\|\|\>|x|\<\|\|\>><rsub|1>\<leq\>s>|<cell|>|<cell|<text|subject to><space|0.27em><around|\<\|\|\>|x|\<\|\|\>><rsub|1>\<leq\>1.<eq-number>>>>>
  </eqnarray>

  We make some assumptions on the dictionary. We are interested in situations where the size of the dictionary <math|N> can be very large, potentially exponential in the ambient dimension <math|n>. Nonetheless we want to restrict our attention to algorithms that run in reasonable time with respect to the ambient dimension <math|n>, that is we want polynomial time algorithms in <math|n>. Of course in general this is impossible, and we need to assume that the dictionary has some structure that can be exploited. Here we make the assumption that one can do <with|font-shape|italic|linear optimization> over the dictionary in polynomial time in <math|n>. More precisely we assume that one can solve in time <math|p<around|(|n|)>> (where <math|p> is polynomial) the following problem for any <math|y\<in\>\<bbb-R\><rsup|n>>:

  <\equation*>
    min<rsub|1\<leq\>i\<leq\>N> y<rsup|\<top\>>*d<rsub|i>.
  </equation*>

  This assumption is met for many <with|font-shape|italic|combinatorial> dictionaries. For instance the dic\<hyphen\>tio\<hyphen\>nary ele\<hyphen\>ments could be vec\<hyphen\>tor of inci\<hyphen\>dence of span\<hyphen\>ning trees in some fixed graph, in which case the lin\<hyphen\>ear opti\<hyphen\>miza\<hyphen\>tion prob\<hyphen\>lem can be solved with a greedy algorithm.

  Finally, for normalization issues, we assume that the <math|\<ell\><rsub|2>>-norm of the dictionary elements are controlled by some <math|m\<gtr\>0>, that is <math|<around|\<\|\|\>|d<rsub|i>|\<\|\|\>><rsub|2>\<leq\>m,\<forall\>i\<in\><around|[|N|]>>.

  Our problem of interest <eqref|eq:structuredsparsity> corresponds to minimizing the function <math|f<around|(|x|)>=<frac|1|2>*<around|\<\|\|\>|Y-D*x|\<\|\|\>><rsup|2><rsub|2>> on the <math|\<ell\><rsub|1>>-ball of <math|\<bbb-R\><rsup|N>> in polynomial time in <math|n>. At first sight this task may seem completely impossible, indeed one is not even allowed to write down entirely a vector <math|x\<in\>\<bbb-R\><rsup|N>> (since this would take time linear in <math|N>). The key property that will save us is that this function admits <with|font-shape|italic|sparse minimizers> as we discussed in the previous section, and this will be exploited by the conditional gradient descent method.

  First let us study the computational complexity of the <math|t<rsup|t*h>> step of conditional gradient descent. Observe that

  <\equation*>
    \<nabla\>*f<around|(|x|)>=D<rsup|\<top\>>*<around|(|D*x-Y|)>.
  </equation*>

  Now assume that <math|z<rsub|t>=D*x<rsub|t>-Y\<in\>\<bbb-R\><rsup|n>> is already computed, then to compute <eqref|eq:FW1> one needs to find the coordinate <math|i<rsub|t>\<in\><around|[|N|]>> that maximizes <math|<around|\||<around|[|\<nabla\>*f<around|(|x<rsub|t>|)>|]><around|(|i|)>|\|>> which can be done by maximizing <math|d<rsub|i><rsup|\<top\>>*z<rsub|t>> and <math|-d<rsub|i><rsup|\<top\>>*z<rsub|t>>. Thus <eqref|eq:FW1> takes time <math|O<around|(|p<around|(|n|)>|)>>. Computing <math|x<rsub|t+1>> from <math|x<rsub|t>> and <math|i<rsub|t>> takes time <math|O<around|(|t|)>> since <math|<around|\<\|\|\>|x<rsub|t>|\<\|\|\>><rsub|0>\<leq\>t>, and computing <math|z<rsub|t+1>> from <math|z<rsub|t>> and <math|i<rsub|t>> takes time <math|O<around|(|n|)>>. Thus the overall time complexity of running <math|t> steps is (we assume <math|p<around|(|n|)>=\<Omega\><around|(|n|)>>)

  <\equation>
    O<around|(|t*p<around|(|n|)>+t<rsup|2>|)>.<label|eq:structuredsparsity2>
  </equation>

  To derive a rate of convergence it remains to study the smoothness of <math|f>. This can be done as follows:

  <\eqnarray*>
    <tformat|<table|<row|<cell|<around|\<\|\|\>|\<nabla\>*f<around|(|x|)>-\<nabla\>*f<around|(|y|)>|\<\|\|\>><rsub|\<infty\>>>|<cell|=>|<cell|<around|\<\|\|\>|D<rsup|\<top\>>*D*<around|(|x-y|)>|\<\|\|\>><rsub|\<infty\>>>>|<row|<cell|>|<cell|=>|<cell|max<rsub|1\<leq\>i\<leq\>N><mid|\|>d<rsub|i><rsup|\<top\>><around*|(|<big|sum><rsub|j=1><rsup|N>d<rsub|j>*<around|(|x<around|(|j|)>-y<around|(|j|)>|)>|)><mid|\|>>>|<row|<cell|>|<cell|\<leq\>>|<cell|m<rsup|2>*<around|\<\|\|\>|x-y|\<\|\|\>><rsub|1>,>>>>
  </eqnarray*>

  which means that <math|f> is <math|m<rsup|2>>-smooth with respect to the <math|\<ell\><rsub|1>>-norm. Thus we get the following rate of convergence:

  <\equation>
    f<around|(|x<rsub|t>|)>-f<around|(|x<rsup|\<ast\>>|)>\<leq\><frac|8*m<rsup|2>|t+1>.<label|eq:structuredsparsity3>
  </equation>

  Putting together <eqref|eq:structuredsparsity2> and <eqref|eq:structuredsparsity3> we proved that one can get an <math|\<epsilon\>>-optimal solution to <eqref|eq:structuredsparsity> with a computational effort of <math|O<around|(|m<rsup|2>*p<around|(|n|)>/\<epsilon\>+m<rsup|4>/\<epsilon\><rsup|2>|)>> using the conditional gradient descent.

  <section|Strong convexity>

  We will now discuss another property of convex functions that can significantly speed-up the convergence of first order methods: strong convexity. We say that <math|f:<cX>\<rightarrow\>\<bbb-R\>> is <math|\<alpha\>>-<with|font-shape|italic|strongly convex> if it satisfies the following improved subgradient inequality:

  <\equation>
    <label|eq:defstrongconv>f<around|(|x|)>-f<around|(|y|)>\<leq\>\<nabla\>*f<around|(|x|)><rsup|\<top\>>*<around|(|x-y|)>-<frac|\<alpha\>|2>*<around|\<\|\|\>|x-y|\<\|\|\>><rsup|2>.
  </equation>

  Of course this definition does not require differentiability of the function <math|f>, and one can replace <math|\<nabla\>*f<around|(|x|)>> in the inequality above by <math|g\<in\>\<partial\>*f<around|(|x|)>>. It is immediate to verify that a function <math|f> is <math|\<alpha\>>-strongly convex if and only if <math|x\<mapsto\>f<around|(|x|)>-<frac|\<alpha\>|2><around|\<\|\|\>|x|\<\|\|\>><rsup|2>> is convex (in particular if <math|f> is twice differentiable then the eigenvalues of the Hessians of <math|f> have to be larger than <math|\<alpha\>>). The strong convexity parameter <math|\<alpha\>> is a measure of the <with|font-shape|italic|curvature> of <math|f>. For instance a linear function has no curvature and hence <math|\<alpha\>=0>. On the other hand one can clearly see why a large value of <math|\<alpha\>> would lead to a faster rate: in this case a point far from the optimum will have a large gradient, and thus gradient descent will make very big steps when far from the optimum. Of course if the function is non-smooth one still has to be careful and tune the step-sizes to be relatively small, but nonetheless we will be able to improve the oracle complexity from <math|O<around|(|1/\<epsilon\><rsup|2>|)>> to <math|O<around|(|1/<around|(|\<alpha\>*\<epsilon\>|)>|)>>. On the other hand with the additional assumption of <math|\<beta\>>-smoothness we will prove that gradient descent with a constant step-size achieves a <with|font-shape|italic|linear rate of convergence>, precisely the oracle complexity will be <math|O<around|(|<frac|\<beta\>|\<alpha\>>*log <around|(|1/\<epsilon\>|)>|)>>. This achieves the objective we had set after Theorem <reference|th:pgd>: strongly-convex and smooth functions can be optimized in very large dimension and up to very high accuracy.

  Before going into the proofs let us discuss another interpretation of strong-convexity and its relation to smoothness. Equation <eqref|eq:defstrongconv> can be read as follows: at any point <math|x> one can find a (convex) quadratic lower bound <math|q<rsub|x><rsup|-><around|(|y|)>=f<around|(|x|)>+\<nabla\>*f<around|(|x|)><rsup|\<top\>>*<around|(|y-x|)>+<frac|\<alpha\>|2>*<around|\<\|\|\>|x-y|\<\|\|\>><rsup|2>> to the function <math|f>, i.e. <math|q<rsub|x><rsup|-><around|(|y|)>\<leq\>f<around|(|y|)>,\<forall\>y\<in\><cX>> (and <math|q<rsub|x><rsup|-><around|(|x|)>=f<around|(|x|)>>). On the other hand for <math|\<beta\>>-smoothness <eqref|eq:defaltsmooth> implies that at any point <math|y> one can find a (convex) quadratic upper bound <math|q<rsub|y><rsup|+><around|(|x|)>=f<around|(|y|)>+\<nabla\>*f<around|(|y|)><rsup|\<top\>>*<around|(|x-y|)>+<frac|\<beta\>|2>*<around|\<\|\|\>|x-y|\<\|\|\>><rsup|2>> to the function <math|f>, i.e. <math|q<rsub|y><rsup|+><around|(|x|)>\<geq\>f<around|(|x|)>,\<forall\>x\<in\><cX>> (and <math|q<rsub|y><rsup|+><around|(|y|)>=f<around|(|y|)>>). Thus in some sense strong convexity is a <with|font-shape|italic|dual> assumption to smoothness, and in fact this can be made precise within the framework of Fenchel duality. Also remark that clearly one always has <math|\<beta\>\<geq\>\<alpha\>>.

  <subsection|Strongly convex and Lipschitz functions>

  We consider here the projected subgradient descent algorithm with time-varying step size <math|<around|(|\<eta\><rsub|t>|)><rsub|t\<geq\>1>>, that is

  <\align*>
    <tformat|<table|<row|<cell|>|<cell|y<rsub|t+1>=x<rsub|t>-\<eta\><rsub|t>*g<rsub|t>,<text|where>g<rsub|t>\<in\>\<partial\>*f<around|(|x<rsub|t>|)>>>|<row|<cell|>|<cell|x<rsub|t+1>=\<Pi\><rsub|<cX>><around|(|y<rsub|t+1>|)>.>>>>
  </align*>

  The following result is extracted from <cite|LJSB12>.

  <\theorem>
    <label|th:LJSB12>Let <math|f> be <math|\<alpha\>>-strongly convex and <math|L>-Lipschitz on <math|<cX>>. Then projected subgradient descent with <math|\<eta\><rsub|s>=<frac|2|\<alpha\>*<around|(|s+1|)>>> satisfies

    <\equation*>
      f<around*|(|<big|sum><rsub|s=1><rsup|t><frac|2*s|t*<around|(|t+1|)>>*x<rsub|s>|)>-f<around|(|x<rsup|\<ast\>>|)>\<leq\><frac|2*L<rsup|2>|\<alpha\>*<around|(|t+1|)>>.
    </equation*>
  </theorem>

  <\proof>
    Coming back to our original analysis of projected subgradient descent in Section <reference|sec:psgd> and using the strong convexity assumption one immediately obtains

    <\equation*>
      f<around|(|x<rsub|s>|)>-f<around|(|x<rsup|\<ast\>>|)>\<leq\><frac|\<eta\><rsub|s>|2>*L<rsup|2>+<around*|(|<frac|1|2*\<eta\><rsub|s>>-<frac|\<alpha\>|2>|)>*<around|\<\|\|\>|x<rsub|s>-x<rsup|\<ast\>>*<around|\<\|\|\>|<rsup|2>-<frac|1|2*\<eta\><rsub|s>>|\<\|\|\>>*x<rsub|s+1>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>.
    </equation*>

    Multiplying this inequality by <math|s> yields

    <\equation*>
      s*<around|(|f<around|(|x<rsub|s>|)>-f<around|(|x<rsup|\<ast\>>|)>|)>\<leq\><frac|L<rsup|2>|\<alpha\>>+<frac|\<alpha\>|4>*<around*|(|s*<around|(|s-1|)>\<\|\|\>x<rsub|s>-x<rsup|\<ast\>>\<\|\|\><rsup|2>-s*<around|(|s+1|)>*<around|\<\|\|\>|x<rsub|s+1>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>|)>,
    </equation*>

    Now sum the resulting inequality over <math|s=1> to <math|s=t>, and apply Jensen's inequality to obtain the claimed statement.
  </proof>

  <subsection|Strongly convex and smooth functions>

  As we will see now, having both strong convexity and smoothness allows for a drastic improvement in the convergence rate. We denote <math|\<kappa\>=<frac|\<beta\>|\<alpha\>>> for the <with|font-shape|italic|condition number> of <math|f>. The key observation is that Lemma <reference|lem:smoothconst> can be improved to (with the notation of the lemma):

  <\equation>
    <label|eq:improvedstrongsmooth>f<around|(|x<rsup|+>|)>-f<around|(|y|)>\<leq\>g<rsub|<cX>><around|(|x|)><rsup|\<top\>>*<around|(|x-y|)>-<frac|1|2*\<beta\>>*<around|\<\|\|\>|g<rsub|<cX>><around|(|x|)>*<around|\<\|\|\>|<rsup|2>-<frac|\<alpha\>|2>|\<\|\|\>>*x-y|\<\|\|\>><rsup|2>.
  </equation>

  <\theorem>
    <label|th:gdssc>Let <math|f> be <math|\<alpha\>>-strongly convex and <math|\<beta\>>-smooth on <math|<cX>>. Then projected gradient descent with <math|\<eta\>=<frac|1|\<beta\>>> satisfies for <math|t\<geq\>0>,

    <\equation*>
      <around|\<\|\|\>|x<rsub|t+1>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>\<leq\>exp <around*|(|-<frac|t|\<kappa\>>|)>*<around|\<\|\|\>|x<rsub|1>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>.
    </equation*>
  </theorem>

  <\proof>
    Using <eqref|eq:improvedstrongsmooth> with <math|y=x<rsup|\<ast\>>> one directly obtains

    <\eqnarray*>
      <tformat|<table|<row|<cell|<around|\<\|\|\>|x<rsub|t+1>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>>|<cell|=>|<cell|<around|\<\|\|\>|x<rsub|t>-<frac|1|\<beta\>>*g<rsub|<cX>><around|(|x<rsub|t>|)>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>>>|<row|<cell|>|<cell|=>|<cell|<around|\<\|\|\>|x<rsub|t>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>-<frac|2|\<beta\>>*g<rsub|<cX>><around|(|x<rsub|t>|)><rsup|\<top\>>*<around|(|x<rsub|t>-x<rsup|\<ast\>>|)>+<frac|1|\<beta\><rsup|2>><around|\<\|\|\>|g<rsub|<cX>><around|(|x<rsub|t>|)>|\<\|\|\>><rsup|2>>>|<row|<cell|>|<cell|\<leq\>>|<cell|<around*|(|1-<frac|\<alpha\>|\<beta\>>|)>*<around|\<\|\|\>|x<rsub|t>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>>>|<row|<cell|>|<cell|\<leq\>>|<cell|<around*|(|1-<frac|\<alpha\>|\<beta\>>|)><rsup|t>*<around|\<\|\|\>|x<rsub|1>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>>>|<row|<cell|>|<cell|\<leq\>>|<cell|exp <around*|(|-<frac|t|\<kappa\>>|)>*<around|\<\|\|\>|x<rsub|1>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>,>>>>
    </eqnarray*>

    which concludes the proof.
  </proof>

  We now show that in the unconstrained case one can improve the rate by a constant factor, precisely one can replace <math|\<kappa\>> by <math|<around|(|\<kappa\>+1|)>/4> in the oracle complexity bound by using a larger step size. This is not a spectacular gain but the reasoning is based on an improvement of <eqref|eq:coercive1> which can be of interest by itself. Note that <eqref|eq:coercive1> and the lemma to follow are sometimes referred to as <with|font-shape|italic|coercivity> of the gradient.

  <\lemma>
    <label|lem:coercive2>Let <math|f> be <math|\<beta\>>-smooth and <math|\<alpha\>>-strongly convex on <math|<R><rsup|n>>. Then for all <math|x,y\<in\>\<bbb-R\><rsup|n>>, one has

    <\equation*>
      <around|(|\<nabla\>*f<around|(|x|)>-\<nabla\>*f<around|(|y|)>|)><rsup|\<top\>>*<around|(|x-y|)>\<geq\><frac|\<alpha\>*\<beta\>|\<beta\>+\<alpha\>>*<around|\<\|\|\>|x-y*<around|\<\|\|\>|<rsup|2>+<frac|1|\<beta\>+\<alpha\>>|\<\|\|\>>*\<nabla\>*f<around|(|x|)>-\<nabla\>*f<around|(|y|)>|\<\|\|\>><rsup|2>.
    </equation*>
  </lemma>

  <\proof>
    Let <math|\<phi\><around|(|x|)>=f<around|(|x|)>-<frac|\<alpha\>|2><around|\<\|\|\>|x|\<\|\|\>><rsup|2>>. By definition of <math|\<alpha\>>-strong convexity one has that <math|\<phi\>> is convex. Furthermore one can show that <math|\<phi\>> is <math|<around|(|\<beta\>-\<alpha\>|)>>-smooth by proving <eqref|eq:defaltsmooth> (and using that it implies smoothness). Thus using <eqref|eq:coercive1> one gets

    <\equation*>
      <around|(|\<nabla\>*\<phi\><around|(|x|)>-\<nabla\>*\<phi\><around|(|y|)>|)><rsup|\<top\>>*<around|(|x-y|)>\<geq\><frac|1|\<beta\>-\<alpha\>>*<around|\<\|\|\>|\<nabla\>*\<phi\><around|(|x|)>-\<nabla\>*\<phi\><around|(|y|)>|\<\|\|\>><rsup|2>,
    </equation*>

    which gives the claimed result with straightforward computations. (Note that if <math|\<alpha\>=\<beta\>> the smoothness of <math|\<phi\>> directly implies that <math|\<nabla\>*f<around|(|x|)>-\<nabla\>*f<around|(|y|)>=\<alpha\>*<around|(|x-y|)>> which proves the lemma in this case.)
  </proof>

  <\theorem>
    Let <math|f> be <math|\<beta\>>-smooth and <math|\<alpha\>>-strongly convex on <math|<R><rsup|n>>. Then gradient descent with <math|\<eta\>=<frac|2|\<alpha\>+\<beta\>>> satisfies

    <\equation*>
      f<around|(|x<rsub|t+1>|)>-f<around|(|x<rsup|\<ast\>>|)>\<leq\><frac|\<beta\>|2>*exp <around*|(|-<frac|4*t|\<kappa\>+1>|)>*<around|\<\|\|\>|x<rsub|1>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>.
    </equation*>
  </theorem>

  <\proof>
    First note that by <math|\<beta\>>-smoothness (since <math|\<nabla\>*f<around|(|x<rsup|\<ast\>>|)>=0>) one has

    <\equation*>
      f<around|(|x<rsub|t>|)>-f<around|(|x<rsup|\<ast\>>|)>\<leq\><frac|\<beta\>|2>*<around|\<\|\|\>|x<rsub|t>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>.
    </equation*>

    Now using Lemma <reference|lem:coercive2> one obtains

    <\eqnarray*>
      <tformat|<table|<row|<cell|<around|\<\|\|\>|x<rsub|t+1>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>>|<cell|=>|<cell|<around|\<\|\|\>|x<rsub|t>-\<eta\>*\<nabla\>*f<around|(|x<rsub|t>|)>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>>>|<row|<cell|>|<cell|=>|<cell|<around|\<\|\|\>|x<rsub|t>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>-2*\<eta\>*\<nabla\>*f<around|(|x<rsub|t>|)><rsup|\<top\>>*<around|(|x<rsub|t>-x<rsup|\<ast\>>|)>+\<eta\><rsup|2>*<around|\<\|\|\>|\<nabla\>*f<around|(|x<rsub|t>|)>|\<\|\|\>><rsup|2>>>|<row|<cell|>|<cell|\<leq\>>|<cell|<around*|(|1-2*<frac|\<eta\>*\<alpha\>*\<beta\>|\<beta\>+\<alpha\>>|)>*<around|\<\|\|\>|x<rsub|t>-x<rsup|\<ast\>>*<around|\<\|\|\>|<rsup|2>+<around*|(|\<eta\><rsup|2>-2*<frac|\<eta\>|\<beta\>+\<alpha\>>|)>|\<\|\|\>>*\<nabla\>*f<around|(|x<rsub|t>|)>|\<\|\|\>><rsup|2>>>|<row|<cell|>|<cell|=>|<cell|<around*|(|<frac|\<kappa\>-1|\<kappa\>+1>|)><rsup|2>*<around|\<\|\|\>|x<rsub|t>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>>>|<row|<cell|>|<cell|\<leq\>>|<cell|exp <around*|(|-<frac|4*t|\<kappa\>+1>|)>*<around|\<\|\|\>|x<rsub|1>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>,>>>>
    </eqnarray*>

    which concludes the proof.
  </proof>

  <section|Lower bounds><label|sec:chap3LB>

  We prove here various oracle complexity lower bounds. These results first appeared in <cite|NY83> but we follow here the simplified presentation of <cite|Nes04>. In general a black-box procedure is a mapping from “history" to the next query point, that is it maps <math|<around|(|x<rsub|1>,g<rsub|1>,\<ldots\>,x<rsub|t>,g<rsub|t>|)>> (with <math|g<rsub|s>\<in\>\<partial\>*f<around|(|x<rsub|s>|)>>) to <math|x<rsub|t+1>>. In order to simplify the notation and the argument, throughout the section we make the following assumption on the black-box procedure: <math|x<rsub|1>=0> and for any <math|t\<geq\>0>, <math|x<rsub|t+1>> is in the linear span of <math|g<rsub|1>,\<ldots\>,g<rsub|t>>, that is

  <\equation>
    <label|eq:ass1>x<rsub|t+1>\<in\><math-up|Span><around|(|g<rsub|1>,\<ldots\>,g<rsub|t>|)>.
  </equation>

  Let <math|e<rsub|1>,\<ldots\>,e<rsub|n>> be the canonical basis of <math|\<bbb-R\><rsup|n>>, and <math|<mB><rsub|2><around|(|R|)>=<around|{|x\<in\><R><rsup|n>:<around|\<\|\|\>|x|\<\|\|\>>\<leq\>R|}>>. We start with a theorem for the two non-smooth cases (convex and strongly convex).

  <\theorem>
    <label|th:lb1>Let <math|t\<leq\>n>, <math|L,R\<gtr\>0>. There exists a convex and <math|L>-Lipschitz function <math|f> such that for any black-box procedure satisfying <eqref|eq:ass1>,

    <\equation*>
      min<rsub|1\<leq\>s\<leq\>t> f<around|(|x<rsub|s>|)>-min<rsub|x\<in\><mB><rsub|2><around|(|R|)>> f<around|(|x|)>\<geq\><frac|R*L|2*<around|(|1+<sqrt|t>|)>>.
    </equation*>

    There also exists an <math|\<alpha\>>-strongly convex and <math|L>-lipschitz function <math|f> such that for any black-box procedure satisfying <eqref|eq:ass1>,

    <\equation*>
      min<rsub|1\<leq\>s\<leq\>t> f<around|(|x<rsub|s>|)>-min<rsub|x\<in\><mB><rsub|2><around*|(|<frac|L|2*\<alpha\>>|)>> f<around|(|x|)>\<geq\><frac|L<rsup|2>|8*\<alpha\>*t>.
    </equation*>
  </theorem>

  Note that the above result is restricted to a number of iterations smaller than the dimension, that is <math|t\<leq\>n>. This restriction is of course necessary to obtain lower bounds polynomial in <math|1/t>: as we saw in Chapter <reference|finitedim> one can always obtain an exponential rate of convergence when the number of calls to the oracle is larger than the dimension.

  <\proof>
    We consider the following <math|\<alpha\>>-strongly convex function:

    <\equation*>
      f<around|(|x|)>=\<gamma\>*max<rsub|1\<leq\>i\<leq\>t> x<around|(|i|)>+<frac|\<alpha\>|2><around|\<\|\|\>|x|\<\|\|\>><rsup|2>.
    </equation*>

    It is easy to see that

    <\equation*>
      \<partial\>*f<around|(|x|)>=\<alpha\>*x+\<gamma\><conv><around*|(|e<rsub|i>,i:x<around|(|i|)>=max<rsub|1\<leq\>j\<leq\>t> x<around|(|j|)>|)>.
    </equation*>

    In particular if <math|<around|\<\|\|\>|x|\<\|\|\>>\<leq\>R> then for any <math|g\<in\>\<partial\>*f<around|(|x|)>> one has <math|<around|\<\|\|\>|g|\<\|\|\>>\<leq\>\<alpha\>*R+\<gamma\>>. In other words <math|f> is <math|<around|(|\<alpha\>*R+\<gamma\>|)>>-Lipschitz on <math|<mB><rsub|2><around|(|R|)>>.

    Next we describe the first order oracle for this function: when asked for a subgradient at <math|x>, it returns <math|\<alpha\>*x+\<gamma\>*e<rsub|i>> where <math|i> is the <with|font-shape|italic|first> coordinate that satisfies <math|x<around|(|i|)>=max<rsub|1\<leq\>j\<leq\>t> x<around|(|j|)>>. In particular when asked for a subgradient at <math|x<rsub|1>=0> it returns <math|e<rsub|1>>. Thus <math|x<rsub|2>> must lie on the line generated by <math|e<rsub|1>>. It is easy to see by induction that in fact <math|x<rsub|s>> must lie in the linear span of <math|e<rsub|1>,\<ldots\>,e<rsub|s-1>>. In particular for <math|s\<leq\>t> we necessarily have <math|x<rsub|s><around|(|t|)>=0> and thus <math|f<around|(|x<rsub|s>|)>\<geq\>0>.

    It remains to compute the minimal value of <math|f>. Let <math|y> be such that <math|y<around|(|i|)>=-<frac|\<gamma\>|\<alpha\>*t>> for <math|1\<leq\>i\<leq\>t> and <math|y<around|(|i|)>=0> for <math|t+1\<leq\>i\<leq\>n>. It is clear that <math|0\<in\>\<partial\>*f<around|(|y|)>> and thus the minimal value of <math|f> is

    <\equation*>
      f<around|(|y|)>=-<frac|\<gamma\><rsup|2>|\<alpha\>*t>+<frac|\<alpha\>|2>*<frac|\<gamma\><rsup|2>|\<alpha\><rsup|2>*t>=-<frac|\<gamma\><rsup|2>|2*\<alpha\>*t>.
    </equation*>

    Wrapping up, we proved that for any <math|s\<leq\>t> one must have

    <\equation*>
      f<around|(|x<rsub|s>|)>-f<around|(|x<rsup|\<ast\>>|)>\<geq\><frac|\<gamma\><rsup|2>|2*\<alpha\>*t>.
    </equation*>

    Taking <math|\<gamma\>=L/2> and <math|R=<frac|L|2*\<alpha\>>> we proved the lower bound for <math|\<alpha\>>-strongly convex functions (note in particular that <math|<around|\<\|\|\>|y|\<\|\|\>><rsup|2>=<frac|\<gamma\><rsup|2>|\<alpha\><rsup|2>*t>=<frac|L<rsup|2>|4*\<alpha\><rsup|2>*t>\<leq\>R<rsup|2>> with these parameters). On the other taking <math|\<alpha\>=<frac|L|R>*<frac|1|1+<sqrt|t>>> and <math|\<gamma\>=L*<frac|<sqrt|t>|1+<sqrt|t>>> concludes the proof for convex functions (note in particular that <math|<around|\<\|\|\>|y|\<\|\|\>><rsup|2>=<frac|\<gamma\><rsup|2>|\<alpha\><rsup|2>*t>=R<rsup|2>> with these parameters).
  </proof>

  We proceed now to the smooth case. As we will see in the following proofs we restrict our attention to quadratic functions, and it might be useful to recall that in this case one can attain the exact optimum in <math|n> calls to the oracle (see Section <reference|sec:CG>). We also recall that for a twice differentiable function <math|f>, <math|\<beta\>>-smoothness is equivalent to the largest eigenvalue of the Hessians of <math|f> being smaller than <math|\<beta\>> at any point, which we write

  <\equation*>
    \<nabla\><rsup|2>*f<around|(|x|)>\<preceq\>\<beta\><mI><rsub|n>,\<forall\>x.
  </equation*>

  Furthermore <math|\<alpha\>>-strong convexity is equivalent to

  <\equation*>
    \<nabla\><rsup|2>*f<around|(|x|)>\<succeq\>\<alpha\><mI><rsub|n>,\<forall\>x.
  </equation*>

  <\theorem>
    <label|th:lb2>Let <math|t\<leq\><around|(|n-1|)>/2>, <math|\<beta\>\<gtr\>0>. There exists a <math|\<beta\>>-smooth convex function <math|f> such that for any black-box procedure satisfying <eqref|eq:ass1>,

    <\equation*>
      min<rsub|1\<leq\>s\<leq\>t> f<around|(|x<rsub|s>|)>-f<around|(|x<rsup|\<ast\>>|)>\<geq\><frac|3*\<beta\>|32>*<frac|<around|\<\|\|\>|x<rsub|1>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>|<around|(|t+1|)><rsup|2>>.
    </equation*>
  </theorem>

  <\proof>
    In this proof for <math|h:<R><rsup|n>\<rightarrow\><R>> we denote <math|h<rsup|\<ast\>>=inf<rsub|x\<in\><R><rsup|n>> h<around|(|x|)>>. For <math|k\<leq\>n> let <math|A<rsub|k>\<in\><R><rsup|n\<times\>n>> be the symmetric and tridiagonal matrix defined by

    <\equation*>
      <around|(|A<rsub|k>|)><rsub|i,j>=<around*|{|<tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|l>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|2|2|cell-halign|l>|<cwith|1|-1|2|2|cell-rborder|0ln>|<table|<row|<cell|2,>|<cell|i=j,i\<leq\>k>>|<row|<cell|-1,>|<cell|j\<in\><around|{|i-1,i+1|}>,i\<leq\>k,j\<neq\>k+1>>|<row|<cell|0,>|<cell|<text|otherwise>.>>>>>|\<nobracket\>>
    </equation*>

    It is easy to verify that <math|0\<preceq\>A<rsub|k>\<preceq\>4<mI><rsub|n>> since

    <\equation*>
      x<rsup|\<top\>>*A<rsub|k>*x=2*<big|sum><rsub|i=1><rsup|k>x<around|(|i|)><rsup|2>-2*<big|sum><rsub|i=1><rsup|k-1>x<around|(|i|)>*x*<around|(|i+1|)>=x<around|(|1|)><rsup|2>+x<around|(|k|)><rsup|2>+<big|sum><rsub|i=1><rsup|k-1><around|(|x<around|(|i|)>-x*<around|(|i+1|)>|)><rsup|2>.
    </equation*>

    We consider now the following <math|\<beta\>>-smooth convex function:

    <\equation*>
      f<around|(|x|)>=<frac|\<beta\>|8>*x<rsup|\<top\>>*A<rsub|2*t+1>*x-<frac|\<beta\>|4>*x<rsup|\<top\>>*e<rsub|1>.
    </equation*>

    Similarly to what happened in the proof Theorem <reference|th:lb1>, one can see here too that <math|x<rsub|s>> must lie in the linear span of <math|e<rsub|1>,\<ldots\>,e<rsub|s-1>> (because of our assumption on the black-box procedure). In particular for <math|s\<leq\>t> we necessarily have <math|x<rsub|s><around|(|i|)>=0> for <math|i=s,\<ldots\>,n>, which implies <math|x<rsub|s><rsup|\<top\>>*A<rsub|2*t+1>*x<rsub|s>=x<rsub|s><rsup|\<top\>>*A<rsub|s>*x<rsub|s>>. In other words, if we denote

    <\equation*>
      f<rsub|k><around|(|x|)>=<frac|\<beta\>|8>*x<rsup|\<top\>>*A<rsub|k>*x-<frac|\<beta\>|4>*x<rsup|\<top\>>*e<rsub|1>,
    </equation*>

    then we just proved that

    <\equation*>
      f<around|(|x<rsub|s>|)>-f<rsup|\<ast\>>=f<rsub|s><around|(|x<rsub|s>|)>-f<rsub|2*t+1><rsup|\<ast\>>\<geq\>f<rsub|s><rsup|\<ast\>>-f<rsub|2*t+1><rsup|\<ast\>>\<geq\>f<rsub|t><rsup|\<ast\>>-f<rsub|2*t+1><rsup|\<ast\>>.
    </equation*>

    Thus it simply remains to compute the minimizer <math|x<rsup|\<ast\>><rsub|k>> of <math|f<rsub|k>>, its norm, and the corresponding function value <math|f<rsub|k><rsup|\<ast\>>>.

    The point <math|x<rsup|\<ast\>><rsub|k>> is the unique solution in the span of <math|e<rsub|1>,\<ldots\>,e<rsub|k>> of <math|A<rsub|k>*x=e<rsub|1>>. It is easy to verify that it is defined by <math|x<rsup|\<ast\>><rsub|k><around|(|i|)>=1-<frac|i|k+1>> for <math|i=1,\<ldots\>,k>. Thus we immediately have:

    <\equation*>
      f<rsup|\<ast\>><rsub|k>=<frac|\<beta\>|8><around|(|x<rsup|\<ast\>><rsub|k>|)><rsup|\<top\>>*A<rsub|k>*x<rsup|\<ast\>><rsub|k>-<frac|\<beta\>|4><around|(|x<rsup|\<ast\>><rsub|k>|)><rsup|\<top\>>*e<rsub|1>=-<frac|\<beta\>|8><around|(|x<rsup|\<ast\>><rsub|k>|)><rsup|\<top\>>*e<rsub|1>=-<frac|\<beta\>|8>*<around*|(|1-<frac|1|k+1>|)>.
    </equation*>

    Furthermore note that

    <\equation*>
      <around|\<\|\|\>|x<rsup|\<ast\>><rsub|k>|\<\|\|\>><rsup|2>=<big|sum><rsub|i=1><rsup|k><around*|(|1-<frac|i|k+1>|)><rsup|2>=<big|sum><rsub|i=1><rsup|k><around*|(|<frac|i|k+1>|)><rsup|2>\<leq\><frac|k+1|3>.
    </equation*>

    Thus one obtains:

    <\equation*>
      f<rsub|t><rsup|\<ast\>>-f<rsub|2*t+1><rsup|\<ast\>>=<frac|\<beta\>|8>*<around*|(|<frac|1|t+1>-<frac|1|2*t+2>|)>\<geq\><frac|3*\<beta\>|32>*<frac|<around|\<\|\|\>|x<rsup|\<ast\>><rsub|2*t+1>|\<\|\|\>><rsup|2>|<around|(|t+1|)><rsup|2>>,
    </equation*>

    which concludes the proof.
  </proof>

  To simplify the proof of the next theorem we will consider the limiting situation <math|n\<to\>+\<infty\>>. More precisely we assume now that we are working in <math|\<ell\><rsub|2>=<around|{|x=<around|(|x<around|(|n|)>|)><rsub|n\<in\>\<bbb-N\>>:<big|sum><rsub|i=1><rsup|+\<infty\>>x<around|(|i|)><rsup|2>\<less\>+\<infty\>|}>> rather than in <math|\<bbb-R\><rsup|n>>. Note that all the theorems we proved in this chapter are in fact valid in an arbitrary Hilbert space <math|\<cal-H\>>. We chose to work in <math|\<bbb-R\><rsup|n>> only for clarity of the exposition.

  <\theorem>
    <label|th:lb3>Let <math|\<kappa\>\<gtr\>1>. There exists a <math|\<beta\>>-smooth and <math|\<alpha\>>-strongly convex function <math|f:\<ell\><rsub|2>\<rightarrow\>\<bbb-R\>> with <math|\<kappa\>=\<beta\>/\<alpha\>> such that for any <math|t\<geq\>1> and any black-box procedure satisfying <eqref|eq:ass1> one has

    <\equation*>
      f<around|(|x<rsub|t>|)>-f<around|(|x<rsup|\<ast\>>|)>\<geq\><frac|\<alpha\>|2><around*|(|<frac|<sqrt|\<kappa\>>-1|<sqrt|\<kappa\>>+1>|)><rsup|2*<around|(|t-1|)>>*<around|\<\|\|\>|x<rsub|1>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>.
    </equation*>
  </theorem>

  Note that for large values of the condition number <math|\<kappa\>> one has

  <\equation*>
    <around*|(|<frac|<sqrt|\<kappa\>>-1|<sqrt|\<kappa\>>+1>|)><rsup|2*<around|(|t-1|)>>\<approx\>exp <around*|(|-<frac|4*<around|(|t-1|)>|<sqrt|\<kappa\>>>|)>.
  </equation*>

  <\proof>
    The overall argument is similar to the proof of Theorem <reference|th:lb2>. Let <math|A:\<ell\><rsub|2>\<rightarrow\>\<ell\><rsub|2>> be the linear operator that corresponds to the infinite tridiagonal matrix with <math|2> on the diagonal and <math|-1> on the upper and lower diagonals. We consider now the following function:

    <\equation*>
      f<around|(|x|)>=<frac|\<alpha\>*<around|(|\<kappa\>-1|)>|8>*<around*|(|<around|\<langle\>|A*x,x|\<rangle\>>-2*<around|\<langle\>|e<rsub|1>,x|\<rangle\>>|)>+<frac|\<alpha\>|2><around|\<\|\|\>|x|\<\|\|\>><rsup|2>.
    </equation*>

    We already proved that <math|0\<preceq\>A\<preceq\>4<mI>> which easily implies that <math|f> is <math|\<alpha\>>-strongly convex and <math|\<beta\>>-smooth. Now as always the key observation is that for this function, thanks to our assumption on the black-box procedure, one necessarily has <math|x<rsub|t><around|(|i|)>=0,\<forall\>i\<geq\>t>. This implies in particular:

    <\equation*>
      <around|\<\|\|\>|x<rsub|t>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>\<geq\><big|sum><rsub|i=t><rsup|+\<infty\>>x<rsup|\<ast\>><around|(|i|)><rsup|2>.
    </equation*>

    Furthermore since <math|f> is <math|\<alpha\>>-strongly convex, one has

    <\equation*>
      f<around|(|x<rsub|t>|)>-f<around|(|x<rsup|\<ast\>>|)>\<geq\><frac|\<alpha\>|2>*<around|\<\|\|\>|x<rsub|t>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>.
    </equation*>

    Thus it only remains to compute <math|x<rsup|\<ast\>>>. This can be done by differentiating <math|f> and setting the gradient to <math|0>, which gives the following infinite set of equations

    <\align*>
      <tformat|<table|<row|<cell|>|<cell|1-2*<frac|\<kappa\>+1|\<kappa\>-1>*x<rsup|\<ast\>><around|(|1|)>+x<rsup|\<ast\>><around|(|2|)>=0,>>|<row|<cell|>|<cell|x<rsup|\<ast\>>*<around|(|k-1|)>-2*<frac|\<kappa\>+1|\<kappa\>-1>*x<rsup|\<ast\>><around|(|k|)>+x<rsup|\<ast\>>*<around|(|k+1|)>=0,\<forall\>k\<geq\>2.>>>>
    </align*>

    It is easy to verify that <math|x<rsup|\<ast\>>> defined by <math|x<rsup|\<ast\>><around|(|i|)>=<around*|(|<frac|<sqrt|\<kappa\>>-1|<sqrt|\<kappa\>>+1>|)><rsup|i>> satisfy this infinite set of equations, and the conclusion of the theorem then follows by straightforward computations.
  </proof>

  <section|Geometric descent><label|sec:GeoD>

  So far our results leave a gap in the case of smooth optimization: gradient descent achieves an oracle complexity of <math|O<around|(|1/\<epsilon\>|)>> (respectively <math|O<around|(|\<kappa\>*log <around|(|1/\<epsilon\>|)>|)>> in the strongly convex case) while we proved a lower bound of <math|\<Omega\>*<around|(|1/<sqrt|\<epsilon\>>|)>> (respectively <math|\<Omega\>*<around|(|<sqrt|\<kappa\>>*log <around|(|1/\<epsilon\>|)>|)>>). In this section we close these gaps with the geometric descent method which was recently introduced in <cite|BLS15>. Historically the first method with optimal oracle complexity was proposed in <cite|NY83>. This method, inspired by the conjugate gradient (see Section <reference|sec:CG>), assumes an oracle to compute <with|font-shape|italic|plane searches>. In <cite|Nem82> this assumption was relaxed to a line search oracle (the geometric descent method also requires a line search oracle). Finally in <cite|Nes83> an optimal method requiring only a first order oracle was introduced. The latter algorithm, called Nesterov's accelerated gradient descent, has been the most influential optimal method for smooth optimization up to this day. We describe and analyze this method in Section <reference|sec:AGD>. As we shall see the intuition behind Nesterov's accelerated gradient descent (both for the derivation of the algorithm and its analysis) is not quite transparent, which motivates the present section as geometric descent has a simple geometric interpretation loosely inspired from the ellipsoid method (see Section <reference|sec:ellipsoid>).

  We focus here on the unconstrained optimization of a smooth and strongly convex function, and we prove that geometric descent achieves the oracle complexity of <math|O<around|(|<sqrt|\<kappa\>>*log <around|(|1/\<epsilon\>|)>|)>>, thus reducing the complexity of the basic gradient descent by a factor <math|<sqrt|\<kappa\>>>. We note that this improvement is quite relevant for machine learning applications. Consider for example the logistic regression problem described in Section <reference|sec:mlapps>: this is a smooth and strongly convex problem, with a smoothness of order of a numerical constant, but with strong convexity equal to the regularization parameter whose inverse can be as large as the sample size. Thus in this case <math|\<kappa\>> can be of order of the sample size, and a faster rate by a factor of <math|<sqrt|\<kappa\>>> is quite significant. We also observe that this improved rate for smooth and strongly convex objectives also implies an almost optimal rate of <math|O<around|(|log <around|(|1/\<epsilon\>|)>/<sqrt|\<epsilon\>>|)>> for the smooth case, as one can simply run geometric descent on the function <math|x\<mapsto\>f<around|(|x|)>+\<epsilon\><around|\<\|\|\>|x|\<\|\|\>><rsup|2>>.

  In Section <reference|sec:warmup> we describe the basic idea of geometric descent, and we show how to obtain effortlessly a geometric method with an oracle complexity of <math|O<around|(|\<kappa\>*log <around|(|1/\<epsilon\>|)>|)>> (i.e., similar to gradient descent). Then we explain why one should expect to be able to accelerate this method in Section <reference|sec:accafterwarmup>. The geometric descent method is described precisely and analyzed in Section <reference|sec:GeoDmethod>.

  <subsection|Warm-up: a geometric alternative to gradient descent><label|sec:warmup>

  <\big-figure>
    <\padded-center>
      <\tikzpicture>
        [scale=0.7, every node/.style=transform shape]

        <draw>(0,0) ellipse (2 and 2); <draw*|dashed> (4,0) ellipse (4 and 4); <draw>(4,0) ellipse (3.85 and 3.85); <draw*|\|-\|> (4,0) -- (4,4) node[pos=0.5, right] <math|<around|\||g|\|>>; <draw*|\|-\|> (4,0) -- (7.85,0) node[pos=0.5, above] <math|<sqrt|1-\<epsilon\>><around|\||g|\|>>;

        <scope| <clip>(0,0) ellipse (2 and 2); <fill*|lightgray> (4,0) ellipse (3.85 and 3.85);>

        <draw>(0,0) node[cross=5pt] ;

        <draw*|\|-\|> (0,0) -- (-2,0) node[pos=0.4, above] <math|1>; <draw*|\|-\|> (0.64719,0) -- (2.53958,0) node[pos=0.35, above] <math|<sqrt|1-\<epsilon\>>>; <draw*|thick> (0.64719,0) ellipse (1.8924 and 1.8924);
      </tikzpicture>
    </padded-center>

    <label|fig:one_ball>
  </big-figure|One ball shrinks.>

  We start with some notation. Let <math|<mB><around|(|x,r<rsup|2>|)>\<assign\><around|{|y\<in\><R><rsup|n>:<around|\<\|\|\>|y-x|\<\|\|\>><rsup|2>\<leq\>r<rsup|2>|}>> (note that the second argument is the radius squared), and

  <\equation*>
    x<rsup|+>=x-<frac|1|\<beta\>>*\<nabla\>*f<around|(|x|)>,<text|and>x<rsup|++>=x-<frac|1|\<alpha\>>*\<nabla\>*f<around|(|x|)>.
  </equation*>

  Rewriting the definition of strong convexity <eqref|eq:defstrongconv> as

  <\eqnarray*>
    <tformat|<table|<row|<cell|>|<cell|f<around|(|y|)>\<geq\>f<around|(|x|)>+\<nabla\>*f<around|(|x|)><rsup|\<top\>>*<around|(|y-x|)>+<frac|\<alpha\>|2>*<around|\<\|\|\>|y-x|\<\|\|\>><rsup|2>>>|<row|<cell|>|<cell|\<Leftrightarrow\><frac|\<alpha\>|2>*<around|\<\|\|\>|y-x+<frac|1|\<alpha\>>*\<nabla\>*f<around|(|x|)>|\<\|\|\>><rsup|2>\<leq\><frac|<around|\<\|\|\>|\<nabla\>*f<around|(|x|)>|\<\|\|\>><rsup|2>|2*\<alpha\>>-<around|(|f<around|(|x|)>-f<around|(|y|)>|)>,>>>>
  </eqnarray*>

  one obtains an enclosing ball for the minimizer of <math|f> with the <math|0<rsup|t*h>> and <math|1<rsup|s*t>> order information at <math|x>:

  <\equation*>
    x<rsup|\<ast\>>\<in\><mB><around*|(|x<rsup|++>,<frac|<around|\<\|\|\>|\<nabla\>*f<around|(|x|)>|\<\|\|\>><rsup|2>|\<alpha\><rsup|2>>-<frac|2|\<alpha\>>*<around|(|f<around|(|x|)>-f<around|(|x<rsup|\<ast\>>|)>|)>|)>.
  </equation*>

  Furthermore recall that by smoothness (see <eqref|eq:onestepofgd>) one has <math|f<around|(|x<rsup|+>|)>\<leq\>f<around|(|x|)>-<frac|1|2*\<beta\>>*<around|\<\|\|\>|\<nabla\>*f<around|(|x|)>|\<\|\|\>><rsup|2>> which allows to <em|shrink> the above ball by a factor of <math|1-<frac|1|\<kappa\>>> and obtain the following:

  <\equation>
    <label|eq:ball2>x<rsup|\<ast\>>\<in\><mB><around*|(|x<rsup|++>,<frac|<around|\<\|\|\>|\<nabla\>*f<around|(|x|)>|\<\|\|\>><rsup|2>|\<alpha\><rsup|2>>*<around*|(|1-<frac|1|\<kappa\>>|)>-<frac|2|\<alpha\>>*<around|(|f<around|(|x<rsup|+>|)>-f<around|(|x<rsup|\<ast\>>|)>|)>|)>
  </equation>

  This suggests a natural strategy: assuming that one has an enclosing ball <math|A\<assign\><mB><around|(|x,R<rsup|2>|)>> for <math|x<rsup|\<ast\>>> (obtained from previous steps of the strategy), one can then enclose <math|x<rsup|\<ast\>>> in a ball <math|B> containing the intersection of <math|<mB><around|(|x,R<rsup|2>|)>> and the ball <math|<mB><around*|(|x<rsup|++>,<frac|<around|\<\|\|\>|\<nabla\>*f<around|(|x|)>|\<\|\|\>><rsup|2>|\<alpha\><rsup|2>>*<around*|(|1-<frac|1|\<kappa\>>|)>|)>> obtained by <eqref|eq:ball2>. Provided that the radius of <math|B> is a fraction of the radius of <math|A>, one can then iterate the procedure by replacing <math|A> by <math|B>, leading to a linear convergence rate. Evaluating the rate at which the radius shrinks is an elementary calculation: for any <math|g\<in\><R><rsup|n>>, <math|\<epsilon\>\<in\><around|(|0,1|)>>, there exists <math|x\<in\><R><rsup|n>> such that

  <\equation*>
    <mB><around|(|0,1|)>\<cap\><mB><around|(|g,<around|\<\|\|\>|g|\<\|\|\>><rsup|2>*<around|(|1-\<epsilon\>|)>|)>\<subset\><mB><around|(|x,1-\<epsilon\>|)>.<space|1em><space|1em><text|(Figure <reference|fig:one_ball>)>
  </equation*>

  Thus we see that in the strategy described above, the radius squared of the enclosing ball for <math|x<rsup|\<ast\>>> shrinks by a factor <math|1-<frac|1|\<kappa\>>> at each iteration, thus matching the rate of convergence of gradient descent (see Theorem <reference|th:gdssc>).

  <subsection|Acceleration><label|sec:accafterwarmup>

  <\big-figure>
    <\padded-center>
      <\tikzpicture>
        [scale=0.7, every node/.style=transform shape]

        <draw*|dashed> (0,0) ellipse (2 and 2); <draw>(0,0) ellipse (1.68 and 1.68); <draw*|dashed> (4,0) ellipse (4 and 4); <draw>(4,0) ellipse (3.85 and 3.85); <draw*|\|-\|> (4,0) -- (7.85,0) node[pos=0.5, above] <math|<sqrt|1-\<epsilon\>><around|\||g|\|>>;

        <scope| <clip>(0,0) ellipse (1.68 and 1.68); <fill*|lightgray> (4,0) ellipse (3.85 and 3.85);>

        <draw>(0,0) node[cross=4pt] ;

        <draw*|\|-\|> (0,-3) -- (-1.68,-3) node[pos=0.5, above] <math|<sqrt|1-\<epsilon\><around|\||g|\|><rsup|2>>>; <draw*|\|-\|> (0.5,0) -- (2.1044,0) node[pos=0.3, above] <with|font-size|0.71|mode|math|<sqrt|1-<sqrt|\<epsilon\>>>>;

        <draw*|thick> (0.5,0) ellipse (1.6044 and 1.6044);
      </tikzpicture>
    </padded-center>

    <label|fig:two_ball>
  </big-figure|Two balls shrink.>

  In the argument from the previous section we missed the following opportunity: observe that the ball <math|A=<mB><around|(|x,R<rsup|2>|)>> was obtained by intersections of previous balls of the form given by <eqref|eq:ball2>, and thus the new value <math|f<around|(|x|)>> could be used to reduce the radius of those previous balls too (an important caveat is that the value <math|f<around|(|x|)>> should be smaller than the values used to build those previous balls). Potentially this could show that the optimum is in fact contained in the ball <math|<mB><around*|(|x,R<rsup|2>-<frac|1|\<kappa\>>*<around|\<\|\|\>|\<nabla\>*f<around|(|x|)>|\<\|\|\>><rsup|2>|)>>. By taking the intersection with the ball <math|<mB><around*|(|x<rsup|++>,<frac|<around|\<\|\|\>|\<nabla\>*f<around|(|x|)>|\<\|\|\>><rsup|2>|\<alpha\><rsup|2>>*<around*|(|1-<frac|1|\<kappa\>>|)>|)>> this would allow to obtain a new ball with radius shrunk by a factor <math|1-<frac|1|<sqrt|\<kappa\>>>> (instead of <math|1-<frac|1|\<kappa\>>>): indeed for any <math|g\<in\><R><rsup|n>>, <math|\<epsilon\>\<in\><around|(|0,1|)>>, there exists <math|x\<in\><R><rsup|n>> such that

  <\equation*>
    <mB><around|(|0,1-\<epsilon\><around|\<\|\|\>|g|\<\|\|\>><rsup|2>|)>\<cap\><mB><around|(|g,<around|\<\|\|\>|g|\<\|\|\>><rsup|2>*<around|(|1-\<epsilon\>|)>|)>\<subset\><mB><around|(|x,1-<sqrt|\<epsilon\>>|)>.<space|1em><space|1em><text|(Figure <reference|fig:two_ball>)>
  </equation*>

  Thus it only remains to deal with the caveat noted above, which we do via a line search. In turns this line search might shift the new ball <eqref|eq:ball2>, and to deal with this we shall need the following strengthening of the above set inclusion (we refer to <cite|BLS15> for a simple proof of this result):

  <\lemma>
    <label|lem:geom>Let <math|a\<in\><R><rsup|n>> and <math|\<epsilon\>\<in\><around|(|0,1|)>,g\<in\><R><rsub|+>>. Assume that <math|<around|\<\|\|\>|a|\<\|\|\>>\<geq\>g>. Then there exists <math|c\<in\><R><rsup|n>> such that for any <math|\<delta\>\<geq\>0>,

    <\equation*>
      <mB><around|(|0,1-\<epsilon\>*g<rsup|2>-\<delta\>|)>\<cap\><mB><around|(|a,g<rsup|2>*<around|(|1-\<epsilon\>|)>-\<delta\>|)>\<subset\><mB><around*|(|c,1-<sqrt|\<epsilon\>>-\<delta\>|)>.
    </equation*>
  </lemma>

  <subsection|The geometric descent method><label|sec:GeoDmethod>

  Let <math|x<rsub|0>\<in\><R><rsup|n>>, <math|c<rsub|0>=x<rsub|0><rsup|++>>, and <math|R<rsub|0><rsup|2>=<around*|(|1-<frac|1|\<kappa\>>|)>*<frac|<around|\<\|\|\>|\<nabla\>*f<around|(|x<rsub|0>|)>|\<\|\|\>><rsup|2>|\<alpha\><rsup|2>>>. For any <math|t\<geq\>0> let

  <\equation*>
    x<rsub|t+1>=<argmin><rsub|x\<in\><around*|{|<around|(|1-\<lambda\>|)>*c<rsub|t>+\<lambda\>*x<rsub|t><rsup|+>,\<lambda\>\<in\><R>|}>>f<around|(|x|)>,
  </equation*>

  and <math|c<rsub|t+1>> (respectively <math|R<rsup|2><rsub|t+1>>) be the center (respectively the squared radius) of the ball given by (the proof of) Lemma <reference|lem:geom> which contains

  <\equation*>
    <mB><around*|(|c<rsub|t>,R<rsub|t><rsup|2>-<frac|<around|\<\|\|\>|\<nabla\>*f<around|(|x<rsub|t+1>|)>|\<\|\|\>><rsup|2>|\<alpha\><rsup|2>*\<kappa\>>|)>\<cap\><mB><around*|(|x<rsub|t+1><rsup|++>,<frac|<around|\<\|\|\>|\<nabla\>*f<around|(|x<rsub|t+1>|)>|\<\|\|\>><rsup|2>|\<alpha\><rsup|2>>*<around*|(|1-<frac|1|\<kappa\>>|)>|)>.
  </equation*>

  Formulas for <math|c<rsub|t+1>> and <math|R<rsup|2><rsub|t+1>> are given at the end of this section.

  <\theorem>
    <label|thm:main>For any <math|t\<geq\>0>, one has <math|x<rsup|\<ast\>>\<in\><mB><around|(|c<rsub|t>,R<rsub|t><rsup|2>|)>>, <math|R<rsub|t+1><rsup|2>\<leq\><around*|(|1-<frac|1|<sqrt|\<kappa\>>>|)>*R<rsub|t><rsup|2>>, and thus

    <\equation*>
      <around|\<\|\|\>|x<rsup|\<ast\>>-c<rsub|t>|\<\|\|\>><rsup|2>\<leq\><around*|(|1-<frac|1|<sqrt|\<kappa\>>>|)><rsup|t>*R<rsub|0><rsup|2>.
    </equation*>
  </theorem>

  <\proof>
    We will prove a stronger claim by induction that for each <math|t\<geq\>0>, one has

    <\equation*>
      x<rsup|\<ast\>>\<in\><mB><around*|(|c<rsub|t>,R<rsub|t><rsup|2>-<frac|2|\<alpha\>>*<around*|(|f<around|(|x<rsub|t><rsup|+>|)>-f<around|(|x<rsup|\<ast\>>|)>|)>|)>.
    </equation*>

    The case <math|t=0> follows immediately by <eqref|eq:ball2>. Let us assume that the above display is true for some <math|t\<geq\>0>. Then using <math|f<around|(|x<rsub|t+1><rsup|+>|)>\<leq\>f<around|(|x<rsub|t+1>|)>-<frac|1|2*\<beta\>>*<around|\<\|\|\>|\<nabla\>*f<around|(|x<rsub|t+1>|)>|\<\|\|\>><rsup|2>\<leq\>f<around|(|x<rsub|t><rsup|+>|)>-<frac|1|2*\<beta\>>*<around|\<\|\|\>|\<nabla\>*f<around|(|x<rsub|t+1>|)>|\<\|\|\>><rsup|2>>, one gets

    <\equation*>
      x<rsup|\<ast\>>\<in\><mB><around*|(|c<rsub|t>,R<rsub|t><rsup|2>-<frac|<around|\<\|\|\>|\<nabla\>*f<around|(|x<rsub|t+1>|)>|\<\|\|\>><rsup|2>|\<alpha\><rsup|2>*\<kappa\>>-<frac|2|\<alpha\>>*<around*|(|f<around|(|x<rsub|t+1><rsup|+>|)>-f<around|(|x<rsup|\<ast\>>|)>|)>|)>.
    </equation*>

    Furthermore by <eqref|eq:ball2> one also has

    <\equation*>
      <mB><around*|(|x<rsub|t+1><rsup|++>,<frac|<around|\<\|\|\>|\<nabla\>*f<around|(|x<rsub|t+1>|)>|\<\|\|\>><rsup|2>|\<alpha\><rsup|2>>*<around*|(|1-<frac|1|\<kappa\>>|)>-<frac|2|\<alpha\>>*<around*|(|f<around|(|x<rsub|t+1><rsup|+>|)>-f<around|(|x<rsup|\<ast\>>|)>|)>|)>.
    </equation*>

    Thus it only remains to observe that the squared radius of the ball given by Lemma <reference|lem:geom> which encloses the intersection of the two above balls is smaller than <math|<around*|(|1-<frac|1|<sqrt|\<kappa\>>>|)>*R<rsub|t><rsup|2>-<frac|2|\<alpha\>>*<around|(|f<around|(|x<rsub|t+1><rsup|+>|)>-f<around|(|x<rsup|\<ast\>>|)>|)>>. We apply Lemma<nbsp><reference|lem:geom> after moving <math|c<rsub|t>> to the origin and scaling distances by <math|R<rsub|t>>. We set <math|\<epsilon\>=<frac|1|\<kappa\>>>, <math|g=<frac|<around|\<\|\|\>|\<nabla\>*f<around|(|x<rsub|t+1>|)>|\<\|\|\>>|\<alpha\>>>, <math|\<delta\>=<frac|2|\<alpha\>>*<around*|(|f<around|(|x<rsub|t+1><rsup|+>|)>-f<around|(|x<rsup|\<ast\>>|)>|)>> and <math|a=x<rsub|t+1><rsup|++>-c<rsub|t>>. The line search step of the algorithm implies that <math|\<nabla\>*f<around|(|x<rsub|t+1>|)><rsup|\<top\>>*<around|(|x<rsub|t+1>-c<rsub|t>|)>=0> and therefore, <math|<around|\<\|\|\>|a|\<\|\|\>>=<around|\<\|\|\>|x<rsub|t+1><rsup|++>-c<rsub|t>|\<\|\|\>>\<geq\><around|\<\|\|\>|\<nabla\>*f<around|(|x<rsub|t+1>|)>|\<\|\|\>>/\<alpha\>=g> and Lemma<nbsp><reference|lem:geom> applies to give the result.
  </proof>

  One can use the following formulas for <math|c<rsub|t+1>> and <math|R<rsup|2><rsub|t+1>> (they are derived from the proof of Lemma <reference|lem:geom>). If <math|<around|\||\<nabla\>*f<around|(|x<rsub|t+1>|)>|\|><rsup|2>/\<alpha\><rsup|2>\<less\>R<rsub|t><rsup|2>/2> then one can tate <math|c<rsub|t+1>=x<rsub|t+1><rsup|++>> and <math|R<rsub|t+1><rsup|2>=<frac|<around|\||\<nabla\>*f<around|(|x<rsub|t+1>|)>|\|><rsup|2>|\<alpha\><rsup|2>>*<around*|(|1-<frac|1|\<kappa\>>|)>>. On the other hand if <math|<around|\||\<nabla\>*f<around|(|x<rsub|t+1>|)>|\|><rsup|2>/\<alpha\><rsup|2>\<geq\>R<rsub|t><rsup|2>/2> then one can tate

  <\eqnarray*>
    <tformat|<table|<row|<cell|c<rsub|t+1>>|<cell|=>|<cell|c<rsub|t>+<frac|R<rsub|t><rsup|2>+<around|\||x<rsub|t+1>-c<rsub|t>|\|><rsup|2>|2*<around|\||x<rsub|t+1><rsup|++>-c<rsub|t>|\|><rsup|2>>*<around|(|x<rsub|t+1><rsup|++>-c<rsub|t>|)>,>>|<row|<cell|R<rsub|t+1><rsup|2>>|<cell|=>|<cell|R<rsub|t><rsup|2>-<frac|<around|\||\<nabla\>*f<around|(|x<rsub|t+1>|)>|\|><rsup|2>|\<alpha\><rsup|2>*\<kappa\>>-<around*|(|<frac|R<rsub|t><rsup|2>+<around|\<\|\|\>|x<rsub|t+1>-c<rsub|t>|\<\|\|\>><rsup|2>|2*<around|\<\|\|\>|x<rsub|t+1><rsup|++>-c<rsub|t>|\<\|\|\>>>|)><rsup|2>.>>>>
  </eqnarray*>

  <section|Nesterov's accelerated gradient descent><label|sec:AGD>

  We describe here the original Nesterov's method which attains the optimal oracle complexity for smooth convex optimization. We give the details of the method both for the strongly convex and non-strongly convex case. We refer to <cite|SBC14> for a recent interpretation of the method in terms of differential equations, and to <cite|AO14> for its relation to mirror descent (see Chapter <reference|mirror>).

  <subsection|The smooth and strongly convex case>

  Nesterov's accelerated gradient descent, illustrated in Figure <reference|fig:nesterovacc>, can be described as follows: Start at an arbitrary initial point <math|x<rsub|1>=y<rsub|1>> and then iterate the following equations for <math|t\<geq\>1>,

  <\eqnarray*>
    <tformat|<table|<row|<cell|y<rsub|t+1>>|<cell|=>|<cell|x<rsub|t>-<frac|1|\<beta\>>*\<nabla\>*f<around|(|x<rsub|t>|)>,>>|<row|<cell|x<rsub|t+1>>|<cell|=>|<cell|<around*|(|1+<frac|<sqrt|\<kappa\>>-1|<sqrt|\<kappa\>>+1>|)>*y<rsub|t+1>-<frac|<sqrt|\<kappa\>>-1|<sqrt|\<kappa\>>+1>*y<rsub|t>.>>>>
  </eqnarray*>

  <\big-figure>
    <padded-center|<tikzpicture|[scale=1] <node*|tokens=1> (noeud1) at (0.5,1) [label=below right:<math|x<rsub|s>>] ; <node*|tokens=1> (noeud2) at (1.5,-1) [label=below right:<math|y<rsub|s>>] ; <node*|tokens=1> (noeud3) at (2.5,2) [label=below right:<math|y<rsub|s+1>>] ; <node*|tokens=1> (noeud4) at (2.8,3) [label=above left:<math|x<rsub|s+1>>] ; <draw*|-\<gtr\>, thick> (noeud1) -- (noeud3) node[midway, left] <math|-<frac|1|\<beta\>>*\<nabla\>*f<around|(|x<rsub|s>|)>>; <draw*|thick, dashed> (noeud2) -- (noeud4) ; <node*|tokens=1> (noeud5) at (4.5,3.3) [label=below right:<math|y<rsub|s+2>>] ; <node*|tokens=1> (noeud6) at (5.3,3.8) [label=right:<math|x<rsub|s+2>>] ; <draw*|-\<gtr\>, thick> (noeud4) -- (noeud5) ; <draw*|thick, dashed> (noeud3) -- (noeud6) ;>>

    <label|fig:nesterovacc>
  </big-figure|Illustration of Nesterov's accelerated gradient descent.>

  <\theorem>
    Let <math|f> be <math|\<alpha\>>-strongly convex and <math|\<beta\>>-smooth, then Nesterov's accelerated gradient descent satisfies

    <\equation*>
      f<around|(|y<rsub|t>|)>-f<around|(|x<rsup|\<ast\>>|)>\<leq\><frac|\<alpha\>+\<beta\>|2>*<around|\<\|\|\>|x<rsub|1>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>*exp <around*|(|-<frac|t-1|<sqrt|\<kappa\>>>|)>.
    </equation*>
  </theorem>

  <\proof>
    We define <math|\<alpha\>>-strongly convex quadratic functions <math|\<Phi\><rsub|s>,s\<geq\>1> by induction as follows:

    <\align>
      <tformat|<table|<row|<cell|>|<cell|\<Phi\><rsub|1><around|(|x|)>=f<around|(|x<rsub|1>|)>+<frac|\<alpha\>|2>*<around|\<\|\|\>|x-x<rsub|1>|\<\|\|\>><rsup|2>,<eq-number>>>|<row|<cell|>|<cell|\<Phi\><rsub|s+1><around|(|x|)>=<around*|(|1-<frac|1|<sqrt|\<kappa\>>>|)>*\<Phi\><rsub|s><around|(|x|)><eq-number>>>|<row|<cell|>|<cell|<space|2em>+<frac|1|<sqrt|\<kappa\>>>*<around*|(|f<around|(|x<rsub|s>|)>+\<nabla\>*f<around|(|x<rsub|s>|)><rsup|\<top\>>*<around|(|x-x<rsub|s>|)>+<frac|\<alpha\>|2>*<around|\<\|\|\>|x-x<rsub|s>|\<\|\|\>><rsup|2>|)>.<eq-number><label|eq:AGD0>>>>>
    </align>

    Intuitively <math|\<Phi\><rsub|s>> becomes a finer and finer approximation (from below) to <math|f> in the following sense:

    <\equation>
      <label|eq:AGD1>\<Phi\><rsub|s+1><around|(|x|)>\<leq\>f<around|(|x|)>+<around*|(|1-<frac|1|<sqrt|\<kappa\>>>|)><rsup|s>*<around|(|\<Phi\><rsub|1><around|(|x|)>-f<around|(|x|)>|)>.
    </equation>

    The above inequality can be proved immediately by induction, using the fact that by <math|\<alpha\>>-strong convexity one has

    <\equation*>
      f<around|(|x<rsub|s>|)>+\<nabla\>*f<around|(|x<rsub|s>|)><rsup|\<top\>>*<around|(|x-x<rsub|s>|)>+<frac|\<alpha\>|2>*<around|\<\|\|\>|x-x<rsub|s>|\<\|\|\>><rsup|2>\<leq\>f<around|(|x|)>.
    </equation*>

    Equation <eqref|eq:AGD1> by itself does not say much, for it to be useful one needs to understand how “far" below <math|f> is <math|\<Phi\><rsub|s>>. The following inequality answers this question:

    <\equation>
      <label|eq:AGD2>f<around|(|y<rsub|s>|)>\<leq\>min<rsub|x\<in\>\<bbb-R\><rsup|n>> \<Phi\><rsub|s><around|(|x|)>.
    </equation>

    The rest of the proof is devoted to showing that <eqref|eq:AGD2> holds true, but first let us see how to combine <eqref|eq:AGD1> and <eqref|eq:AGD2> to obtain the rate given by the theorem (we use that by <math|\<beta\>>-smoothness one has <math|f<around|(|x|)>-f<around|(|x<rsup|\<ast\>>|)>\<leq\><frac|\<beta\>|2>*<around|\<\|\|\>|x-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>>):

    <\eqnarray*>
      <tformat|<table|<row|<cell|f<around|(|y<rsub|t>|)>-f<around|(|x<rsup|\<ast\>>|)>>|<cell|\<leq\>>|<cell|\<Phi\><rsub|t><around|(|x<rsup|\<ast\>>|)>-f<around|(|x<rsup|\<ast\>>|)>>>|<row|<cell|>|<cell|\<leq\>>|<cell|<around*|(|1-<frac|1|<sqrt|\<kappa\>>>|)><rsup|t-1>*<around|(|\<Phi\><rsub|1><around|(|x<rsup|\<ast\>>|)>-f<around|(|x<rsup|\<ast\>>|)>|)>>>|<row|<cell|>|<cell|\<leq\>>|<cell|<frac|\<alpha\>+\<beta\>|2>*<around|\<\|\|\>|x<rsub|1>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>*<around*|(|1-<frac|1|<sqrt|\<kappa\>>>|)><rsup|t-1>.>>>>
    </eqnarray*>

    We now prove <eqref|eq:AGD2> by induction (note that it is true at <math|s=1> since <math|x<rsub|1>=y<rsub|1>>). Let <math|\<Phi\><rsub|s><rsup|\<ast\>>=min<rsub|x\<in\>\<bbb-R\><rsup|n>> \<Phi\><rsub|s><around|(|x|)>>. Using the definition of <math|y<rsub|s+1>> (and <math|\<beta\>>-smoothness), convexity, and the induction hypothesis, one gets

    <\eqnarray*>
      <tformat|<table|<row|<cell|f<around|(|y<rsub|s+1>|)>>|<cell|\<leq\>>|<cell|f<around|(|x<rsub|s>|)>-<frac|1|2*\<beta\>>*<around|\<\|\|\>|\<nabla\>*f<around|(|x<rsub|s>|)>|\<\|\|\>><rsup|2>>>|<row|<cell|>|<cell|=>|<cell|<around*|(|1-<frac|1|<sqrt|\<kappa\>>>|)>*f<around|(|y<rsub|s>|)>+<around*|(|1-<frac|1|<sqrt|\<kappa\>>>|)>*<around|(|f<around|(|x<rsub|s>|)>-f<around|(|y<rsub|s>|)>|)>>>|<row|<cell|>|<cell|>|<cell|+<frac|1|<sqrt|\<kappa\>>>*f<around|(|x<rsub|s>|)>-<frac|1|2*\<beta\>>*<around|\<\|\|\>|\<nabla\>*f<around|(|x<rsub|s>|)>|\<\|\|\>><rsup|2>>>|<row|<cell|>|<cell|\<leq\>>|<cell|<around*|(|1-<frac|1|<sqrt|\<kappa\>>>|)>*\<Phi\><rsub|s><rsup|\<ast\>>+<around*|(|1-<frac|1|<sqrt|\<kappa\>>>|)>*\<nabla\>*f<around|(|x<rsub|s>|)><rsup|\<top\>>*<around|(|x<rsub|s>-y<rsub|s>|)>>>|<row|<cell|>|<cell|>|<cell|+<frac|1|<sqrt|\<kappa\>>>*f<around|(|x<rsub|s>|)>-<frac|1|2*\<beta\>>*<around|\<\|\|\>|\<nabla\>*f<around|(|x<rsub|s>|)>|\<\|\|\>><rsup|2>.>>>>
    </eqnarray*>

    Thus we now have to show that

    <\eqnarray>
      <tformat|<table|<row|<cell|\<Phi\><rsub|s+1><rsup|\<ast\>>>|<cell|\<geq\>>|<cell|<around*|(|1-<frac|1|<sqrt|\<kappa\>>>|)>*\<Phi\><rsub|s><rsup|\<ast\>>+<around*|(|1-<frac|1|<sqrt|\<kappa\>>>|)>*\<nabla\>*f<around|(|x<rsub|s>|)><rsup|\<top\>>*<around|(|x<rsub|s>-y<rsub|s>|)><eq-number>>>|<row|<cell|>|<cell|>|<cell|+<frac|1|<sqrt|\<kappa\>>>*f<around|(|x<rsub|s>|)>-<frac|1|2*\<beta\>>*<around|\<\|\|\>|\<nabla\>*f<around|(|x<rsub|s>|)>|\<\|\|\>><rsup|2>.<eq-number><label|eq:AGD3>>>>>
    </eqnarray>

    To prove this inequality we have to understand better the functions <math|\<Phi\><rsub|s>>. First note that <math|\<nabla\><rsup|2>*\<Phi\><rsub|s><around|(|x|)>=\<alpha\><math-up|I><rsub|n>> (immediate by induction) and thus <math|\<Phi\><rsub|s>> has to be of the following form:

    <\equation*>
      \<Phi\><rsub|s><around|(|x|)>=\<Phi\><rsub|s><rsup|\<ast\>>+<frac|\<alpha\>|2>*<around|\<\|\|\>|x-v<rsub|s>|\<\|\|\>><rsup|2>,
    </equation*>

    for some <math|v<rsub|s>\<in\>\<bbb-R\><rsup|n>>. Now observe that by differentiating <eqref|eq:AGD0> and using the above form of <math|\<Phi\><rsub|s>> one obtains

    <\equation*>
      \<nabla\>*\<Phi\><rsub|s+1><around|(|x|)>=\<alpha\>*<around*|(|1-<frac|1|<sqrt|\<kappa\>>>|)>*<around|(|x-v<rsub|s>|)>+<frac|1|<sqrt|\<kappa\>>>*\<nabla\>*f<around|(|x<rsub|s>|)>+<frac|\<alpha\>|<sqrt|\<kappa\>>>*<around|(|x-x<rsub|s>|)>.
    </equation*>

    In particular <math|\<Phi\><rsub|s+1>> is by definition minimized at <math|v<rsub|s+1>> which can now be defined by induction using the above identity, precisely:

    <\equation>
      <label|eq:AGD4>v<rsub|s+1>=<around*|(|1-<frac|1|<sqrt|\<kappa\>>>|)>*v<rsub|s>+<frac|1|<sqrt|\<kappa\>>>*x<rsub|s>-<frac|1|\<alpha\>*<sqrt|\<kappa\>>>*\<nabla\>*f<around|(|x<rsub|s>|)>.
    </equation>

    Using the form of <math|\<Phi\><rsub|s>> and <math|\<Phi\><rsub|s+1>>, as well as the original definition <eqref|eq:AGD0> one gets the following identity by evaluating <math|\<Phi\><rsub|s+1>> at <math|x<rsub|s>>:

    <\align>
      <tformat|<table|<row|<cell|>|<cell|\<Phi\><rsub|s+1><rsup|\<ast\>>+<frac|\<alpha\>|2>*<around|\<\|\|\>|x<rsub|s>-v<rsub|s+1>|\<\|\|\>><rsup|2><eq-number>>>|<row|<cell|>|<cell|=<around*|(|1-<frac|1|<sqrt|\<kappa\>>>|)>*\<Phi\><rsub|s><rsup|\<ast\>>+<frac|\<alpha\>|2>*<around*|(|1-<frac|1|<sqrt|\<kappa\>>>|)>\<\|\|\>x<rsub|s>-v<rsub|s>\<\|\|\><rsup|2>+<frac|1|<sqrt|\<kappa\>>>*f<around|(|x<rsub|s>|)>.<eq-number><label|eq:AGD5>>>>>
    </align>

    Note that thanks to <eqref|eq:AGD4> one has

    <\eqnarray*>
      <tformat|<table|<row|<cell|<around|\<\|\|\>|x<rsub|s>-v<rsub|s+1>|\<\|\|\>><rsup|2>>|<cell|=>|<cell|<around*|(|1-<frac|1|<sqrt|\<kappa\>>>|)><rsup|2>*<around|\<\|\|\>|x<rsub|s>-v<rsub|s>*<around|\<\|\|\>|<rsup|2>+<frac|1|\<alpha\><rsup|2>*\<kappa\>>|\<\|\|\>>*\<nabla\>*f<around|(|x<rsub|s>|)>|\<\|\|\>><rsup|2>>>|<row|<cell|>|<cell|>|<cell|-<frac|2|\<alpha\>*<sqrt|\<kappa\>>>*<around*|(|1-<frac|1|<sqrt|\<kappa\>>>|)>*\<nabla\>*f<around|(|x<rsub|s>|)><rsup|\<top\>>*<around|(|v<rsub|s>-x<rsub|s>|)>,>>>>
    </eqnarray*>

    which combined with <eqref|eq:AGD5> yields

    <\eqnarray*>
      <tformat|<table|<row|<cell|\<Phi\><rsub|s+1><rsup|\<ast\>>>|<cell|=>|<cell|<around*|(|1-<frac|1|<sqrt|\<kappa\>>>|)>*\<Phi\><rsub|s><rsup|\<ast\>>+<frac|1|<sqrt|\<kappa\>>>*f<around|(|x<rsub|s>|)>+<frac|\<alpha\>|2*<sqrt|\<kappa\>>>*<around*|(|1-<frac|1|<sqrt|\<kappa\>>>|)>*<around|\<\|\|\>|x<rsub|s>-v<rsub|s>|\<\|\|\>><rsup|2>>>|<row|<cell|>|<cell|>|<cell|<space|2em>-<frac|1|2*\<beta\>>\<\|\|\>\<nabla\>*f<around|(|x<rsub|s>|)>\<\|\|\><rsup|2>+<frac|1|<sqrt|\<kappa\>>>*<around*|(|1-<frac|1|<sqrt|\<kappa\>>>|)>*\<nabla\>*f<around|(|x<rsub|s>|)><rsup|\<top\>>*<around|(|v<rsub|s>-x<rsub|s>|)>.>>>>
    </eqnarray*>

    Finally we show by induction that <math|v<rsub|s>-x<rsub|s>=<sqrt|\<kappa\>>*<around|(|x<rsub|s>-y<rsub|s>|)>>, which concludes the proof of <eqref|eq:AGD3> and thus also concludes the proof of the theorem:

    <\eqnarray*>
      <tformat|<table|<row|<cell|v<rsub|s+1>-x<rsub|s+1>>|<cell|=>|<cell|<around*|(|1-<frac|1|<sqrt|\<kappa\>>>|)>*v<rsub|s>+<frac|1|<sqrt|\<kappa\>>>*x<rsub|s>-<frac|1|\<alpha\>*<sqrt|\<kappa\>>>*\<nabla\>*f<around|(|x<rsub|s>|)>-x<rsub|s+1>>>|<row|<cell|>|<cell|=>|<cell|<sqrt|\<kappa\>>*x<rsub|s>-<around|(|<sqrt|\<kappa\>>-1|)>*y<rsub|s>-<frac|<sqrt|\<kappa\>>|\<beta\>>*\<nabla\>*f<around|(|x<rsub|s>|)>-x<rsub|s+1>>>|<row|<cell|>|<cell|=>|<cell|<sqrt|\<kappa\>>*y<rsub|s+1>-<around|(|<sqrt|\<kappa\>>-1|)>*y<rsub|s>-x<rsub|s+1>>>|<row|<cell|>|<cell|=>|<cell|<sqrt|\<kappa\>>*<around|(|x<rsub|s+1>-y<rsub|s+1>|)>,>>>>
    </eqnarray*>

    where the first equality comes from <eqref|eq:AGD4>, the second from the induction hypothesis, the third from the definition of <math|y<rsub|s+1>> and the last one from the definition of <math|x<rsub|s+1>>.
  </proof>

  <subsection|The smooth case>

  In this section we show how to adapt Nesterov's accelerated gradient descent for the case <math|\<alpha\>=0>, using a time-varying combination of the elements in the primary sequence <math|<around|(|y<rsub|t>|)>>. First we define the following sequences:

  <\equation*>
    \<lambda\><rsub|0>=0,\<lambda\><rsub|t>=<frac|1+<sqrt|1+4*\<lambda\><rsub|t-1><rsup|2>>|2>,<text|and>\<gamma\><rsub|t>=<frac|1-\<lambda\><rsub|t>|\<lambda\><rsub|t+1>>.
  </equation*>

  (Note that <math|\<gamma\><rsub|t>\<leq\>0>.) Now the algorithm is simply defined by the following equations, with <math|x<rsub|1>=y<rsub|1>> an arbitrary initial point,

  <\eqnarray*>
    <tformat|<table|<row|<cell|y<rsub|t+1>>|<cell|=>|<cell|x<rsub|t>-<frac|1|\<beta\>>*\<nabla\>*f<around|(|x<rsub|t>|)>,>>|<row|<cell|x<rsub|t+1>>|<cell|=>|<cell|<around|(|1-\<gamma\><rsub|s>|)>*y<rsub|t+1>+\<gamma\><rsub|t>*y<rsub|t>.>>>>
  </eqnarray*>

  <\theorem>
    Let <math|f> be a convex and <math|\<beta\>>-smooth function, then Nesterov's accelerated gradient descent satisfies

    <\equation*>
      f<around|(|y<rsub|t>|)>-f<around|(|x<rsup|\<ast\>>|)>\<leq\><frac|2*\<beta\>*<around|\<\|\|\>|x<rsub|1>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>|t<rsup|2>>.
    </equation*>
  </theorem>

  We follow here the proof of <cite|BT09>. We also refer to <cite|Tse08> for a proof with simpler step-sizes.

  <\proof>
    Using the unconstrained version of Lemma <reference|lem:smoothconst> one obtains

    <\align>
      <tformat|<table|<row|<cell|>|<cell|f<around|(|y<rsub|s+1>|)>-f<around|(|y<rsub|s>|)><eq-number>>>|<row|<cell|>|<cell|\<leq\>\<nabla\>*f<around|(|x<rsub|s>|)><rsup|\<top\>>*<around|(|x<rsub|s>-y<rsub|s>|)>-<frac|1|2*\<beta\>>*<around|\<\|\|\>|\<nabla\>*f<around|(|x<rsub|s>|)>|\<\|\|\>><rsup|2><eq-number>>>|<row|<cell|>|<cell|=\<beta\>*<around|(|x<rsub|s>-y<rsub|s+1>|)><rsup|\<top\>>*<around|(|x<rsub|s>-y<rsub|s>|)>-<frac|\<beta\>|2>*<around|\<\|\|\>|x<rsub|s>-y<rsub|s+1>|\<\|\|\>><rsup|2>.<eq-number><label|eq:1>>>>>
    </align>

    Similarly we also get

    <\equation>
      <label|eq:2>f<around|(|y<rsub|s+1>|)>-f<around|(|x<rsup|\<ast\>>|)>\<leq\>\<beta\>*<around|(|x<rsub|s>-y<rsub|s+1>|)><rsup|\<top\>>*<around|(|x<rsub|s>-x<rsup|\<ast\>>|)>-<frac|\<beta\>|2>*<around|\<\|\|\>|x<rsub|s>-y<rsub|s+1>|\<\|\|\>><rsup|2>.
    </equation>

    Now multiplying <eqref|eq:1> by <math|<around|(|\<lambda\><rsub|s>-1|)>> and adding the result to <eqref|eq:2>, one obtains with <math|\<delta\><rsub|s>=f<around|(|y<rsub|s>|)>-f<around|(|x<rsup|\<ast\>>|)>>,

    <\align*>
      <tformat|<table|<row|<cell|>|<cell|\<lambda\><rsub|s>*\<delta\><rsub|s+1>-<around|(|\<lambda\><rsub|s>-1|)>*\<delta\><rsub|s>>>|<row|<cell|>|<cell|\<leq\>\<beta\>*<around|(|x<rsub|s>-y<rsub|s+1>|)><rsup|\<top\>>*<around|(|\<lambda\><rsub|s>*x<rsub|s>-<around|(|\<lambda\><rsub|s>-1|)>*y<rsub|s>-x<rsup|\<ast\>>|)>-<frac|\<beta\>|2>*\<lambda\><rsub|s>*<around|\<\|\|\>|x<rsub|s>-y<rsub|s+1>|\<\|\|\>><rsup|2>.>>>>
    </align*>

    Multiplying this inequality by <math|\<lambda\><rsub|s>> and using that by definition <math|\<lambda\><rsub|s-1><rsup|2>=\<lambda\><rsub|s><rsup|2>-\<lambda\><rsub|s>>, as well as the elementary identity <math|2*a<rsup|\<top\>>*b-<around|\<\|\|\>|a|\<\|\|\>><rsup|2>=<around|\<\|\|\>|b|\<\|\|\>><rsup|2>-<around|\<\|\|\>|b-a|\<\|\|\>><rsup|2>>, one obtains

    <\align>
      <tformat|<table|<row|<cell|>|<cell|\<lambda\><rsub|s><rsup|2>*\<delta\><rsub|s+1>-\<lambda\><rsub|s-1><rsup|2>*\<delta\><rsub|s><eq-number>>>|<row|<cell|>|<cell|\<leq\><frac|\<beta\>|2>*<around*|(|2*\<lambda\><rsub|s>*<around|(|x<rsub|s>-y<rsub|s+1>|)><rsup|\<top\>>*<around|(|\<lambda\><rsub|s>*x<rsub|s>-<around|(|\<lambda\><rsub|s>-1|)>*y<rsub|s>-x<rsup|\<ast\>>|)>-<around|\<\|\|\>|\<lambda\><rsub|s>*<around|(|y<rsub|s+1>-x<rsub|s>|)>|\<\|\|\>><rsup|2>|)><eq-number>>>|<row|<cell|>|<cell|=<frac|\<beta\>|2>*<around*|(|<around|\<\|\|\>|\<lambda\><rsub|s>*x<rsub|s>-<around|(|\<lambda\><rsub|s>-1|)>*y<rsub|s>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>-<around|\<\|\|\>|\<lambda\><rsub|s>*y<rsub|s+1>-<around|(|\<lambda\><rsub|s>-1|)>*y<rsub|s>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>|)>.<eq-number><label|eq:3>>>>>
    </align>

    Next remark that, by definition, one has

    <\align>
      <tformat|<table|<row|<cell|>|<cell|x<rsub|s+1>=y<rsub|s+1>+\<gamma\><rsub|s>*<around|(|y<rsub|s>-y<rsub|s+1>|)><eq-number>>>|<row|<cell|>|<cell|\<Leftrightarrow\>\<lambda\><rsub|s+1>*x<rsub|s+1>=\<lambda\><rsub|s+1>*y<rsub|s+1>+<around|(|1-\<lambda\><rsub|s>|)>*<around|(|y<rsub|s>-y<rsub|s+1>|)><eq-number>>>|<row|<cell|>|<cell|\<Leftrightarrow\>\<lambda\><rsub|s+1>*x<rsub|s+1>-<around|(|\<lambda\><rsub|s+1>-1|)>*y<rsub|s+1>=\<lambda\><rsub|s>*y<rsub|s+1>-<around|(|\<lambda\><rsub|s>-1|)>*y<rsub|s>.<eq-number><label|eq:5>>>>>
    </align>

    Putting together <eqref|eq:3> and <eqref|eq:5> one gets with <math|u<rsub|s>=\<lambda\><rsub|s>*x<rsub|s>-<around|(|\<lambda\><rsub|s>-1|)>*y<rsub|s>-x<rsup|\<ast\>>>,

    <\equation*>
      \<lambda\><rsub|s><rsup|2>*\<delta\><rsub|s+1>-\<lambda\><rsub|s-1><rsup|2>*\<delta\><rsub|s><rsup|2>\<leq\><frac|\<beta\>|2>*<around*|(|<around|\<\|\|\>|u<rsub|s>|\<\|\|\>><rsup|2>-<around|\<\|\|\>|u<rsub|s+1>|\<\|\|\>><rsup|2>|)>.
    </equation*>

    Summing these inequalities from <math|s=1> to <math|s=t-1> one obtains:

    <\equation*>
      \<delta\><rsub|t>\<leq\><frac|\<beta\>|2*\<lambda\><rsub|t-1><rsup|2>><around|\<\|\|\>|u<rsub|1>|\<\|\|\>><rsup|2>.
    </equation*>

    By induction it is easy to see that <math|\<lambda\><rsub|t-1>\<geq\><frac|t|2>> which concludes the proof.
  </proof>

  <chapter|Almost dimension-free convex optimization in non-Euclidean spaces><label|mirror>

  In the previous chapter we showed that dimension-free oracle complexity is possible when the objective function <math|f> and the constraint set <math|<cX>> are well-behaved in the Euclidean norm; e.g. if for all points <math|x\<in\><cX>> and all subgradients <math|g\<in\>\<partial\>*f<around|(|x|)>>, one has that <math|<around|\<\|\|\>|x|\<\|\|\>><rsub|2>> and <math|<around|\<\|\|\>|g|\<\|\|\>><rsub|2>> are independent of the ambient dimension <math|n>. If this assumption is not met then the gradient descent techniques of Chapter <reference|dimfree> may lose their dimension-free convergence rates. For instance consider a differentiable convex function <math|f> defined on the Euclidean ball <math|<mB><rsub|2,n>> and such that <math|<around|\<\|\|\>|\<nabla\>*f<around|(|x|)>|\<\|\|\>><rsub|\<infty\>>\<leq\>1,\<forall\>x\<in\><mB><rsub|2,n>>. This implies that <math|<around|\<\|\|\>|\<nabla\>*f<around|(|x|)>|\<\|\|\>><rsub|2>\<leq\><sqrt|n>>, and thus projected gradient descent will converge to the minimum of <math|f> on <math|<mB><rsub|2,n>> at a rate <math|<sqrt|n/t>>. In this chapter we describe the method of <cite|NY83>, known as mirror descent, which allows to find the minimum of such functions <math|f> over the <math|\<ell\><rsub|1>>-ball (instead of the Euclidean ball) at the much faster rate <math|<sqrt|log <around|(|n|)>/t>>. This is only one example of the potential of mirror descent. This chapter is devoted to the description of mirror descent and some of its alternatives. The presentation is inspired from <cite|BT03>, [Chapter 11, <cite|CL06>], <cite|Rak09|Haz11|Bub11>.<new-page>

  In order to describe the intuition behind the method let us abstract the situation for a moment and forget that we are doing optimization in finite dimension. We already observed that projected gradient descent works in an arbitrary Hilbert space <math|\<cal-H\>>. Suppose now that we are interested in the more general situation of optimization in some Banach space <math|\<cal-B\>>. In other words the norm that we use to measure the various quantity of interest does not derive from an inner product (think of <math|\<cal-B\>=\<ell\><rsub|1>> for example). In that case the gradient descent strategy does not even make sense: indeed the gradients (more formally the Fréchet derivative) <math|\<nabla\>*f<around|(|x|)>> are elements of the dual space <math|\<cal-B\><rsup|\<ast\>>> and thus one cannot perform the computation <math|x-\<eta\>*\<nabla\>*f<around|(|x|)>> (it simply does not make sense). We did not have this problem for optimization in a Hilbert space <math|\<cal-H\>> since by Riesz representation theorem <math|\<cal-H\><rsup|\<ast\>>> is isometric to <math|\<cal-H\>>. The great insight of Nemirovski and Yudin is that one can still do a gradient descent by first mapping the point <math|x\<in\>\<cal-B\>> into the dual space <math|\<cal-B\><rsup|\<ast\>>>, then performing the gradient update in the dual space, and finally mapping back the resulting point to the primal space <math|\<cal-B\>>. Of course the new point in the primal space might lie outside of the constraint set <math|\<cal-X\>\<subset\>\<cal-B\>> and thus we need a way to project back the point on the constraint set <math|\<cal-X\>>. Both the primal/dual mapping and the projection are based on the concept of a <with|font-shape|italic|mirror map> which is the key element of the scheme. Mirror maps are defined in Section <reference|sec:mm>, and the above scheme is formally described in Section <reference|sec:MD>.

  In the rest of this chapter we fix an arbitrary norm <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>>> on <math|<R><rsup|n>>, and a compact convex set <math|<cX>\<subset\><R><rsup|n>>. The dual norm <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>><rsub|\<ast\>>> is defined as <math|<around|\<\|\|\>|g|\<\|\|\>><rsub|\<ast\>>=sup<rsub|x\<in\>\<bbb-R\><rsup|n>:<around|\<\|\|\>|x|\<\|\|\>>\<leq\>1> g<rsup|\<top\>>*x>. We say that a convex function <math|f:<cX>\<rightarrow\><R>> is (i) <math|L>-Lipschitz w.r.t. <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>>> if <math|\<forall\>x\<in\><cX>,g\<in\>\<partial\>*f<around|(|x|)>,<around|\<\|\|\>|g|\<\|\|\>><rsub|\<ast\>>\<leq\>L>, (ii) <math|\<beta\>>-smooth w.r.t. <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>>> if <math|<around|\<\|\|\>|\<nabla\>*f<around|(|x|)>-\<nabla\>*f<around|(|y|)>|\<\|\|\>><rsub|\<ast\>>\<leq\>\<beta\>*<around|\<\|\|\>|x-y|\<\|\|\>>,\<forall\>x,y\<in\><cX>>, and (iii) <math|\<alpha\>>-strongly convex w.r.t. <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>>> if

  <\equation*>
    f<around|(|x|)>-f<around|(|y|)>\<leq\>g<rsup|\<top\>>*<around|(|x-y|)>-<frac|\<alpha\>|2>*<around|\<\|\|\>|x-y|\<\|\|\>><rsup|2>,\<forall\>x,y\<in\><cX>,g\<in\>\<partial\>*f<around|(|x|)>.
  </equation*>

  We also define the Bregman divergence associated to <math|f> as

  <\equation*>
    D<rsub|f>*<around|(|x,y|)>=f<around|(|x|)>-f<around|(|y|)>-\<nabla\>*f<around|(|y|)><rsup|\<top\>>*<around|(|x-y|)>.
  </equation*>

  The following identity will be useful several times:

  <\equation>
    <label|eq:useful1><around|(|\<nabla\>*f<around|(|x|)>-\<nabla\>*f<around|(|y|)>|)><rsup|\<top\>>*<around|(|x-z|)>=D<rsub|f>*<around|(|x,y|)>+D<rsub|f>*<around|(|z,x|)>-D<rsub|f>*<around|(|z,y|)>.
  </equation>

  <section|Mirror maps><label|sec:mm>

  Let <math|<cD>\<subset\><R><rsup|n>> be a convex open set such that <math|\<cal-X\>> is included in its closure, that is <math|\<cal-X\>\<subset\><wide|\<cal-D\>|\<bar\>>>, and <math|\<cal-X\>\<cap\>\<cal-D\>\<neq\>\<emptyset\>>. We say that <math|\<Phi\>:<cD>\<rightarrow\><R>> is a mirror map if it safisfies the following properties<footnote|Assumption (ii) can be relaxed in some cases, see for example <cite|ABL14>.>:

  <\enumerate>
    <item*|(i)><math|\<Phi\>> is strictly convex and differentiable.

    <item*|(ii)>The gradient of <math|\<Phi\>> takes all possible values, that is <math|\<nabla\>*\<Phi\><around|(|<cD>|)>=<R><rsup|n>>.

    <item*|(iii)>The gradient of <math|\<Phi\>> diverges on the boundary of <math|<cD>>, that is

    <\equation*>
      lim<rsub|x\<rightarrow\>\<partial\>*\<cal-D\>><around|\<\|\|\>|\<nabla\>*\<Phi\><around|(|x|)>|\<\|\|\>>=+\<infty\>.
    </equation*>
  </enumerate>

  In mirror descent the gradient of the mirror map <math|\<Phi\>> is used to map points from the “primal" to the “dual" (note that all points lie in <math|<R><rsup|n>> so the notions of primal and dual spaces only have an intuitive meaning). Precisely a point <math|x\<in\>\<cal-X\>\<cap\>\<cal-D\>> is mapped to <math|\<nabla\>*\<Phi\><around|(|x|)>>, from which one takes a gradient step to get to <math|\<nabla\>*\<Phi\><around|(|x|)>-\<eta\>*\<nabla\>*f<around|(|x|)>>. Property (ii) then allows us to write the resulting point as <math|\<nabla\>*\<Phi\><around|(|y|)>=\<nabla\>*\<Phi\><around|(|x|)>-\<eta\>*\<nabla\>*f<around|(|x|)>> for some <math|y\<in\><cD>>. The primal point <math|y> may lie outside of the set of constraints <math|<cX>>, in which case one has to project back onto <math|<cX>>. In mirror descent this projection is done via the Bregman divergence associated to <math|\<Phi\>>. Precisely one defines

  <\equation*>
    \<Pi\><rsub|<cX>><rsup|\<Phi\>><around|(|y|)>=<argmin><rsub|x\<in\>\<cal-X\>\<cap\>\<cal-D\>>D<rsub|\<Phi\>>*<around|(|x,y|)>.
  </equation*>

  Property (i) and (iii) ensures the existence and uniqueness of this projection (in particular since <math|x\<mapsto\>D<rsub|\<Phi\>>*<around|(|x,y|)>> is locally increasing on the boundary of <math|\<cal-D\>>). The following lemma shows that the Bregman divergence essentially behaves as the Euclidean norm squared in terms of projections (recall Lemma <reference|lem:todonow>).

  <\lemma>
    <label|lem:todonow2>Let <math|x\<in\><cX>\<cap\><cD>> and <math|y\<in\><cD>>, then

    <\equation*>
      <around|(|\<nabla\>*\<Phi\><around|(|\<Pi\><rsub|<cX>><rsup|\<Phi\>><around|(|y|)>|)>-\<nabla\>*\<Phi\><around|(|y|)>|)><rsup|\<top\>>*<around|(|\<Pi\><rsup|\<Phi\>><rsub|<cX>><around|(|y|)>-x|)>\<leq\>0,
    </equation*>

    which also implies

    <\equation*>
      D<rsub|\<Phi\>>*<around|(|x,\<Pi\><rsup|\<Phi\>><rsub|<cX>><around|(|y|)>|)>+D<rsub|\<Phi\>>*<around|(|\<Pi\><rsup|\<Phi\>><rsub|<cX>><around|(|y|)>,y|)>\<leq\>D<rsub|\<Phi\>>*<around|(|x,y|)>.
    </equation*>
  </lemma>

  <\proof>
    The proof is an immediate corollary of Proposition <reference|prop:firstorder> together with the fact that <math|\<nabla\><rsub|x>*D<rsub|\<Phi\>>*<around|(|x,y|)>=\<nabla\>*\<Phi\><around|(|x|)>-\<nabla\>*\<Phi\><around|(|y|)>>.
  </proof>

  <section|Mirror descent><label|sec:MD>

  We can now describe the mirror descent strategy based on a mirror map <math|\<Phi\>>. Let <math|x<rsub|1>\<in\><argmin><rsub|x\<in\>\<cal-X\>\<cap\>\<cal-D\>>\<Phi\><around|(|x|)>>. Then for <math|t\<geq\>1>, let <math|y<rsub|t+1>\<in\>\<cal-D\>> such that

  <\equation>
    <label|eq:MD1>\<nabla\>*\<Phi\><around|(|y<rsub|t+1>|)>=\<nabla\>*\<Phi\><around|(|x<rsub|t>|)>-\<eta\>*g<rsub|t>,<text|where>g<rsub|t>\<in\>\<partial\>*f<around|(|x<rsub|t>|)>,
  </equation>

  and

  <\equation>
    <label|eq:MD2>x<rsub|t+1>\<in\>\<Pi\><rsub|<cX>><rsup|\<Phi\>><around|(|y<rsub|t+1>|)>.
  </equation>

  See Figure <reference|fig:MD> for an illustration of this procedure.

  <big-figure|<tikzpicture|[scale=3.5] <clip>(-2.4,-0.7) rectangle (1,1); <draw*|rotate=30, very thick> (0,-0.5) ellipse (0.7 and 1); <draw*|very thick> (-2,0) ellipse (1 and 0.5); <node>(S) [very thick, regular polygon, regular polygon sides=6, draw, inner sep=20] at (0,0) ; <node>at (0.3,-0.6) <math|<cD>>; <node>at (-1.9,-0.4) <math|<R><rsup|n>>; <node>at (0.1, -0.2) <math|<cX>>; <node*|tokens=1> (noeudat) at (-0.1,0.15) [label=right:<math|x<rsub|t>>] ; <node*|tokens=1> (noeudat1) at (-0.15,-0.1) [label=right:<math|x<rsub|t+1>>] ; <node*|tokens=1> (noeudwt1) at (-0.4,-0.45) [label=below right:<math|y<rsub|t+1>>] ; <draw*|-\<gtr\>, thick> (noeudwt1) .. controls (-0.3, -0.45) and (-0.15, -0.2) .. (noeudat1) node[midway, below right] projection <eqref|eq:MD2>; <node*|tokens=1> (noeudmat) at (-1.62,0.15) [label=right:<math|\<nabla\>*\<Phi\><around|(|x<rsub|t>|)>>] ; <node*|tokens=1> (noeudmwt1) at (-1.42,-0.1) [label=right:<math|\<nabla\>*\<Phi\><around|(|y<rsub|t+1>|)>>] ; <draw*|-\<gtr\>, thick> (noeudmat) -- (noeudmwt1) node[midway, left] <tabular*|<tformat|<cwith|1|-1|1|1|cell-halign|c>|<cwith|1|-1|1|1|cell-lborder|0ln>|<cwith|1|-1|1|1|cell-rborder|0ln>|<cwith|1|-1|1|-1|cell-valign|c>|<table|<row|<cell|>>|<row|<cell|gradient step>>|<row|<cell|<eqref|eq:MD1>>>>>>; <draw*|-\<gtr\>, semithick> (noeudat) .. controls (-0.6,0.45) and (-1.12, 0.45) .. (noeudmat) node[midway, above] <math|\<nabla\>*\<Phi\>>; <draw*|-\<gtr\>, semithick> (noeudmwt1) .. controls (-1.22,-0.5) and (-0.44, -0.46) .. (noeudwt1) node[midway, below] <math|<around|(|\<nabla\>*\<Phi\>|)><rsup|-1>>;><label|fig:MD>|Illustration of mirror descent.<label|fig:MD>>

  <\theorem>
    <label|th:MD>Let <math|\<Phi\>> be a mirror map <math|\<rho\>>-strongly convex on <math|\<cal-X\>\<cap\>\<cal-D\>> w.r.t. <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>>>. Let <math|R<rsup|2>=sup<rsub|x\<in\>\<cal-X\>\<cap\>\<cal-D\>> \<Phi\><around|(|x|)>-\<Phi\><around|(|x<rsub|1>|)>>, and <math|f> be convex and <math|L>-Lipschitz w.r.t. <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>>>. Then mirror descent with <math|\<eta\>=<frac|R|L>*<sqrt|<frac|2*\<rho\>|t>>> satisfies

    <\equation*>
      f*<around*|(|<frac|1|t>*<big|sum><rsub|s=1><rsup|t>x<rsub|s>|)>-f<around|(|x<rsup|\<ast\>>|)>\<leq\>R*L*<sqrt|<frac|2|\<rho\>*t>>.
    </equation*>
  </theorem>

  <\proof>
    Let <math|x\<in\>\<cal-X\>\<cap\>\<cal-D\>>. The claimed bound will be obtained by taking a limit <math|x\<rightarrow\>x<rsup|\<ast\>>>. Now by convexity of <math|f>, the definition of mirror descent, equation <eqref|eq:useful1>, and Lemma <reference|lem:todonow2>, one has

    <\align*>
      <tformat|<table|<row|<cell|>|<cell|f<around|(|x<rsub|s>|)>-f<around|(|x|)>>>|<row|<cell|>|<cell|\<leq\>g<rsub|s><rsup|\<top\>>*<around|(|x<rsub|s>-x|)>>>|<row|<cell|>|<cell|=<frac|1|\<eta\>>*<around|(|\<nabla\>*\<Phi\><around|(|x<rsub|s>|)>-\<nabla\>*\<Phi\><around|(|y<rsub|s+1>|)>|)><rsup|\<top\>>*<around|(|x<rsub|s>-x|)>>>|<row|<cell|>|<cell|=<frac|1|\<eta\>>*<around*|(|D<rsub|\<Phi\>>*<around|(|x,x<rsub|s>|)>+D<rsub|\<Phi\>>*<around|(|x<rsub|s>,y<rsub|s+1>|)>-D<rsub|\<Phi\>>*<around|(|x,y<rsub|s+1>|)>|)>>>|<row|<cell|>|<cell|\<leq\><frac|1|\<eta\>>*<around*|(|D<rsub|\<Phi\>>*<around|(|x,x<rsub|s>|)>+D<rsub|\<Phi\>>*<around|(|x<rsub|s>,y<rsub|s+1>|)>-D<rsub|\<Phi\>>*<around|(|x,x<rsub|s+1>|)>-D<rsub|\<Phi\>>*<around|(|x<rsub|s+1>,y<rsub|s+1>|)>|)>.>>>>
    </align*>

    The term <math|D<rsub|\<Phi\>>*<around|(|x,x<rsub|s>|)>-D<rsub|\<Phi\>>*<around|(|x,x<rsub|s+1>|)>> will lead to a telescopic sum when summing over <math|s=1> to <math|s=t>, and it remains to bound the other term as follows using <math|\<rho\>>-strong convexity of the mirror map and <math|a*z-b*z<rsup|2>\<leq\><frac|a<rsup|2>|4*b>,\<forall\>z\<in\><R>>:

    <\align*>
      <tformat|<table|<row|<cell|>|<cell|D<rsub|\<Phi\>>*<around|(|x<rsub|s>,y<rsub|s+1>|)>-D<rsub|\<Phi\>>*<around|(|x<rsub|s+1>,y<rsub|s+1>|)>>>|<row|<cell|>|<cell|=\<Phi\><around|(|x<rsub|s>|)>-\<Phi\><around|(|x<rsub|s+1>|)>-\<nabla\>*\<Phi\><around|(|y<rsub|s+1>|)><rsup|\<top\>>*<around|(|x<rsub|s>-x<rsub|s+1>|)>>>|<row|<cell|>|<cell|\<leq\><around|(|\<nabla\>*\<Phi\><around|(|x<rsub|s>|)>-\<nabla\>*\<Phi\><around|(|y<rsub|s+1>|)>|)><rsup|\<top\>>*<around|(|x<rsub|s>-x<rsub|s+1>|)>-<frac|\<rho\>|2>*<around|\<\|\|\>|x<rsub|s>-x<rsub|s+1>|\<\|\|\>><rsup|2>>>|<row|<cell|>|<cell|=\<eta\>*g<rsub|s><rsup|\<top\>>*<around|(|x<rsub|s>-x<rsub|s+1>|)>-<frac|\<rho\>|2>*<around|\<\|\|\>|x<rsub|s>-x<rsub|s+1>|\<\|\|\>><rsup|2>>>|<row|<cell|>|<cell|\<leq\>\<eta\>*L\<\|\|\>x<rsub|s>-x<rsub|s+1>\<\|\|\>-<frac|\<rho\>|2>*<around|\<\|\|\>|x<rsub|s>-x<rsub|s+1>|\<\|\|\>><rsup|2>>>|<row|<cell|>|<cell|\<leq\><frac|<around|(|\<eta\>*L|)><rsup|2>|2*\<rho\>>.>>>>
    </align*>

    We proved

    <\equation*>
      <big|sum><rsub|s=1><rsup|t><around*|(|f<around|(|x<rsub|s>|)>-f<around|(|x|)>|)>\<leq\><frac|D<rsub|\<Phi\>>*<around|(|x,x<rsub|1>|)>|\<eta\>>+\<eta\>*<frac|L<rsup|2>*t|2*\<rho\>>,
    </equation*>

    which concludes the proof up to trivial computation.
  </proof>

  We observe that one can rewrite mirror descent as follows:

  <\eqnarray>
    <tformat|<table|<row|<cell|x<rsub|t+1>>|<cell|=>|<cell|<argmin><rsub|x\<in\>\<cal-X\>\<cap\>\<cal-D\>>D<rsub|\<Phi\>>*<around|(|x,y<rsub|t+1>|)><eq-number>>>|<row|<cell|>|<cell|=>|<cell|<argmin><rsub|x\<in\>\<cal-X\>\<cap\>\<cal-D\>>\<Phi\><around|(|x|)>-\<nabla\>*\<Phi\><around|(|y<rsub|t+1>|)><rsup|\<top\>>*x<eq-number><label|eq:MD3>>>|<row|<cell|>|<cell|=>|<cell|<argmin><rsub|x\<in\>\<cal-X\>\<cap\>\<cal-D\>>\<Phi\><around|(|x|)>-<around|(|\<nabla\>*\<Phi\><around|(|x<rsub|t>|)>-\<eta\>*g<rsub|t>|)><rsup|\<top\>>*x<eq-number>>>|<row|<cell|>|<cell|=>|<cell|<argmin><rsub|x\<in\>\<cal-X\>\<cap\>\<cal-D\>>\<eta\>*g<rsub|t><rsup|\<top\>>*x+D<rsub|\<Phi\>>*<around|(|x,x<rsub|t>|)>.<eq-number><label|eq:MDproxview>>>>>
  </eqnarray>

  This last expression is often taken as the definition of mirror descent (see <cite|BT03>). It gives a proximal point of view on mirror descent: the method is trying to minimize the local linearization of the function while not moving too far away from the previous point, with distances measured via the Bregman divergence of the mirror map.

  <section|Standard setups for mirror descent><label|sec:mdsetups>

  <no-indent><with|font-series|bold|“Ball setup".> The simplest version of mirror descent is obtained by taking <math|\<Phi\><around|(|x|)>=<frac|1|2><around|\<\|\|\>|x|\<\|\|\>><rsup|2><rsub|2>> on <math|\<cal-D\>=\<bbb-R\><rsup|n>>. The function <math|\<Phi\>> is a mirror map strongly convex w.r.t. <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>><rsub|2>>, and furthermore the associated Bregman divergence is given by <math|D<rsub|\<Phi\>>*<around|(|x,y|)>=<frac|1|2>*<around|\<\|\|\>|x-y|\<\|\|\>><rsup|2><rsub|2>>. Thus in that case mirror descent is exactly equivalent to projected subgradient descent, and the rate of convergence obtained in Theorem <reference|th:MD> recovers our earlier result on projected subgradient descent.

  <no-indent><with|font-series|bold|“Simplex setup".> A more interesting choice of a mirror map is given by the negative entropy

  <\equation*>
    \<Phi\><around|(|x|)>=<big|sum><rsub|i=1><rsup|n>x<around|(|i|)>*log x<around|(|i|)>,
  </equation*>

  on <math|\<cal-D\>=\<bbb-R\><rsub|++><rsup|n>>. In that case the gradient update <math|\<nabla\>*\<Phi\><around|(|y<rsub|t+1>|)>=\<nabla\>*\<Phi\><around|(|x<rsub|t>|)>-\<eta\>*\<nabla\>*f<around|(|x<rsub|t>|)>> can be written equivalently as

  <\equation*>
    y<rsub|t+1><around|(|i|)>=x<rsub|t><around|(|i|)>*exp <around*|(|-\<eta\>*<around|[|\<nabla\>*f<around|(|x<rsub|t>|)>|]><around|(|i|)>|)>,i=1,\<ldots\>,n.
  </equation*>

  The Bregman divergence of this mirror map is given by <math|D<rsub|\<Phi\>>*<around|(|x,y|)>=<big|sum><rsub|i=1><rsup|n>x<around|(|i|)>*log <frac|x<around|(|i|)>|y<around|(|i|)>>> (also known as the Kullback-Leibler divergence). It is easy to verify that the projection with respect to this Bregman divergence on the simplex <math|\<Delta\><rsub|n>=<around|{|x\<in\>\<bbb-R\><rsub|+><rsup|n>:<big|sum><rsub|i=1><rsup|n>x<around|(|i|)>=1|}>> amounts to a simple renormalization <math|y\<mapsto\>y/<around|\<\|\|\>|y|\<\|\|\>><rsub|1>>. Furthermore it is also easy to verify that <math|\<Phi\>> is <math|1>-strongly convex w.r.t. <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>><rsub|1>> on <math|\<Delta\><rsub|n>> (this result is known as Pinsker's inequality). Note also that for <math|\<cal-X\>=\<Delta\><rsub|n>> one has <math|x<rsub|1>=<around|(|1/n,\<ldots\>,1/n|)>> and <math|R<rsup|2>=log n>.

  The above observations imply that when minimizing on the simplex <math|\<Delta\><rsub|n>> a function <math|f> with subgradients bounded in <math|\<ell\><rsub|\<infty\>>>-norm, mirror descent with the negative entropy achieves a rate of convergence of order <math|<sqrt|<frac|log n|t>>>. On the other hand the regular subgradient descent achieves only a rate of order <math|<sqrt|<frac|n|t>>> in this case!

  <no-indent><with|font-series|bold|“Spectrahedron setup".> We consider here functions defined on matrices, and we are interested in minimizing a function <math|f> on the <with|font-shape|italic|spectrahedron> <math|\<cal-S\><rsub|n>> defined as:

  <\equation*>
    \<cal-S\><rsub|n>=<around*|{|X\<in\>\<bbb-S\><rsub|+><rsup|n>:<math-up|Tr><around|(|X|)>=1|}>.
  </equation*>

  In this setting we consider the mirror map on <math|\<cal-D\>=\<bbb-S\><rsub|++><rsup|n>> given by the negative von Neumann entropy:

  <\equation*>
    \<Phi\><around|(|X|)>=<big|sum><rsub|i=1><rsup|n>\<lambda\><rsub|i><around|(|X|)>*log \<lambda\><rsub|i><around|(|X|)>,
  </equation*>

  where <math|\<lambda\><rsub|1><around|(|X|)>,\<ldots\>,\<lambda\><rsub|n><around|(|X|)>> are the eigenvalues of <math|X>. It can be shown that the gradient update <math|\<nabla\>*\<Phi\><around|(|Y<rsub|t+1>|)>=\<nabla\>*\<Phi\><around|(|X<rsub|t>|)>-\<eta\>*\<nabla\>*f<around|(|X<rsub|t>|)>> can be written equivalently as

  <\equation*>
    Y<rsub|t+1>=exp <around*|(|log X<rsub|t>-\<eta\>*\<nabla\>*f<around|(|X<rsub|t>|)>|)>,
  </equation*>

  where the matrix exponential and matrix logarithm are defined as usual. Furthermore the projection on <math|\<cal-S\><rsub|n>> is a simple trace renormalization.

  With highly non-trivial computation one can show that <math|\<Phi\>> is <math|<frac|1|2>>-strongly convex with respect to the Schatten <math|1>-norm defined as

  <\equation*>
    <around|\<\|\|\>|X|\<\|\|\>><rsub|1>=<big|sum><rsub|i=1><rsup|n>\<lambda\><rsub|i><around|(|X|)>.
  </equation*>

  It is easy to see that for <math|\<cal-X\>=\<cal-S\><rsub|n>> one has <math|x<rsub|1>=<frac|1|n><mI><rsub|n>> and <math|R<rsup|2>=log n>. In other words the rate of convergence for optimization on the spectrahedron is the same than on the simplex!

  <section|Lazy mirror descent, aka Nesterov's dual averaging>

  In this section we consider a slightly more efficient version of mirror descent for which we can prove that Theorem <reference|th:MD> still holds true. This alternative algorithm can be advantageous in some situations (such as distributed settings), but the basic mirror descent scheme remains important for extensions considered later in this text (saddle points, stochastic oracles, ...).

  In lazy mirror descent, also commonly known as Nesterov's dual averaging or simply dual averaging, one replaces <eqref|eq:MD1> by

  <\equation*>
    \<nabla\>*\<Phi\><around|(|y<rsub|t+1>|)>=\<nabla\>*\<Phi\><around|(|y<rsub|t>|)>-\<eta\>*g<rsub|t>,
  </equation*>

  and also <math|y<rsub|1>> is such that <math|\<nabla\>*\<Phi\><around|(|y<rsub|1>|)>=0>. In other words instead of going back and forth between the primal and the dual, dual averaging simply averages the gradients in the dual, and if asked for a point in the primal it simply maps the current dual point to the primal using the same methodology as mirror descent. In particular using <eqref|eq:MD3> one immediately sees that dual averaging is defined by:

  <\equation>
    <label|eq:DA0>x<rsub|t>=<argmin><rsub|x\<in\>\<cal-X\>\<cap\>\<cal-D\>>\<eta\>*<big|sum><rsub|s=1><rsup|t-1>g<rsub|s><rsup|\<top\>>*x+\<Phi\><around|(|x|)>.
  </equation>

  <\theorem>
    Let <math|\<Phi\>> be a mirror map <math|\<rho\>>-strongly convex on <math|\<cal-X\>\<cap\>\<cal-D\>> w.r.t. <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>>>. Let <math|R<rsup|2>=sup<rsub|x\<in\>\<cal-X\>\<cap\>\<cal-D\>> \<Phi\><around|(|x|)>-\<Phi\><around|(|x<rsub|1>|)>>, and <math|f> be convex and <math|L>-Lipschitz w.r.t. <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>>>. Then dual averaging with <math|\<eta\>=<frac|R|L>*<sqrt|<frac|\<rho\>|2*t>>> satisfies

    <\equation*>
      f*<around*|(|<frac|1|t>*<big|sum><rsub|s=1><rsup|t>x<rsub|s>|)>-f<around|(|x<rsup|\<ast\>>|)>\<leq\>2*R*L*<sqrt|<frac|2|\<rho\>*t>>.
    </equation*>
  </theorem>

  <\proof>
    We define <math|\<psi\><rsub|t><around|(|x|)>=\<eta\>*<big|sum><rsub|s=1><rsup|t>g<rsub|s><rsup|\<top\>>*x+\<Phi\><around|(|x|)>>, so that <math|x<rsub|t>\<in\><argmin><rsub|x\<in\>\<cal-X\>\<cap\>\<cal-D\>>\<psi\><rsub|t-1><around|(|x|)>>. Since <math|\<Phi\>> is <math|\<rho\>>-strongly convex one clearly has that <math|\<psi\><rsub|t>> is <math|\<rho\>>-strongly convex, and thus

    <\eqnarray*>
      <tformat|<table|<row|<cell|\<psi\><rsub|t><around|(|x<rsub|t+1>|)>-\<psi\><rsub|t><around|(|x<rsub|t>|)>>|<cell|\<leq\>>|<cell|\<nabla\>*\<psi\><rsub|t><around|(|x<rsub|t+1>|)><rsup|\<top\>>*<around|(|x<rsub|t+1>-x<rsub|t>|)>-<frac|\<rho\>|2>*<around|\<\|\|\>|x<rsub|t+1>-x<rsub|t>|\<\|\|\>><rsup|2>>>|<row|<cell|>|<cell|\<leq\>>|<cell|-<frac|\<rho\>|2>*<around|\<\|\|\>|x<rsub|t+1>-x<rsub|t>|\<\|\|\>><rsup|2>,>>>>
    </eqnarray*>

    where the second inequality comes from the first order optimality condition for <math|x<rsub|t+1>> (see Proposition <reference|prop:firstorder>). Next observe that

    <\eqnarray*>
      <tformat|<table|<row|<cell|\<psi\><rsub|t><around|(|x<rsub|t+1>|)>-\<psi\><rsub|t><around|(|x<rsub|t>|)>>|<cell|=>|<cell|\<psi\><rsub|t-1><around|(|x<rsub|t+1>|)>-\<psi\><rsub|t-1><around|(|x<rsub|t>|)>+\<eta\>*g<rsub|t><rsup|\<top\>>*<around|(|x<rsub|t+1>-x<rsub|t>|)>>>|<row|<cell|>|<cell|\<geq\>>|<cell|\<eta\>*g<rsub|t><rsup|\<top\>>*<around|(|x<rsub|t+1>-x<rsub|t>|)>.>>>>
    </eqnarray*>

    Putting together the two above displays and using Cauchy-Schwarz (with the assumption <math|<around|\<\|\|\>|g<rsub|t>|\<\|\|\>><rsub|\<ast\>>\<leq\>L>) one obtains

    <\equation*>
      <frac|\<rho\>|2>*<around|\<\|\|\>|x<rsub|t+1>-x<rsub|t>|\<\|\|\>><rsup|2>\<leq\>\<eta\>*g<rsub|t><rsup|\<top\>>*<around|(|x<rsub|t>-x<rsub|t+1>|)>\<leq\>\<eta\>*L*<around|\<\|\|\>|x<rsub|t>-x<rsub|t+1>|\<\|\|\>>.
    </equation*>

    In particular this shows that <math|<around|\<\|\|\>|x<rsub|t+1>-x<rsub|t>|\<\|\|\>>\<leq\><frac|2*\<eta\>*L|\<rho\>>> and thus with the above display

    <\equation>
      <label|eq:DA1>g<rsub|t><rsup|\<top\>>*<around|(|x<rsub|t>-x<rsub|t+1>|)>\<leq\><frac|2*\<eta\>*L<rsup|2>|\<rho\>>.
    </equation>

    Now we claim that for any <math|x\<in\><cX>\<cap\><cD>>,

    <\equation>
      <label|eq:DA2><big|sum><rsub|s=1><rsup|t>g<rsub|s><rsup|\<top\>>*<around|(|x<rsub|s>-x|)>\<leq\><big|sum><rsub|s=1><rsup|t>g<rsub|s><rsup|\<top\>>*<around|(|x<rsub|s>-x<rsub|s+1>|)>+<frac|\<Phi\><around|(|x|)>-\<Phi\><around|(|x<rsub|1>|)>|\<eta\>>,
    </equation>

    which would clearly conclude the proof thanks to <eqref|eq:DA1> and straightforward computations. Equation <eqref|eq:DA2> is equivalent to

    <\equation*>
      <big|sum><rsub|s=1><rsup|t>g<rsub|s><rsup|\<top\>>*x<rsub|s+1>+<frac|\<Phi\><around|(|x<rsub|1>|)>|\<eta\>>\<leq\><big|sum><rsub|s=1><rsup|t>g<rsub|s><rsup|\<top\>>*x+<frac|\<Phi\><around|(|x|)>|\<eta\>>,
    </equation*>

    and we now prove the latter equation by induction. At <math|t=0> it is true since <math|x<rsub|1>\<in\><argmin><rsub|x\<in\><cX>\<cap\><cD>>\<Phi\><around|(|x|)>>. The following inequalities prove the inductive step, where we use the induction hypothesis at <math|x=x<rsub|t+1>> for the first inequality, and the definition of <math|x<rsub|t+1>> for the second inequality:

    <\equation*>
      <big|sum><rsub|s=1><rsup|t>g<rsub|s><rsup|\<top\>>*x<rsub|s+1>+<frac|\<Phi\><around|(|x<rsub|1>|)>|\<eta\>>\<leq\>g<rsub|t><rsup|\<top\>>*x<rsub|t+1>+<big|sum><rsub|s=1><rsup|t-1>g<rsub|s><rsup|\<top\>>*x<rsub|t+1>+<frac|\<Phi\><around|(|x<rsub|t+1>|)>|\<eta\>>\<leq\><big|sum><rsub|s=1><rsup|t>g<rsub|s><rsup|\<top\>>*x+<frac|\<Phi\><around|(|x|)>|\<eta\>>.
    </equation*>
  </proof>

  <section|Mirror prox>

  It can be shown that mirror descent accelerates for smooth functions to the rate <math|1/t>. We will prove this result in Chapter <reference|rand> (see Theorem <reference|th:SMDsmooth>). We describe here a variant of mirror descent which also attains the rate <math|1/t> for smooth functions. This method is called mirror prox and it was introduced in <cite|Nem04>. The true power of mirror prox will reveal itself later in the text when we deal with smooth representations of non-smooth functions as well as stochastic oracles<footnote|Basically mirror prox allows for a smooth vector field point of view (see Section <reference|sec:vectorfield>), while mirror descent does not.>.

  Mirror prox is described by the following equations:

  <\align*>
    <tformat|<table|<row|<cell|>|<cell|\<nabla\>*\<Phi\><around|(|y<rsub|t+1><rprime|'>|)>=\<nabla\>*\<Phi\><around|(|x<rsub|t>|)>-\<eta\>*\<nabla\>*f<around|(|x<rsub|t>|)>,>>|<row|<cell|>|<cell|>>|<row|<cell|>|<cell|y<rsub|t+1>\<in\><argmin><rsub|x\<in\>\<cal-X\>\<cap\>\<cal-D\>>D<rsub|\<Phi\>>*<around|(|x,y<rsub|t+1><rprime|'>|)>,>>|<row|<cell|>|<cell|>>|<row|<cell|>|<cell|\<nabla\>*\<Phi\><around|(|x<rsub|t+1><rprime|'>|)>=\<nabla\>*\<Phi\><around|(|x<rsub|t>|)>-\<eta\>*\<nabla\>*f<around|(|y<rsub|t+1>|)>,>>|<row|<cell|>|<cell|>>|<row|<cell|>|<cell|x<rsub|t+1>\<in\><argmin><rsub|x\<in\>\<cal-X\>\<cap\>\<cal-D\>>D<rsub|\<Phi\>>*<around|(|x,x<rsub|t+1><rprime|'>|)>.>>>>
  </align*>

  In words the algorithm first makes a step of mirror descent to go from <math|x<rsub|t>> to <math|y<rsub|t+1>>, and then it makes a similar step to obtain <math|x<rsub|t+1>>, starting again from <math|x<rsub|t>> but this time using the gradient of <math|f> evaluated at <math|y<rsub|t+1>> (instead of <math|x<rsub|t>>), see Figure <reference|fig:mp> for an illustration. The following result justifies the procedure.

  <big-figure|<tikzpicture|[scale=4] <clip>(-2.4,-0.7) rectangle (0.5,1); <draw*|rotate=30, very thick> (0,-0.5) ellipse (0.73 and 1); <draw*|very thick> (-2,0) ellipse (1 and 0.5); <node>(S) [very thick, regular polygon, regular polygon sides=6, draw, inner sep=22] at (0,0) ; <node>at (0.3,-0.6) <math|<cD>>; <node>at (-2.2,-0.4) <math|<R><rsup|n>>; <node>at (0.12, -0.22) <math|<cX>>; <node*|tokens=1> (noeudat) at (-0.1,0.15) [label=right:<math|x<rsub|t>>] ; <node*|tokens=1> (noeudat1) at (-0.15,-0.13) [label=right:<math|y<rsub|t+1>>] ; <node*|tokens=1> (noeudwt1) at (-0.4,-0.45) [label=below right:<math|y<rsub|t+1><rprime|'>>] ; <draw*|-\<gtr\>, thick> (noeudwt1) .. controls (-0.3, -0.45) and (-0.15, -0.2) .. (noeudat1) node[midway, below right] projection; <node*|tokens=1> (noeudat3) at (-0.2,0) [label=right:<math|x<rsub|t+1>>] ; <node*|tokens=1> (noeudwt3) at (-0.3,-0.2) [label=left:<math|x<rsub|t+1><rprime|'>>] ; <draw*|-\<gtr\>, thick> (noeudwt3) .. controls (-0.22, -0.12) and (-0.22, -0.1) .. (noeudat3) ; <node*|tokens=1> (noeudmat) at (-1.7,0.3) [label=right:<math|\<nabla\>*\<Phi\><around|(|x<rsub|t>|)>>] ; <node*|tokens=1> (noeudmwt1) at (-2,-0.2) [label=below right:<math|\<nabla\>*\<Phi\><around|(|y<rsub|t+1><rprime|'>|)>>] ; <node*|tokens=1> (noeudmwt2) at (-1.6,-0.1) [label=right:<math|\<nabla\>*\<Phi\><around|(|x<rsub|t+1><rprime|'>|)>>] ; <draw*|-\<gtr\>, thick> (noeudmat) -- (noeudmwt2) node[midway, right] <math|-\<eta\>*\<nabla\>*f<around|(|y<rsub|t+1>|)>>; <draw*|-\<gtr\>, thick, dashed> (noeudmat) -- (noeudmwt1) node[midway, left] <math|-\<eta\>*\<nabla\>*f<around|(|x<rsub|t>|)>>; <draw*|-\<gtr\>, semithick> (-0.4,0.5) .. controls (-0.7,0.6) and (-1, 0.6) .. (-1.3,0.5) node[midway, above] <math|\<nabla\>*\<Phi\>>; <draw*|-\<gtr\>, semithick> (-1.45,-0.5) .. controls (-1.15,-0.6) and (-0.85, -0.6) .. (-0.55,-0.5) node[midway, below] <math|<around|(|\<nabla\>*\<Phi\>|)><rsup|-1>>;><label|fig:mp>|Illustration of mirror prox.>

  <\theorem>
    Let <math|\<Phi\>> be a mirror map <math|\<rho\>>-strongly convex on <math|\<cal-X\>\<cap\>\<cal-D\>> w.r.t. <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>>>. Let <math|R<rsup|2>=sup<rsub|x\<in\>\<cal-X\>\<cap\>\<cal-D\>> \<Phi\><around|(|x|)>-\<Phi\><around|(|x<rsub|1>|)>>, and <math|f> be convex and <math|\<beta\>>-smooth w.r.t. <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>>>. Then mirror prox with <math|\<eta\>=<frac|\<rho\>|\<beta\>>> satisfies

    <\equation*>
      f*<around*|(|<frac|1|t>*<big|sum><rsub|s=1><rsup|t>y<rsub|s+1>|)>-f<around|(|x<rsup|\<ast\>>|)>\<leq\><frac|\<beta\>*R<rsup|2>|\<rho\>*t>.
    </equation*>
  </theorem>

  <\proof>
    Let <math|x\<in\>\<cal-X\>\<cap\>\<cal-D\>>. We write

    <\eqnarray*>
      <tformat|<table|<row|<cell|f<around|(|y<rsub|t+1>|)>-f<around|(|x|)>>|<cell|\<leq\>>|<cell|\<nabla\>*f<around|(|y<rsub|t+1>|)><rsup|\<top\>>*<around|(|y<rsub|t+1>-x|)>>>|<row|<cell|>|<cell|=>|<cell|\<nabla\>*f<around|(|y<rsub|t+1>|)><rsup|\<top\>>*<around|(|x<rsub|t+1>-x|)>+\<nabla\>*f<around|(|x<rsub|t>|)><rsup|\<top\>>*<around|(|y<rsub|t+1>-x<rsub|t+1>|)>>>|<row|<cell|>|<cell|>|<cell|+<around|(|\<nabla\>*f<around|(|y<rsub|t+1>|)>-\<nabla\>*f<around|(|x<rsub|t>|)>|)><rsup|\<top\>>*<around|(|y<rsub|t+1>-x<rsub|t+1>|)>.>>>>
    </eqnarray*>

    We will now bound separately these three terms. For the first one, using the definition of the method, Lemma <reference|lem:todonow2>, and equation <eqref|eq:useful1>, one gets

    <\align*>
      <tformat|<table|<row|<cell|>|<cell|\<eta\>*\<nabla\>*f<around|(|y<rsub|t+1>|)><rsup|\<top\>>*<around|(|x<rsub|t+1>-x|)>>>|<row|<cell|>|<cell|=<around|(|\<nabla\>*\<Phi\><around|(|x<rsub|t>|)>-\<nabla\>*\<Phi\><around|(|x<rsub|t+1><rprime|'>|)>|)><rsup|\<top\>>*<around|(|x<rsub|t+1>-x|)>>>|<row|<cell|>|<cell|\<leq\><around|(|\<nabla\>*\<Phi\><around|(|x<rsub|t>|)>-\<nabla\>*\<Phi\><around|(|x<rsub|t+1>|)>|)><rsup|\<top\>>*<around|(|x<rsub|t+1>-x|)>>>|<row|<cell|>|<cell|=D<rsub|\<Phi\>>*<around|(|x,x<rsub|t>|)>-D<rsub|\<Phi\>>*<around|(|x,x<rsub|t+1>|)>-D<rsub|\<Phi\>>*<around|(|x<rsub|t+1>,x<rsub|t>|)>.>>>>
    </align*>

    For the second term using the same properties than above and the strong-convexity of the mirror map one obtains

    <\align>
      <tformat|<table|<row|<cell|>|<cell|\<eta\>*\<nabla\>*f<around|(|x<rsub|t>|)><rsup|\<top\>>*<around|(|y<rsub|t+1>-x<rsub|t+1>|)><eq-number>>>|<row|<cell|>|<cell|=<around|(|\<nabla\>*\<Phi\><around|(|x<rsub|t>|)>-\<nabla\>*\<Phi\><around|(|y<rsub|t+1><rprime|'>|)>|)><rsup|\<top\>>*<around|(|y<rsub|t+1>-x<rsub|t+1>|)><eq-number>>>|<row|<cell|>|<cell|\<leq\><around|(|\<nabla\>*\<Phi\><around|(|x<rsub|t>|)>-\<nabla\>*\<Phi\><around|(|y<rsub|t+1>|)>|)><rsup|\<top\>>*<around|(|y<rsub|t+1>-x<rsub|t+1>|)><eq-number>>>|<row|<cell|>|<cell|=D<rsub|\<Phi\>>*<around|(|x<rsub|t+1>,x<rsub|t>|)>-D<rsub|\<Phi\>>*<around|(|x<rsub|t+1>,y<rsub|t+1>|)>-D<rsub|\<Phi\>>*<around|(|y<rsub|t+1>,x<rsub|t>|)><eq-number><label|eq:pourplustard1>>>|<row|<cell|>|<cell|\<leq\>D<rsub|\<Phi\>>*<around|(|x<rsub|t+1>,x<rsub|t>|)>-<frac|\<rho\>|2>*<around|\<\|\|\>|x<rsub|t+1>-y<rsub|t+1>*<around|\<\|\|\>|<rsup|2>-<frac|\<rho\>|2>|\<\|\|\>>*y<rsub|t+1>-x<rsub|t>|\<\|\|\>><rsup|2>.<eq-number>>>>>
    </align>

    Finally for the last term, using Cauchy-Schwarz, <math|\<beta\>>-smoothness, and <math|2*a*b\<leq\>a<rsup|2>+b<rsup|2>> one gets

    <\align*>
      <tformat|<table|<row|<cell|>|<cell|<around|(|\<nabla\>*f<around|(|y<rsub|t+1>|)>-\<nabla\>*f<around|(|x<rsub|t>|)>|)><rsup|\<top\>>*<around|(|y<rsub|t+1>-x<rsub|t+1>|)>>>|<row|<cell|>|<cell|\<leq\><around|\<\|\|\>|\<nabla\>*f<around|(|y<rsub|t+1>|)>-\<nabla\>*f<around|(|x<rsub|t>|)>|\<\|\|\>><rsub|\<ast\>>\<cdot\><around|\<\|\|\>|y<rsub|t+1>-x<rsub|t+1>|\<\|\|\>>>>|<row|<cell|>|<cell|\<leq\>\<beta\>*<around|\<\|\|\>|y<rsub|t+1>-x<rsub|t>|\<\|\|\>>\<cdot\><around|\<\|\|\>|y<rsub|t+1>-x<rsub|t+1>|\<\|\|\>>>>|<row|<cell|>|<cell|\<leq\><frac|\<beta\>|2>*<around|\<\|\|\>|y<rsub|t+1>-x<rsub|t>*<around|\<\|\|\>|<rsup|2>+<frac|\<beta\>|2>|\<\|\|\>>*y<rsub|t+1>-x<rsub|t+1>|\<\|\|\>><rsup|2>.>>>>
    </align*>

    Thus summing up these three terms and using that <math|\<eta\>=<frac|\<rho\>|\<beta\>>> one gets

    <\equation*>
      f<around|(|y<rsub|t+1>|)>-f<around|(|x|)>\<leq\><frac|D<rsub|\<Phi\>>*<around|(|x,x<rsub|t>|)>-D<rsub|\<Phi\>>*<around|(|x,x<rsub|t+1>|)>|\<eta\>>.
    </equation*>

    The proof is concluded with straightforward computations.
  </proof>

  <section|The vector field point of view on MD, DA, and MP><label|sec:vectorfield>

  In this section we consider a mirror map <math|\<Phi\>> that satisfies the assumptions from Theorem <reference|th:MD>.

  By inspecting the proof of Theorem <reference|th:MD> one can see that for arbitrary vectors <math|g<rsub|1>,\<ldots\>,g<rsub|t>\<in\><R><rsup|n>> the mirror descent strategy described by <eqref|eq:MD1> or <eqref|eq:MD2> (or alternatively by <eqref|eq:MDproxview>) satisfies for any <math|x\<in\><cX>\<cap\><cD>>,

  <\equation>
    <label|eq:vfMD><big|sum><rsub|s=1><rsup|t>g<rsub|s><rsup|\<top\>>*<around|(|x<rsub|s>-x|)>\<leq\><frac|R<rsup|2>|\<eta\>>+<frac|\<eta\>|2*\<rho\>>*<big|sum><rsub|s=1><rsup|t><around|\<\|\|\>|g<rsub|s>|\<\|\|\>><rsub|\<ast\>><rsup|2>.
  </equation>

  The observation that the sequence of vectors <math|<around|(|g<rsub|s>|)>> does not have to come from the subgradients of a <with|font-shape|italic|fixed> function <math|f> is the starting point for the theory of online learning, see <cite|Bub11> for more details. In this monograph we will use this observation to generalize mirror descent to saddle point calculations as well as stochastic settings. We note that we could also use dual averaging (defined by <eqref|eq:DA0>) which satisfies

  <\equation*>
    <big|sum><rsub|s=1><rsup|t>g<rsub|s><rsup|\<top\>>*<around|(|x<rsub|s>-x|)>\<leq\><frac|R<rsup|2>|\<eta\>>+<frac|2*\<eta\>|\<rho\>>*<big|sum><rsub|s=1><rsup|t><around|\<\|\|\>|g<rsub|s>|\<\|\|\>><rsub|\<ast\>><rsup|2>.
  </equation*>

  In order to generalize mirror prox we simply replace the gradient <math|\<nabla\>*f> by an arbitrary vector field <math|g:<cX>\<rightarrow\><R><rsup|n>> which yields the following equations:

  <\align*>
    <tformat|<table|<row|<cell|>|<cell|\<nabla\>*\<Phi\><around|(|y<rsub|t+1><rprime|'>|)>=\<nabla\>*\<Phi\><around|(|x<rsub|t>|)>-\<eta\>*g<around|(|x<rsub|t>|)>,>>|<row|<cell|>|<cell|y<rsub|t+1>\<in\><argmin><rsub|x\<in\>\<cal-X\>\<cap\>\<cal-D\>>D<rsub|\<Phi\>>*<around|(|x,y<rsub|t+1><rprime|'>|)>,>>|<row|<cell|>|<cell|\<nabla\>*\<Phi\><around|(|x<rsub|t+1><rprime|'>|)>=\<nabla\>*\<Phi\><around|(|x<rsub|t>|)>-\<eta\>*g<around|(|y<rsub|t+1>|)>,>>|<row|<cell|>|<cell|x<rsub|t+1>\<in\><argmin><rsub|x\<in\>\<cal-X\>\<cap\>\<cal-D\>>D<rsub|\<Phi\>>*<around|(|x,x<rsub|t+1><rprime|'>|)>.>>>>
  </align*>

  Under the assumption that the vector field is <math|\<beta\>>-Lipschitz w.r.t. <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>>>, i.e., <math|<around|\<\|\|\>|g<around|(|x|)>-g<around|(|y|)>|\<\|\|\>><rsub|\<ast\>>\<leq\>\<beta\>*<around|\<\|\|\>|x-y|\<\|\|\>>> one obtains with <math|\<eta\>=<frac|\<rho\>|\<beta\>>>

  <\equation>
    <label|eq:vfMP><big|sum><rsub|s=1><rsup|t>g<around|(|y<rsub|s+1>|)><rsup|\<top\>>*<around|(|y<rsub|s+1>-x|)>\<leq\><frac|\<beta\>*R<rsup|2>|\<rho\>>.
  </equation>

  <chapter|Beyond the black-box model><label|beyond>

  In the black-box model non-smoothness dramatically deteriorates the rate of convergence of first order methods from <math|1/t<rsup|2>> to <math|1/<sqrt|t>>. However, as we already pointed out in Section <reference|sec:structured>, we (almost) always know the function to be optimized <with|font-shape|italic|globally>. In particular the “source" of non-smoothness can often be identified. For instance the LASSO objective (see Section <reference|sec:mlapps>) is non-smooth, but it is a sum of a smooth part (the least squares fit) and a <with|font-shape|italic|simple> non-smooth part (the <math|\<ell\><rsub|1>>-norm). Using this specific structure we will propose in Section <reference|sec:simplenonsmooth> a first order method with a <math|1/t<rsup|2>> convergence rate, despite the non-smoothness. In Section <reference|sec:sprepresentation> we consider another type of non-smoothness that can effectively be overcome, where the function is the maximum of smooth functions. Finally we conclude this chapter with a concise description of interior point methods, for which the structural assumption is made on the constraint set rather than on the objective function.

  <section|Sum of a smooth and a simple non-smooth term><label|sec:simplenonsmooth>

  We consider here the following problem<footnote|We restrict to unconstrained minimization for sake of simplicity. One can extend the discussion to constrained minimization by using ideas from Section <reference|sec:gdsmooth>.>:

  <\equation*>
    min<rsub|x\<in\><R><rsup|n>> f<around|(|x|)>+g<around|(|x|)>,
  </equation*>

  where <math|f> is convex and <math|\<beta\>>-smooth, and <math|g> is convex. We assume that <math|f> can be accessed through a first order oracle, and that <math|g> is known and “simple". What we mean by simplicity will be clear from the description of the algorithm. For instance a separable function, that is <math|g<around|(|x|)>=<big|sum><rsub|i=1><rsup|n>g<rsub|i><around|(|x<around|(|i|)>|)>>, will be considered as simple. The prime example being <math|g<around|(|x|)>=<around|\<\|\|\>|x|\<\|\|\>><rsub|1>>. This section is inspired from <cite|BT09> (see also <cite|Nes07|WNF09>).

  <subsection*|ISTA (Iterative Shrinkage-Thresholding Algorithm)>

  Recall that gradient descent on the smooth function <math|f> can be written as (see <eqref|eq:MDproxview>)

  <\equation*>
    x<rsub|t+1>=<argmin><rsub|x\<in\>\<bbb-R\><rsup|n>>\<eta\>*\<nabla\>*f<around|(|x<rsub|t>|)><rsup|\<top\>>*x+<frac|1|2>*<around|\<\|\|\>|x-x<rsub|t>|\<\|\|\>><rsup|2><rsub|2>.
  </equation*>

  Here one wants to minimize <math|f+g>, and <math|g> is assumed to be known and “simple". Thus it seems quite natural to consider the following update rule, where only <math|f> is locally approximated with a first order oracle:

  <\eqnarray>
    <tformat|<table|<row|<cell|x<rsub|t+1>>|<cell|=>|<cell|<argmin><rsub|x\<in\>\<bbb-R\><rsup|n>>\<eta\>*<around|(|g<around|(|x|)>+\<nabla\>*f<around|(|x<rsub|t>|)><rsup|\<top\>>*x|)>+<frac|1|2>*<around|\<\|\|\>|x-x<rsub|t>|\<\|\|\>><rsup|2><rsub|2><eq-number>>>|<row|<cell|>|<cell|=>|<cell|<argmin><rsub|x\<in\>\<bbb-R\><rsup|n>>g<around|(|x|)>+<frac|1|2*\<eta\>>*<around|\<\|\|\>|x-<around|(|x<rsub|t>-\<eta\>*\<nabla\>*f<around|(|x<rsub|t>|)>|)>|\<\|\|\>><rsub|2><rsup|2>.<eq-number><label|eq:proxoperator>>>>>
  </eqnarray>

  The algorithm described by the above iteration is known as ISTA (Iterative Shrinkage-Thresholding Algorithm). In terms of convergence rate it is easy to show that ISTA has the same convergence rate on <math|f+g> as gradient descent on <math|f>. More precisely with <math|\<eta\>=<frac|1|\<beta\>>> one has

  <\equation*>
    f<around|(|x<rsub|t>|)>+g<around|(|x<rsub|t>|)>-<around|(|f<around|(|x<rsup|\<ast\>>|)>+g<around|(|x<rsup|\<ast\>>|)>|)>\<leq\><frac|\<beta\>*<around|\<\|\|\>|x<rsub|1>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2><rsub|2>|2*t>.
  </equation*>

  This improved convergence rate over a subgradient descent directly on <math|f+g> comes at a price: in general <eqref|eq:proxoperator> may be a difficult optimization problem by itself, and this is why one needs to assume that <math|g> is simple. For instance if <math|g> can be written as <math|g<around|(|x|)>=<big|sum><rsub|i=1><rsup|n>g<rsub|i><around|(|x<around|(|i|)>|)>> then one can compute <math|x<rsub|t+1>> by solving <math|n> convex problems in dimension <math|1>. In the case where <math|g<around|(|x|)>=\<lambda\><around|\<\|\|\>|x|\<\|\|\>><rsub|1>> this one-dimensional problem is given by:

  <\equation*>
    min<rsub|x\<in\>\<bbb-R\>> \<lambda\>\|x\|+<frac|1|2*\<eta\>>*<around|(|x-x<rsub|0>|)><rsup|2>,<text|where>x<rsub|0>\<in\>\<bbb-R\>.
  </equation*>

  Elementary computations shows that this problem has an analytical solution given by <math|\<tau\><rsub|\<lambda\>*\<eta\>><around|(|x<rsub|0>|)>>, where <math|\<tau\>> is the shrinkage operator (hence the name ISTA), defined by

  <\equation*>
    \<tau\><rsub|\<alpha\>><around|(|x|)>=<around|(|<around|\||x|\|>-\<alpha\>|)><rsub|+><math-up|sign><around|(|x|)>.
  </equation*>

  Much more is known about <eqref|eq:proxoperator> (which is called the <with|font-shape|italic|proximal operator> of <math|g>), and in fact entire monographs have been written about this equation, see e.g. <cite|PB13|BJMO12>.

  <subsection*|FISTA (Fast ISTA)>

  An obvious idea is to combine Nesterov's accelerated gradient descent (which results in a <math|1/t<rsup|2>> rate to optimize <math|f>) with ISTA. This results in FISTA (Fast ISTA) which is described as follows. Let

  <\equation*>
    \<lambda\><rsub|0>=0,\<lambda\><rsub|t>=<frac|1+<sqrt|1+4*\<lambda\><rsub|t-1><rsup|2>>|2>,<text|and>\<gamma\><rsub|t>=<frac|1-\<lambda\><rsub|t>|\<lambda\><rsub|t+1>>.
  </equation*>

  Let <math|x<rsub|1>=y<rsub|1>> an arbitrary initial point, and

  <\eqnarray*>
    <tformat|<table|<row|<cell|y<rsub|t+1>>|<cell|=>|<cell|<math-up|argmin><rsub|x\<in\>\<bbb-R\><rsup|n>>g<around|(|x|)>+<frac|\<beta\>|2>*<around|\<\|\|\>|x-<around|(|x<rsub|t>-<frac|1|\<beta\>>*\<nabla\>*f<around|(|x<rsub|t>|)>|)>|\<\|\|\>><rsub|2><rsup|2>,>>|<row|<cell|x<rsub|t+1>>|<cell|=>|<cell|<around|(|1-\<gamma\><rsub|t>|)>*y<rsub|t+1>+\<gamma\><rsub|t>*y<rsub|t>.>>>>
  </eqnarray*>

  Again it is easy show that the rate of convergence of FISTA on <math|f+g> is similar to the one of Nesterov's accelerated gradient descent on <math|f>, more precisely:

  <\equation*>
    f<around|(|y<rsub|t>|)>+g<around|(|y<rsub|t>|)>-<around|(|f<around|(|x<rsup|\<ast\>>|)>+g<around|(|x<rsup|\<ast\>>|)>|)>\<leq\><frac|2*\<beta\>*<around|\<\|\|\>|x<rsub|1>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>|t<rsup|2>>.
  </equation*>

  <subsection*|CMD and RDA>

  ISTA and FISTA assume smoothness in the Euclidean metric. Quite naturally one can also use these ideas in a non-Euclidean setting. Starting from <eqref|eq:MDproxview> one obtains the CMD (Composite Mirror Descent) algorithm of <cite|DSSST10>, while with <eqref|eq:DA0> one obtains the RDA (Regularized Dual Averaging) of <cite|Xia10>. We refer to these papers for more details.

  <section|Smooth saddle-point representation of a non-smooth function><label|sec:sprepresentation>

  Quite often the non-smoothness of a function <math|f> comes from a <math|max> operation. More precisely non-smooth functions can often be represented as

  <\equation>
    <label|eq:sprepresentation>f<around|(|x|)>=max<rsub|1\<leq\>i\<leq\>m> f<rsub|i><around|(|x|)>,
  </equation>

  where the functions <math|f<rsub|i>> are smooth. This was the case for instance with the function we used to prove the black-box lower bound <math|1/<sqrt|t>> for non-smooth optimization in Theorem <reference|th:lb1>. We will see now that by using this structural representation one can in fact attain a rate of <math|1/t>. This was first observed in <cite|Nes04b> who proposed the Nesterov's smoothing technique. Here we will present the alternative method of <cite|Nem04> which we find more transparent (yet another version is the Chambolle-Pock algorithm, see <cite|CP11>). Most of what is described in this section can be found in <cite|JN11a|JN11b>.

  In the next subsection we introduce the more general problem of saddle point computation. We then proceed to apply a modified version of mirror descent to this problem, which will be useful both in Chapter <reference|rand> and also as a warm-up for the more powerful modified mirror prox that we introduce next.

  <subsection|Saddle point computation><label|sec:sp>

  Let <math|<cX>\<subset\><R><rsup|n>>, <math|<cY>\<subset\><R><rsup|m>> be compact and convex sets. Let <math|\<phi\>:<cX>\<times\><cY>\<rightarrow\>\<bbb-R\>> be a continuous function, such that <math|\<phi\>*<around|(|\<cdummy\>,y|)>> is convex and <math|\<phi\>*<around|(|x,\<cdot\>|)>> is concave. We write <math|g<rsub|<cX>>*<around|(|x,y|)>> (respectively <math|g<rsub|<cY>>*<around|(|x,y|)>>) for an element of <math|\<partial\><rsub|x>*\<phi\>*<around|(|x,y|)>> (respectively <math|\<partial\><rsub|y>*<around|(|-\<phi\>*<around|(|x,y|)>|)>>). We are interested in computing

  <\equation*>
    min<rsub|x\<in\><cX>> max<rsub|y\<in\><cY>> \<phi\>*<around|(|x,y|)>.
  </equation*>

  By Sion's minimax theorem there exists a pair <math|<around|(|x<rsup|\<ast\>>,y<rsup|\<ast\>>|)>\<in\><cX>\<times\><cY>> such that

  <\equation*>
    \<phi\>*<around|(|x<rsup|\<ast\>>,y<rsup|\<ast\>>|)>=min<rsub|x\<in\>\<cal-X\>> max<rsub|y\<in\>\<cal-Y\>> \<phi\>*<around|(|x,y|)>=max<rsub|y\<in\>\<cal-Y\>> min<rsub|x\<in\>\<cal-X\>> \<phi\>*<around|(|x,y|)>.
  </equation*>

  We will explore algorithms that produce a candidate pair of solutions <math|<around|(|<tx>,<ty>|)>\<in\><cX>\<times\><cY>>. The quality of <math|<around|(|<tx>,<ty>|)>> is evaluated through the so-called duality gap<footnote|Observe that the duality gap is the sum of the primal gap <math|max<rsub|y\<in\>\<cal-Y\>> \<phi\>*<around|(|<tx>,y|)>-\<phi\>*<around|(|x<rsup|\<ast\>>,y<rsup|\<ast\>>|)>> and the dual gap <math|\<phi\>*<around|(|x<rsup|\<ast\>>,y<rsup|\<ast\>>|)>-min<rsub|x\<in\>\<cal-X\>> \<phi\>*<around|(|x,<ty>|)>>.>

  <\equation*>
    max<rsub|y\<in\>\<cal-Y\>> \<phi\>*<around|(|<tx>,y|)>-min<rsub|x\<in\>\<cal-X\>> \<phi\>*<around|(|x,<ty>|)>.
  </equation*>

  The key observation is that the duality gap can be controlled similarly to the suboptimality gap <math|f<around|(|x|)>-f<around|(|x<rsup|\<ast\>>|)>> in a simple convex optimization problem. Indeed for any <math|<around|(|x,y|)>\<in\><cX>\<times\><cY>>,

  <\equation*>
    \<phi\>*<around|(|<tx>,<ty>|)>-\<phi\>*<around|(|x,<ty>|)>\<leq\>g<rsub|<cX>>*<around|(|<tx>,<ty>|)><rsup|\<top\>>*<around|(|<tx>-x|)>,
  </equation*>

  and

  <\equation*>
    -\<phi\>*<around|(|<tx>,<ty>|)>-<around|(|-\<phi\>*<around|(|<tx>,y|)>|)>\<leq\>g<rsub|<cY>>*<around|(|<tx>,<ty>|)><rsup|\<top\>>*<around|(|<ty>-y|)>.
  </equation*>

  In particular, using the notation <math|z=<around|(|x,y|)>\<in\><cZ>\<assign\><cX>\<times\><cY>> and <math|g<around|(|z|)>=<around|(|g<rsub|<cX>>*<around|(|x,y|)>,g<rsub|<cY>>*<around|(|x,y|)>|)>> we just proved

  <\equation>
    <label|eq:keysp>max<rsub|y\<in\>\<cal-Y\>> \<phi\>*<around|(|<tx>,y|)>-min<rsub|x\<in\>\<cal-X\>> \<phi\>*<around|(|x,<ty>|)>\<leq\>g<around|(|<tz>|)><rsup|\<top\>>*<around|(|<tz>-z|)>,
  </equation>

  for some <math|z\<in\>\<cal-Z\>>. In view of the vector field point of view developed in Section <reference|sec:vectorfield> this suggests to do a mirror descent in the <math|<cZ>>-space with the vector field <math|g:<cZ>\<rightarrow\><R><rsup|n>\<times\><R><rsup|m>>.

  We will assume in the next subsections that <math|<cX>> is equipped with a mirror map <math|\<Phi\><rsub|<cX>>> (defined on <math|<cD><rsub|<cX>>>) which is <math|1>-strongly convex w.r.t. a norm <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>><rsub|<cX>>> on <math|<cX>\<cap\><cD><rsub|<cX>>>. We denote <math|R<rsup|2><rsub|<cX>>=sup<rsub|x\<in\><cX>> \<Phi\><around|(|x|)>-min<rsub|x\<in\><cX>> \<Phi\><around|(|x|)>>. We define similar quantities for the space <math|<cY>>.

  <subsection|Saddle Point Mirror Descent (SP-MD)><label|sec:spmd>

  We consider here mirror descent on the space <math|<cZ>=<cX>\<times\><cY>> with the mirror map <math|\<Phi\><around|(|z|)>=a*\<Phi\><rsub|<cX>><around|(|x|)>+b*\<Phi\><rsub|<cY>><around|(|y|)>> (defined on <math|<cD>=<cD><rsub|<cX>>\<times\><cD><rsub|<cY>>>), where <math|a,b\<in\><R><rsub|+>> are to be defined later, and with the vector field <math|g:<cZ>\<rightarrow\><R><rsup|n>\<times\><R><rsup|m>> defined in the previous subsection. We call the resulting algorithm SP-MD (Saddle Point Mirror Descent). It can be described succintly as follows.

  Let <math|z<rsub|1>\<in\><argmin><rsub|z\<in\><cZ>\<cap\><cD>>\<Phi\><around|(|z|)>>. Then for <math|t\<geq\>1>, let

  <\equation*>
    z<rsub|t+1>\<in\><argmin><rsub|z\<in\><cZ>\<cap\><cD>>\<eta\>*g<rsub|t><rsup|\<top\>>*z+D<rsub|\<Phi\>>*<around|(|z,z<rsub|t>|)>,
  </equation*>

  where <math|g<rsub|t>=<around|(|g<rsub|<cX>,t>,g<rsub|<cY>,t>|)>> with <math|g<rsub|<cX>,t>\<in\>\<partial\><rsub|x>*\<phi\>*<around|(|x<rsub|t>,y<rsub|t>|)>> and <math|g<rsub|<cY>,t>\<in\>\<partial\><rsub|y>*<around|(|-\<phi\>*<around|(|x<rsub|t>,y<rsub|t>|)>|)>>.

  <\theorem>
    <label|th:spmd>Assume that <math|\<phi\>*<around|(|\<cdummy\>,y|)>> is <math|L<rsub|<cX>>>-Lipschitz w.r.t. <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>><rsub|<cX>>>, that is <math|<around|\<\|\|\>|g<rsub|<cX>>*<around|(|x,y|)>|\<\|\|\>><rsub|<cX>><rsup|\<ast\>>\<leq\>L<rsub|<cX>>,\<forall\><around|(|x,y|)>\<in\><cX>\<times\><cY>>. Similarly assume that <math|\<phi\>*<around|(|x,\<cdot\>|)>> is <math|L<rsub|<cY>>>-Lipschitz w.r.t. <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>><rsub|<cY>>>. Then SP-MD with <math|a=<frac|L<rsub|<cX>>|R<rsub|<cX>>>>, <math|b=<frac|L<rsub|<cY>>|R<rsub|<cY>>>>, and <math|\<eta\>=<sqrt|<frac|2|t>>> satisfies

    <\equation*>
      max<rsub|y\<in\>\<cal-Y\>> \<phi\>*<around*|(|<frac|1|t>*<big|sum><rsub|s=1><rsup|t>x<rsub|s>,y|)>-min<rsub|x\<in\>\<cal-X\>> \<phi\>*<around*|(|x,<frac|1|t>*<big|sum><rsub|s=1><rsup|t>y<rsub|s>|)>\<leq\><around|(|R<rsub|<cX>>*L<rsub|<cX>>+R<rsub|<cY>>*L<rsub|<cY>>|)>*<sqrt|<frac|2|t>>.
    </equation*>
  </theorem>

  <\proof>
    First we endow <math|\<cal-Z\>> with the norm <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>><rsub|<cZ>>> defined by

    <\equation*>
      <around|\<\|\|\>|z|\<\|\|\>><rsub|<cZ>>=<sqrt|a\<\|\|\>x\<\|\|\><rsub|\<cal-X\>><rsup|2>+b<around|\<\|\|\>|y|\<\|\|\>><rsub|\<cal-Y\>><rsup|2>>.
    </equation*>

    It is immediate that <math|\<Phi\>> is <math|1>-strongly convex with respect to <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>><rsub|\<cal-Z\>>> on <math|\<cal-Z\>\<cap\>\<cal-D\>>. Furthermore one can easily check that

    <\equation*>
      <around|\<\|\|\>|z|\<\|\|\>><rsub|\<cal-Z\>><rsup|\<ast\>>=<sqrt|<frac|1|a><around*|(|<around|\<\|\|\>|x|\<\|\|\>><rsub|\<cal-X\>><rsup|\<ast\>>|)><rsup|2>+<frac|1|b><around*|(|<around|\<\|\|\>|y|\<\|\|\>><rsub|\<cal-Y\>><rsup|\<ast\>>|)><rsup|2>>,
    </equation*>

    and thus the vector field <math|<around|(|g<rsub|t>|)>> used in the SP-MD satisfies:

    <\equation*>
      <around|\<\|\|\>|g<rsub|t>|\<\|\|\>><rsub|\<cal-Z\>><rsup|\<ast\>>\<leq\><sqrt|<frac|L<rsub|\<cal-X\>><rsup|2>|a>+<frac|L<rsub|\<cal-Y\>><rsup|2>|b>>.
    </equation*>

    Using <eqref|eq:vfMD> together with <eqref|eq:keysp> and the values of <math|a,b> and <math|\<eta\>> concludes the proof.
  </proof>

  <subsection|Saddle Point Mirror Prox (SP-MP)>

  We now consider the most interesting situation in the context of this chapter, where the function <math|\<phi\>> is smooth. Precisely we say that <math|\<phi\>> is <math|<around|(|\<beta\><rsub|11>,\<beta\><rsub|12>,\<beta\><rsub|22>,\<beta\><rsub|21>|)>>-smooth if for any <math|x,x<rprime|'>\<in\><cX>,y,y<rprime|'>\<in\><cY>>,

  <\align*>
    <tformat|<table|<row|<cell|>|<cell|<around|\<\|\|\>|\<nabla\><rsub|x>*\<phi\>*<around|(|x,y|)>-\<nabla\><rsub|x>*\<phi\>*<around|(|x<rprime|'>,y|)>|\<\|\|\>><rsub|\<cal-X\>><rsup|\<ast\>>\<leq\>\<beta\><rsub|11>*<around|\<\|\|\>|x-x<rprime|'>|\<\|\|\>><rsub|\<cal-X\>>,>>|<row|<cell|>|<cell|<around|\<\|\|\>|\<nabla\><rsub|x>*\<phi\>*<around|(|x,y|)>-\<nabla\><rsub|x>*\<phi\>*<around|(|x,y<rprime|'>|)>|\<\|\|\>><rsub|\<cal-X\>><rsup|\<ast\>>\<leq\>\<beta\><rsub|12>*<around|\<\|\|\>|y-y<rprime|'>|\<\|\|\>><rsub|\<cal-Y\>>,>>|<row|<cell|>|<cell|<around|\<\|\|\>|\<nabla\><rsub|y>*\<phi\>*<around|(|x,y|)>-\<nabla\><rsub|y>*\<phi\>*<around|(|x,y<rprime|'>|)>|\<\|\|\>><rsub|\<cal-Y\>><rsup|\<ast\>>\<leq\>\<beta\><rsub|22>*<around|\<\|\|\>|y-y<rprime|'>|\<\|\|\>><rsub|\<cal-Y\>>,>>|<row|<cell|>|<cell|<around|\<\|\|\>|\<nabla\><rsub|y>*\<phi\>*<around|(|x,y|)>-\<nabla\><rsub|y>*\<phi\>*<around|(|x<rprime|'>,y|)>|\<\|\|\>><rsub|\<cal-Y\>><rsup|\<ast\>>\<leq\>\<beta\><rsub|21>*<around|\<\|\|\>|x-x<rprime|'>|\<\|\|\>><rsub|\<cal-X\>>,>>>>
  </align*>

  This will imply the Lipschitzness of the vector field <math|g:<cZ>\<rightarrow\><R><rsup|n>\<times\><R><rsup|m>> under the appropriate norm. Thus we use here mirror prox on the space <math|<cZ>> with the mirror map <math|\<Phi\><around|(|z|)>=a*\<Phi\><rsub|<cX>><around|(|x|)>+b*\<Phi\><rsub|<cY>><around|(|y|)>> and the vector field <math|g>. The resulting algorithm is called SP-MP (Saddle Point Mirror Prox) and we can describe it succintly as follows.

  Let <math|z<rsub|1>\<in\><argmin><rsub|z\<in\><cZ>\<cap\><cD>>\<Phi\><around|(|z|)>>. Then for <math|t\<geq\>1>, let <math|z<rsub|t>=<around|(|x<rsub|t>,y<rsub|t>|)>> and <math|w<rsub|t>=<around|(|u<rsub|t>,v<rsub|t>|)>> be defined by

  <\eqnarray*>
    <tformat|<table|<row|<cell|w<rsub|t+1>>|<cell|=>|<cell|<argmin><rsub|z\<in\><cZ>\<cap\><cD>>\<eta\>*<around|(|\<nabla\><rsub|x>*\<phi\>*<around|(|x<rsub|t>,y<rsub|t>|)>,-\<nabla\><rsub|y>*\<phi\>*<around|(|x<rsub|t>,y<rsub|t>|)>|)><rsup|\<top\>>*z+D<rsub|\<Phi\>>*<around|(|z,z<rsub|t>|)>>>|<row|<cell|z<rsub|t+1>>|<cell|=>|<cell|<argmin><rsub|z\<in\><cZ>\<cap\><cD>>\<eta\>*<around|(|\<nabla\><rsub|x>*\<phi\>*<around|(|u<rsub|t+1>,v<rsub|t+1>|)>,-\<nabla\><rsub|y>*\<phi\>*<around|(|u<rsub|t+1>,v<rsub|t+1>|)>|)><rsup|\<top\>>*z+D<rsub|\<Phi\>>*<around|(|z,z<rsub|t>|)>.>>>>
  </eqnarray*>

  <\theorem>
    <label|th:spmp>Assume that <math|\<phi\>> is <math|<around|(|\<beta\><rsub|11>,\<beta\><rsub|12>,\<beta\><rsub|22>,\<beta\><rsub|21>|)>>-smooth. Then SP-MP with <math|a=<frac|1|R<rsub|<cX>><rsup|2>>>, <math|b=<frac|1|R<rsub|<cY>><rsup|2>>>, and <math|\<eta\>=1/<around*|(|2*max <around*|(|\<beta\><rsub|11>*R<rsup|2><rsub|<cX>>,\<beta\><rsub|22>*R<rsup|2><rsub|<cY>>,\<beta\><rsub|12>*R<rsub|<cX>>*R<rsub|<cY>>,\<beta\><rsub|21>*R<rsub|<cX>>*R<rsub|<cY>>|)>|)>> satisfies

    <\align*>
      <tformat|<table|<row|<cell|>|<cell|max<rsub|y\<in\>\<cal-Y\>> \<phi\>*<around*|(|<frac|1|t>*<big|sum><rsub|s=1><rsup|t>u<rsub|s+1>,y|)>-min<rsub|x\<in\>\<cal-X\>> \<phi\>*<around*|(|x,<frac|1|t>*<big|sum><rsub|s=1><rsup|t>v<rsub|s+1>|)>>>|<row|<cell|>|<cell|\<leq\>max <around*|(|\<beta\><rsub|11>*R<rsup|2><rsub|<cX>>,\<beta\><rsub|22>*R<rsup|2><rsub|<cY>>,\<beta\><rsub|12>*R<rsub|<cX>>*R<rsub|<cY>>,\<beta\><rsub|21>*R<rsub|<cX>>*R<rsub|<cY>>|)><frac|4|t>.>>>>
    </align*>
  </theorem>

  <\proof>
    In light of the proof of Theorem <reference|th:spmd> and <eqref|eq:vfMP> it clearly suffices to show that the vector field <math|g<around|(|z|)>=<around|(|\<nabla\><rsub|x>*\<phi\>*<around|(|x,y|)>,-\<nabla\><rsub|y>*\<phi\><rsub|(>*x,y|)>)> is <math|\<beta\>>-Lipschitz w.r.t. <math|<around|\<\|\|\>|z|\<\|\|\>><rsub|<cZ>>=<sqrt|<frac|1|R<rsub|<cX>><rsup|2>>\<\|\|\>x\<\|\|\><rsub|\<cal-X\>><rsup|2>+<frac|1|R<rsub|<cY>><rsup|2>><around|\<\|\|\>|y|\<\|\|\>><rsub|\<cal-Y\>><rsup|2>>> with <math|\<beta\>=2*max <around*|(|\<beta\><rsub|11>*R<rsup|2><rsub|<cX>>,\<beta\><rsub|22>*R<rsup|2><rsub|<cY>>,\<beta\><rsub|12>*R<rsub|<cX>>*R<rsub|<cY>>,\<beta\><rsub|21>*R<rsub|<cX>>*R<rsub|<cY>>|)>>. In other words one needs to show that

    <\equation*>
      <around|\<\|\|\>|g<around|(|z|)>-g<around|(|z<rprime|'>|)>|\<\|\|\>><rsub|<cZ>><rsup|\<ast\>>\<leq\>\<beta\>*<around|\<\|\|\>|z-z<rprime|'>|\<\|\|\>><rsub|<cZ>>,
    </equation*>

    which can be done with straightforward calculations (by introducing <math|g*<around|(|x<rprime|'>,y|)>> and using the definition of smoothness for <math|\<phi\>>).
  </proof>

  <subsection|Applications><label|sec:spex>

  We investigate briefly three applications for SP-MD and SP-MP.

  <subsubsection|Minimizing a maximum of smooth functions><label|sec:spex1>

  The problem <eqref|eq:sprepresentation> (when <math|f> has to minimized over <math|<cX>>) can be rewritten as

  <\equation*>
    min<rsub|x\<in\><cX>> max<rsub|y\<in\>\<Delta\><rsub|m>> <wide|f|\<vect\>><around|(|x|)><rsup|\<top\>>*y,
  </equation*>

  where <math|<wide|f|\<vect\>><around|(|x|)>=<around|(|f<rsub|1><around|(|x|)>,\<ldots\>,f<rsub|m><around|(|x|)>|)>\<in\><R><rsup|m>>. We assume that the functions <math|f<rsub|i>> are <math|L>-Lipschtiz and <math|\<beta\>>-smooth w.r.t. some norm <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>><rsub|<cX>>>. Let us study the smoothness of <math|\<phi\>*<around|(|x,y|)>=<wide|f|\<vect\>><around|(|x|)><rsup|\<top\>>*y> when <math|<cX>> is equipped with <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>><rsub|<cX>>> and <math|\<Delta\><rsub|m>> is equipped with <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>><rsub|1>>. On the one hand <math|\<nabla\><rsub|y>*\<phi\>*<around|(|x,y|)>=<wide|f|\<vect\>><around|(|x|)>>, in particular one immediately has <math|\<beta\><rsub|22>=0>, and furthermore

  <\equation*>
    <around|\<\|\|\>|<wide|f|\<vect\>><around|(|x|)>-<wide|f|\<vect\>><around|(|x<rprime|'>|)>|\<\|\|\>><rsub|\<infty\>>\<leq\>L*<around|\<\|\|\>|x-x<rprime|'>|\<\|\|\>><rsub|\<cal-X\>>,
  </equation*>

  that is <math|\<beta\><rsub|21>=L>. On the other hand <math|\<nabla\><rsub|x>*\<phi\>*<around|(|x,y|)>=<big|sum><rsub|i=1><rsup|m>y<rsub|i>*\<nabla\>*f<rsub|i><around|(|x|)>>, and thus

  <\align*>
    <tformat|<table|<row|<cell|>|<cell|<around|\<\|\|\>|<big|sum><rsub|i=1><rsup|m>y<around|(|i|)>*<around|(|\<nabla\>*f<rsub|i><around|(|x|)>-\<nabla\>*f<rsub|i><around|(|x<rprime|'>|)>|)>|\<\|\|\>><rsub|<cX>><rsup|\<ast\>>\<leq\>\<beta\>*<around|\<\|\|\>|x-x<rprime|'>|\<\|\|\>><rsub|<cX>>,>>|<row|<cell|>|<cell|<around|\<\|\|\>|<big|sum><rsub|i=1><rsup|m><around|(|y<around|(|i|)>-y<rprime|'><around|(|i|)>|)>*\<nabla\>*f<rsub|i><around|(|x|)>|\<\|\|\>><rsub|<cX>><rsup|\<ast\>>\<leq\>L*<around|\<\|\|\>|y-y<rprime|'>|\<\|\|\>><rsub|1>,>>>>
  </align*>

  that is <math|\<beta\><rsub|11>=\<beta\>> and <math|\<beta\><rsub|12>=L>. Thus using SP-MP with some mirror map on <math|<cX>> and the negentropy on <math|\<Delta\><rsub|m>> (see the “simplex setup" in Section <reference|sec:mdsetups>), one obtains an <math|\<epsilon\>>-optimal point of <math|f<around|(|x|)>=max<rsub|1\<leq\>i\<leq\>m> f<rsub|i><around|(|x|)>> in <math|O<around*|(|<frac|\<beta\>*R<rsub|<cX>><rsup|2>+L*R<rsub|<cX>>*<sqrt|log <around|(|m|)>>|\<epsilon\>>|)>> iterations. Furthermore an iteration of SP-MP has a computational complexity of order of a step of mirror descent in <math|<cX>> on the function <math|x\<mapsto\><big|sum><rsub|i=1><rsup|m>y<around|(|i|)>*f<rsub|i><around|(|x|)>> (plus <math|O<around|(|m|)>> for the update in the <math|<cY>>-space).

  Thus by using the structure of <math|f> we were able to obtain a much better rate than black-box procedures (which would have required <math|\<Omega\>*<around|(|1/\<epsilon\><rsup|2>|)>> iterations as <math|f> is potentially non-smooth).

  <subsubsection|Matrix games><label|sec:spex2>

  Let <math|A\<in\><R><rsup|n\<times\>m>>, we denote <math|<around|\<\|\|\>|A|\<\|\|\>><rsub|<math-up|max>>> for the maximal entry (in absolute value) of <math|A>, and <math|A<rsub|i>\<in\><R><rsup|n>> for the <math|i<rsup|t*h>> column of <math|A>. We consider the problem of computing a Nash equilibrium for the zero-sum game corresponding to the loss matrix <math|A>, that is we want to solve

  <\equation*>
    min<rsub|x\<in\>\<Delta\><rsub|n>> max<rsub|y\<in\>\<Delta\><rsub|m>> x<rsup|\<top\>>*A*y.
  </equation*>

  Here we equip both <math|\<Delta\><rsub|n>> and <math|\<Delta\><rsub|m>> with <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>><rsub|1>>. Let <math|\<phi\>*<around|(|x,y|)>=x<rsup|\<top\>>*A*y>. Using that <math|\<nabla\><rsub|x>*\<phi\>*<around|(|x,y|)>=A*y> and <math|\<nabla\><rsub|y>*\<phi\>*<around|(|x,y|)>=A<rsup|\<top\>>*x> one immediately obtains <math|\<beta\><rsub|11>=\<beta\><rsub|22>=0>. Furthermore since

  <\equation*>
    <around|\<\|\|\>|A*<around|(|y-y<rprime|'>|)>|\<\|\|\>><rsub|\<infty\>>=<around|\<\|\|\>|<big|sum><rsub|i=1><rsup|m><around|(|y<around|(|i|)>-y<rprime|'><around|(|i|)>|)>*A<rsub|i>|\<\|\|\>><rsub|\<infty\>>\<leq\><around|\<\|\|\>|A|\<\|\|\>><rsub|<math-up|max>>*<around|\<\|\|\>|y-y<rprime|'>|\<\|\|\>><rsub|1>,
  </equation*>

  one also has <math|\<beta\><rsub|12>=\<beta\><rsub|21>=<around|\<\|\|\>|A|\<\|\|\>><rsub|<math-up|max>>>. Thus SP-MP with the negentropy on both <math|\<Delta\><rsub|n>> and <math|\<Delta\><rsub|m>> attains an <math|\<epsilon\>>-optimal pair of mixed strategies with <math|O<around*|(|<around|\<\|\|\>|A|\<\|\|\>><rsub|<math-up|max>><sqrt|log <around|(|n|)>*log <around|(|m|)>>/\<epsilon\>|)>> iterations. Furthermore the computational complexity of a step of SP-MP is dominated by the matrix-vector multiplications which are <math|O<around|(|n*m|)>>. Thus overall the complexity of getting an <math|\<epsilon\>>-optimal Nash equilibrium with SP-MP is <math|O<around*|(|<around|\<\|\|\>|A|\<\|\|\>><rsub|<math-up|max>>*n*m*<sqrt|log <around|(|n|)>*log <around|(|m|)>>/\<epsilon\>|)>>.

  <subsubsection|Linear classification><label|sec:spex3>

  Let <math|<around|(|\<ell\><rsub|i>,A<rsub|i>|)>\<in\><around|{|-1,1|}>\<times\><R><rsup|n>>, <math|i\<in\><around|[|m|]>>, be a data set that one wishes to separate with a linear classifier. That is one is looking for <math|x\<in\><mB><rsub|2,n>> such that for all <math|i\<in\><around|[|m|]>>, <math|<math-up|sign><around|(|x<rsup|\<top\>>*A<rsub|i>|)>=<math-up|sign><around|(|\<ell\><rsub|i>|)>>, or equivalently <math|\<ell\><rsub|i>*x<rsup|\<top\>>*A<rsub|i>\<gtr\>0>. Clearly without loss of generality one can assume <math|\<ell\><rsub|i>=1> for all <math|i\<in\><around|[|m|]>> (simply replace <math|A<rsub|i>> by <math|\<ell\><rsub|i>*A<rsub|i>>). Let <math|A\<in\><R><rsup|n\<times\>m>> be the matrix where the <math|i<rsup|t*h>> column is <math|A<rsub|i>>. The problem of finding <math|x> with maximal margin can be written as

  <\equation>
    <label|eq:linearclassif>max<rsub|x\<in\><mB><rsub|2,n>> min<rsub|1\<leq\>i\<leq\>m> A<rsub|i><rsup|\<top\>>*x=max<rsub|x\<in\><mB><rsub|2,n>> min<rsub|y\<in\>\<Delta\><rsub|m>> x<rsup|\<top\>>*A*y.
  </equation>

  Assuming that <math|<around|\<\|\|\>|A<rsub|i>|\<\|\|\>><rsub|2>\<leq\>B>, and using the calculations we did in Section <reference|sec:spex1>, it is clear that <math|\<phi\>*<around|(|x,y|)>=x<rsup|\<top\>>*A*y> is <math|<around|(|0,B,0,B|)>>-smooth with respect to <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>><rsub|2>> on <math|<mB><rsub|2,n>> and <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>><rsub|1>> on <math|\<Delta\><rsub|m>>. This implies in particular that SP-MP with the Euclidean norm squared on <math|<mB><rsub|2,n>> and the negentropy on <math|\<Delta\><rsub|m>> will solve <eqref|eq:linearclassif> in <math|O<around|(|B*<sqrt|log <around|(|m|)>>/\<epsilon\>|)>> iterations. Again the cost of an iteration is dominated by the matrix-vector multiplications, which results in an overall complexity of <math|O<around|(|B*n*m*<sqrt|log <around|(|m|)>>/\<epsilon\>|)>> to find an <math|\<epsilon\>>-optimal solution to <eqref|eq:linearclassif>.

  <section|Interior point methods><label|sec:IPM>

  We describe here interior point methods (IPM), a class of algorithms fundamentally different from what we have seen so far. The first algorithm of this type was described in <cite|Kar84>, but the theory we shall present was developed in <cite|NN94>. We follow closely the presentation given in [Chapter 4, <cite|Nes04>]. Other useful references (in particular for the primal-dual IPM, which are the ones used in practice) include <cite|Ren01|Nem04b|NW06>.

  IPM are designed to solve convex optimization problems of the form

  <\align*>
    <tformat|<table|<row|<cell|>|<cell|<with|math-font-family|rm|min.>*<space|0.27em>c<rsup|\<top\>>*x>>|<row|<cell|>|<cell|<text|s.t.><space|0.27em>x\<in\><cX>,>>>>
  </align*>

  with <math|c\<in\><R><rsup|n>>, and <math|<cX>\<subset\><R><rsup|n>> convex and compact. Note that, at this point, the linearity of the objective is without loss of generality as minimizing a convex function <math|f> over <math|<cX>> is equivalent to minimizing a linear objective over the epigraph of <math|f> (which is also a convex set). The structural assumption on <math|<cX>> that one makes in IPM is that there exists a <with|font-shape|italic|self-concordant barrier> for <math|<cX>> with an easily computable gradient and Hessian. The meaning of the previous sentence will be made precise in the next subsections. The importance of IPM stems from the fact that LPs and SDPs (see Section <reference|sec:structured>) satisfy this structural assumption.

  <subsection|The barrier method><label|sec:barriermethod>

  We say that <math|F:<inte><around|(|<cX>|)>\<rightarrow\><R>> is a <with|font-shape|italic|barrier> for <math|<cX>> if

  <\equation*>
    F<around|(|x|)><long-arrow|\<rubber-rightarrow\>|x\<to\>\<partial\><cX>|>+\<infty\>.
  </equation*>

  We will only consider strictly convex barriers. We extend the domain of definition of <math|F> to <math|<R><rsup|n>> with <math|F<around|(|x|)>=+\<infty\>> for <math|x\<nin\><inte><around|(|<cX>|)>>. For <math|t\<in\><R><rsub|+>> let

  <\equation*>
    x<rsup|\<ast\>><around|(|t|)>\<in\><argmin><rsub|x\<in\><R><rsup|n>>t*c<rsup|\<top\>>*x+F<around|(|x|)>.
  </equation*>

  In the following we denote <math|F<rsub|t><around|(|x|)>\<assign\>t*c<rsup|\<top\>>*x+F<around|(|x|)>>. In IPM the path <math|<around|(|x<rsup|\<ast\>><around|(|t|)>|)><rsub|t\<in\><R><rsub|+>>> is referred to as the <with|font-shape|italic|central path>. It seems clear that the central path eventually leads to the minimum <math|x<rsup|\<ast\>>> of the objective function <math|c<rsup|\<top\>>*x> on <math|<cX>>, precisely we will have

  <\equation*>
    x<rsup|\<ast\>><around|(|t|)><long-arrow|\<rubber-rightarrow\>|t\<to\>+\<infty\>|>x<rsup|\<ast\>>.
  </equation*>

  The idea of the <with|font-shape|italic|barrier method> is to move along the central path by “boosting" a fast locally convergent algorithm, which we denote for the moment by <math|<cA>>, using the following scheme: Assume that one has computed <math|x<rsup|\<ast\>><around|(|t|)>>, then one uses <math|<cA>> initialized at <math|x<rsup|\<ast\>><around|(|t|)>> to compute <math|x<rsup|\<ast\>><around|(|t<rprime|'>|)>> for some <math|t<rprime|'>\<gtr\>t>. There is a clear tension for the choice of <math|t<rprime|'>>, on the one hand <math|t<rprime|'>> should be large in order to make as much progress as possible on the central path, but on the other hand <math|x<rsup|\<ast\>><around|(|t|)>> needs to be close enough to <math|x<rsup|\<ast\>><around|(|t<rprime|'>|)>> so that it is in the basin of fast convergence for <math|<cA>> when run on <math|F<rsub|t<rprime|'>>>.

  IPM follows the above methodology with <math|<cA>> being <with|font-shape|italic|Newton's method>. Indeed as we will see in the next subsection, Newton's method has a quadratic convergence rate, in the sense that if initialized close enough to the optimum it attains an <math|\<epsilon\>>-optimal point in <math|log log <around|(|1/\<epsilon\>|)>> iterations! Thus we now have a clear plan to make these ideas formal and analyze the iteration complexity of IPM:

  <\enumerate>
    <item>First we need to describe precisely the region of fast convergence for Newton's method. This will lead us to define self-concordant functions, which are “natural" functions for Newton's method.

    <item>Then we need to evaluate precisely how much larger <math|t<rprime|'>> can be compared to <math|t>, so that <math|x<rsup|\<ast\>><around|(|t|)>> is still in the region of fast convergence of Newton's method when optimizing the function <math|F<rsub|t<rprime|'>>> with <math|t<rprime|'>\<gtr\>t>. This will lead us to define <math|\<nu\>>-self concordant barriers.

    <item>How do we get close to the central path in the first place? Is it possible to compute <math|x<rsup|\<ast\>><around|(|0|)>=<argmin><rsub|x\<in\><R><rsup|n>>F<around|(|x|)>> (the so-called analytical center of <math|\<cal-X\>>)?
  </enumerate>

  <subsection|Traditional analysis of Newton's method><label|sec:tradanalysisNM>

  We start by describing Newton's method together with its standard analysis showing the quadratic convergence rate when initialized close enough to the optimum. In this subsection we denote <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>>> for both the Euclidean norm on <math|<R><rsup|n>> and the operator norm on matrices (in particular <math|<around|\<\|\|\>|A*x|\<\|\|\>>\<leq\><around|\<\|\|\>|A|\<\|\|\>>\<cdot\><around|\<\|\|\>|x|\<\|\|\>>>).

  Let <math|f:<R><rsup|n>\<rightarrow\><R>> be a <math|C<rsup|2>> function. Using a Taylor's expansion of <math|f> around <math|x> one obtains

  <\equation*>
    f*<around|(|x+h|)>=f<around|(|x|)>+h<rsup|\<top\>>*\<nabla\>*f<around|(|x|)>+<frac|1|2>*h<rsup|\<top\>>*\<nabla\><rsup|2>*f<around|(|x|)>*h+o<around|(|<around|\<\|\|\>|h|\<\|\|\>><rsup|2>|)>.
  </equation*>

  Thus, starting at <math|x>, in order to minimize <math|f> it seems natural to move in the direction <math|h> that minimizes

  <\equation*>
    h<rsup|\<top\>>*\<nabla\>*f<around|(|x|)>+<frac|1|2>*h<rsup|\<top\>>*\<nabla\>*f<rsup|2><around|(|x|)>*h.
  </equation*>

  If <math|\<nabla\><rsup|2>*f<around|(|x|)>> is positive definite then the solution to this problem is given by <math|h=-<around|[|\<nabla\><rsup|2>*f<around|(|x|)>|]><rsup|-1>*\<nabla\>*f<around|(|x|)>>. Newton's method simply iterates this idea: starting at some point <math|x<rsub|0>\<in\><R><rsup|n>>, it iterates for <math|k\<geq\>0> the following equation:

  <\equation*>
    x<rsub|k+1>=x<rsub|k>-<around|[|\<nabla\><rsup|2>*f<around|(|x<rsub|k>|)>|]><rsup|-1>*\<nabla\>*f<around|(|x<rsub|k>|)>.
  </equation*>

  While this method can have an arbitrarily bad behavior in general, if started close enough to a strict local minimum of <math|f>, it can have a very fast convergence:

  <\theorem>
    <label|th:NM>Assume that <math|f> has a Lipschitz Hessian, that is <math|<around|\<\|\|\>|\<nabla\><rsup|2>*f<around|(|x|)>-\<nabla\><rsup|2>*f<around|(|y|)>|\<\|\|\>>\<leq\>M*<around|\<\|\|\>|x-y|\<\|\|\>>>. Let <math|x<rsup|\<ast\>>> be local minimum of <math|f> with strictly positive Hessian, that is <math|\<nabla\><rsup|2>*f<around|(|x<rsup|\<ast\>>|)>\<succeq\>\<mu\><mI><rsub|n>>, <math|\<mu\>\<gtr\>0>. Suppose that the initial starting point <math|x<rsub|0>> of Newton's method is such that

    <\equation*>
      <around|\<\|\|\>|x<rsub|0>-x<rsup|\<ast\>>|\<\|\|\>>\<leq\><frac|\<mu\>|2*M>.
    </equation*>

    Then Newton's method is well-defined and converges to <math|x<rsup|\<ast\>>> at a quadratic rate:

    <\equation*>
      <around|\<\|\|\>|x<rsub|k+1>-x<rsup|\<ast\>>|\<\|\|\>>\<leq\><frac|M|\<mu\>>*<around|\<\|\|\>|x<rsub|k>-x<rsup|\<ast\>>|\<\|\|\>><rsup|2>.
    </equation*>
  </theorem>

  <\proof>
    We use the following simple formula, for <math|x,h\<in\><R><rsup|n>>,

    <\equation*>
      <big|int><rsub|0><rsup|1>\<nabla\><rsup|2>*f*<around|(|x+s*h|)>*h*d*s=\<nabla\>*f*<around|(|x+h|)>-\<nabla\>*f<around|(|x|)>.
    </equation*>

    Now note that <math|\<nabla\>*f<around|(|x<rsup|\<ast\>>|)>=0>, and thus with the above formula one obtains

    <\equation*>
      \<nabla\>*f<around|(|x<rsub|k>|)>=<big|int><rsub|0><rsup|1>\<nabla\><rsup|2>*f*<around|(|x<rsup|\<ast\>>+s*<around|(|x<rsub|k>-x<rsup|\<ast\>>|)>|)>*<around|(|x<rsub|k>-x<rsup|\<ast\>>|)>*d*s,
    </equation*>

    which allows us to write:

    <\align*>
      <tformat|<table|<row|<cell|>|<cell|x<rsub|k+1>-x<rsup|\<ast\>>>>|<row|<cell|>|<cell|=x<rsub|k>-x<rsup|\<ast\>>-<around|[|\<nabla\><rsup|2>*f<around|(|x<rsub|k>|)>|]><rsup|-1>*\<nabla\>*f<around|(|x<rsub|k>|)>>>|<row|<cell|>|<cell|=x<rsub|k>-x<rsup|\<ast\>>-<around|[|\<nabla\><rsup|2>*f<around|(|x<rsub|k>|)>|]><rsup|-1>*<big|int><rsub|0><rsup|1>\<nabla\><rsup|2>*f*<around|(|x<rsup|\<ast\>>+s*<around|(|x<rsub|k>-x<rsup|\<ast\>>|)>|)>*<around|(|x<rsub|k>-x<rsup|\<ast\>>|)>*d*s>>|<row|<cell|>|<cell|=<around|[|\<nabla\><rsup|2>*f<around|(|x<rsub|k>|)>|]><rsup|-1>*<big|int><rsub|0><rsup|1><around|[|\<nabla\><rsup|2>*f<around|(|x<rsub|k>|)>-\<nabla\><rsup|2>*f*<around|(|x<rsup|\<ast\>>+s*<around|(|x<rsub|k>-x<rsup|\<ast\>>|)>|)>|]>*<around|(|x<rsub|k>-x<rsup|\<ast\>>|)>*d*s.>>>>
    </align*>

    In particular one has

    <\align*>
      <tformat|<table|<row|<cell|>|<cell|<around|\<\|\|\>|x<rsub|k+1>-x<rsup|\<ast\>>|\<\|\|\>>>>|<row|<cell|>|<cell|\<leq\><around|\<\|\|\>|<around|[|\<nabla\><rsup|2>*f<around|(|x<rsub|k>|)>|]><rsup|-1>|\<\|\|\>>>>|<row|<cell|>|<cell|\<times\><around*|(|<big|int><rsub|0><rsup|1><around|\<\|\|\>|\<nabla\><rsup|2>*f<around|(|x<rsub|k>|)>-\<nabla\><rsup|2>*f*<around|(|x<rsup|\<ast\>>+s*<around|(|x<rsub|k>-x<rsup|\<ast\>>|)>|)>|\<\|\|\>>*d*s|)>*<around|\<\|\|\>|x<rsub|k>-x<rsup|\<ast\>>|\<\|\|\>>.>>>>
    </align*>

    Using the Lipschitz property of the Hessian one immediately obtains that

    <\equation*>
      <around*|(|<big|int><rsub|0><rsup|1><around|\<\|\|\>|\<nabla\><rsup|2>*f<around|(|x<rsub|k>|)>-\<nabla\><rsup|2>*f*<around|(|x<rsup|\<ast\>>+s*<around|(|x<rsub|k>-x<rsup|\<ast\>>|)>|)>|\<\|\|\>>*d*s|)>\<leq\><frac|M|2>*<around|\<\|\|\>|x<rsub|k>-x<rsup|\<ast\>>|\<\|\|\>>.
    </equation*>

    Using again the Lipschitz property of the Hessian (note that <math|<around|\<\|\|\>|A-B|\<\|\|\>>\<leq\>s\<Leftrightarrow\>s<mI><rsub|n>\<succeq\>A-B\<succeq\>-s<mI><rsub|n>>), the hypothesis on <math|x<rsup|\<ast\>>>, and an induction hypothesis that <math|<around|\<\|\|\>|x<rsub|k>-x<rsup|\<ast\>>|\<\|\|\>>\<leq\><frac|\<mu\>|2*M>>, one has

    <\equation*>
      \<nabla\><rsup|2>*f<around|(|x<rsub|k>|)>\<succeq\>\<nabla\><rsup|2>*f<around|(|x<rsup|\<ast\>>|)>-M*<around|\<\|\|\>|x<rsub|k>-x<rsup|\<ast\>>|\<\|\|\>><mI><rsub|n>\<succeq\><around|(|\<mu\>-M*<around|\<\|\|\>|x<rsub|k>-x<rsup|\<ast\>>|\<\|\|\>>|)><mI><rsub|n>\<succeq\><frac|\<mu\>|2><mI><rsub|n>,
    </equation*>

    which concludes the proof.
  </proof>

  <subsection|Self-concordant functions>

  Before giving the definition of self-concordant functions let us try to get some insight into the “geometry" of Newton's method. Let <math|A> be a <math|n\<times\>n> non-singular matrix. We look at a Newton step on the functions <math|f:x\<mapsto\>f<around|(|x|)>> and <math|\<phi\>:y\<mapsto\>f*<around|(|A<rsup|-1>*y|)>>, starting respectively from <math|x> and <math|y=A*x>, that is:

  <\equation*>
    x<rsup|+>=x-<around|[|\<nabla\><rsup|2>*f<around|(|x|)>|]><rsup|-1>*\<nabla\>*f<around|(|x|)>,<space|0.27em><text|and><space|0.27em>y<rsup|+>=y-<around|[|\<nabla\><rsup|2>*\<phi\><around|(|y|)>|]><rsup|-1>*\<nabla\>*\<phi\><around|(|y|)>.
  </equation*>

  By using the following simple formulas

  <\equation*>
    \<nabla\>*<around|(|x\<mapsto\>f*<around|(|A*x|)>|)>=A<rsup|\<top\>>*\<nabla\>*f*<around|(|A*x|)>,<space|0.27em><text|and><space|0.27em>\<nabla\><rsup|2>*<around|(|x\<mapsto\>f*<around|(|A*x|)>|)>=A<rsup|\<top\>>*\<nabla\><rsup|2>*f*<around|(|A*x|)>*A.
  </equation*>

  it is easy to show that

  <\equation*>
    y<rsup|+>=A*x<rsup|+>.
  </equation*>

  In other words Newton's method will follow the same trajectory in the “<math|x>-space" and in the “<math|y>-space" (the image through <math|A> of the <math|x>-space), that is Newton's method is <with|font-shape|italic|affine invariant>. Observe that this property is not shared by the methods described in Chapter <reference|dimfree> (except for the conditional gradient descent).

  The affine invariance of Newton's method casts some concerns on the assumptions of the analysis in Section <reference|sec:tradanalysisNM>. Indeed the assumptions are all in terms of the canonical inner product in <math|<R><rsup|n>>. However we just showed that the method itself does not depend on the choice of the inner product (again this is not true for first order methods). Thus one would like to derive a result similar to Theorem <reference|th:NM> without any reference to a prespecified inner product. The idea of self-concordance is to modify the Lipschitz assumption on the Hessian to achieve this goal.

  Assume from now on that <math|f> is <math|C<rsup|3>>, and let <math|\<nabla\><rsup|3>*f<around|(|x|)>:<R><rsup|n>\<times\><R><rsup|n>\<times\><R><rsup|n>\<rightarrow\><R>> be the third order differential operator. The Lipschitz assumption on the Hessian in Theorem <reference|th:NM> can be written as:

  <\equation*>
    \<nabla\><rsup|3>*f<around|(|x|)><around|[|h,h,h|]>\<leq\>M<around|\<\|\|\>|h|\<\|\|\>><rsub|2><rsup|3>.
  </equation*>

  The issue is that this inequality depends on the choice of an inner product. More importantly it is easy to see that a convex function which goes to infinity on a compact set simply cannot satisfy the above inequality. A natural idea to try fix these issues is to replace the Euclidean metric on the right hand side by the metric given by the function <math|f> itself at <math|x>, that is:

  <\equation*>
    <around|\<\|\|\>|h|\<\|\|\>><rsub|x>=<sqrt|h<rsup|\<top\>>*\<nabla\><rsup|2>*f<around|(|x|)>*h>.
  </equation*>

  Observe that to be clear one should rather use the notation <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>><rsub|x,f>>, but since <math|f> will always be clear from the context we stick to <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>><rsub|x>>.

  <\definition>
    Let <math|\<cal-X\>> be a convex set with non-empty interior, and <math|f> a <math|C<rsup|3>> convex function defined on <math|<inte><around|(|\<cal-X\>|)>>. Then <math|f> is self-concordant (with constant <math|M>) if for all <math|x\<in\><inte><around|(|\<cal-X\>|)>,h\<in\><R><rsup|n>>,

    <\equation*>
      \<nabla\><rsup|3>*f<around|(|x|)><around|[|h,h,h|]>\<leq\>M<around|\<\|\|\>|h|\<\|\|\>><rsub|x><rsup|3>.
    </equation*>

    We say that <math|f> is standard self-concordant if <math|f> is self-concordant with constant <math|M=2>.
  </definition>

  An easy consequence of the definition is that a self-concordant function is a barrier for the set <math|\<cal-X\>>, see [Theorem 4.1.4, <cite|Nes04>]. The main example to keep in mind of a standard self-concordant function is <math|f<around|(|x|)>=-log x> for <math|x\<gtr\>0>. The next definition will be key in order to describe the region of quadratic convergence for Newton's method on self-concordant functions.

  <\definition>
    Let <math|f> be a standard self-concordant function on <math|\<cal-X\>>. For <math|x\<in\><math-up|int><around|(|\<cal-X\>|)>>, we say that <math|\<lambda\><rsub|f><around|(|x|)>=<around|\<\|\|\>|\<nabla\>*f<around|(|x|)>|\<\|\|\>><rsub|x><rsup|\<ast\>>> is the <with|font-shape|italic|Newton decrement> of <math|f> at <math|x>.
  </definition>

  An important inequality is that for <math|x> such that <math|\<lambda\><rsub|f><around|(|x|)>\<less\>1>, and <math|x<rsup|\<ast\>>=<argmin>f<around|(|x|)>>, one has

  <\equation>
    <label|eq:trucipm3><around|\<\|\|\>|x-x<rsup|\<ast\>>|\<\|\|\>><rsub|x>\<leq\><frac|\<lambda\><rsub|f><around|(|x|)>|1-\<lambda\><rsub|f><around|(|x|)>>,
  </equation>

  see [Equation 4.1.18, <cite|Nes04>]. We state the next theorem without a proof, see also [Theorem 4.1.14, <cite|Nes04>].

  <\theorem>
    <label|th:NMsc>Let <math|f> be a standard self-concordant function on <math|\<cal-X\>>, and <math|x\<in\><math-up|int><around|(|\<cal-X\>|)>> such that <math|\<lambda\><rsub|f><around|(|x|)>\<leq\>1/4>, then

    <\equation*>
      \<lambda\><rsub|f>*<around*|(|x-<around|[|\<nabla\><rsup|2>*f<around|(|x|)>|]><rsup|-1>*\<nabla\>*f<around|(|x|)>|)>\<leq\>2*\<lambda\><rsub|f><around|(|x|)><rsup|2>.
    </equation*>
  </theorem>

  In other words the above theorem states that, if initialized at a point <math|x<rsub|0>> such that <math|\<lambda\><rsub|f><around|(|x<rsub|0>|)>\<leq\>1/4>, then Newton's iterates satisfy <math|\<lambda\><rsub|f><around|(|x<rsub|k+1>|)>\<leq\>2*\<lambda\><rsub|f><around|(|x<rsub|k>|)><rsup|2>>. Thus, Newton's region of quadratic convergence for self-concordant functions can be described as a “Newton decrement ball" <math|<around|{|x:\<lambda\><rsub|f><around|(|x|)>\<leq\>1/4|}>>. In particular by taking the barrier to be a self-concordant function we have now resolved Step (1) of the plan described in Section <reference|sec:barriermethod>.

  <subsection|<math|\<nu\>>-self-concordant barriers>

  We deal here with Step (2) of the plan described in Section <reference|sec:barriermethod>. Given Theorem <reference|th:NMsc> we want <math|t<rprime|'>> to be as large as possible and such that

  <\equation>
    <label|eq:trucipm1>\<lambda\><rsub|F<rsub|t<rprime|'>>><around|(|x<rsup|\<ast\>><around|(|t|)>|)>\<leq\>1/4.
  </equation>

  Since the Hessian of <math|F<rsub|t<rprime|'>>> is the Hessian of <math|F>, one has

  <\equation*>
    \<lambda\><rsub|F<rsub|t<rprime|'>>><around|(|x<rsup|\<ast\>><around|(|t|)>|)>=<around|\<\|\|\>|t<rprime|'>*c+\<nabla\>*F<around|(|x<rsup|\<ast\>><around|(|t|)>|)>|\<\|\|\>><rsub|x<rsup|\<ast\>><around|(|t|)>><rsup|\<ast\>>.
  </equation*>

  Observe that, by first order optimality, one has <math|t*c+\<nabla\>*F<around|(|x<rsup|\<ast\>><around|(|t|)>|)>=0>, which yields

  <\equation>
    <label|eq:trucipm11>\<lambda\><rsub|F<rsub|t<rprime|'>>><around|(|x<rsup|\<ast\>><around|(|t|)>|)>=<around|(|t<rprime|'>-t|)><around|\<\|\|\>|c|\<\|\|\>><rsup|\<ast\>><rsub|x<rsup|\<ast\>><around|(|t|)>>.
  </equation>

  Thus taking

  <\equation>
    <label|eq:trucipm2>t<rprime|'>=t+<frac|1|4<around|\<\|\|\>|c|\<\|\|\>><rsup|\<ast\>><rsub|x<rsup|\<ast\>><around|(|t|)>>>
  </equation>

  immediately yields <eqref|eq:trucipm1>. In particular with the value of <math|t<rprime|'>> given in <eqref|eq:trucipm2> the Newton's method on <math|F<rsub|t<rprime|'>>> initialized at <math|x<rsup|\<ast\>><around|(|t|)>> will converge quadratically fast to <math|x<rsup|\<ast\>><around|(|t<rprime|'>|)>>.

  It remains to verify that by iterating <eqref|eq:trucipm2> one obtains a sequence diverging to infinity, and to estimate the rate of growth. Thus one needs to control <math|<around|\<\|\|\>|c|\<\|\|\>><rsup|\<ast\>><rsub|x<rsup|\<ast\>><around|(|t|)>>=<frac|1|t>*<around|\<\|\|\>|\<nabla\>*F<around|(|x<rsup|\<ast\>><around|(|t|)>|)>|\<\|\|\>><rsub|x<rsup|\<ast\>><around|(|t|)>><rsup|\<ast\>>>. Luckily there is a natural class of functions for which one can control <math|<around|\<\|\|\>|\<nabla\>*F<around|(|x|)>|\<\|\|\>><rsub|x><rsup|\<ast\>>> uniformly over <math|x>. This is the set of functions such that

  <\equation>
    <label|eq:nu>\<nabla\><rsup|2>*F<around|(|x|)>\<succeq\><frac|1|\<nu\>>*\<nabla\>*F<around|(|x|)>*<around|[|\<nabla\>*F<around|(|x|)>|]><rsup|\<top\>>.
  </equation>

  Indeed in that case one has:

  <\eqnarray*>
    <tformat|<table|<row|<cell|<around|\<\|\|\>|\<nabla\>*F<around|(|x|)>|\<\|\|\>><rsub|x><rsup|\<ast\>>>|<cell|=>|<cell|sup<rsub|h:h<rsup|\<top\>>*\<nabla\>*F<rsup|2><around|(|x|)>*h\<leq\>1> \<nabla\>*F<around|(|x|)><rsup|\<top\>>*h>>|<row|<cell|>|<cell|\<leq\>>|<cell|sup<rsub|h:h<rsup|\<top\>>*<around*|(|<frac|1|\<nu\>>*\<nabla\>*F<around|(|x|)>*<around|[|\<nabla\>*F<around|(|x|)>|]><rsup|\<top\>>|)>*h\<leq\>1> \<nabla\>*F<around|(|x|)><rsup|\<top\>>*h>>|<row|<cell|>|<cell|=>|<cell|<sqrt|\<nu\>>.>>>>
  </eqnarray*>

  Thus a safe choice to increase the penalization parameter is <math|t<rprime|'>=<around*|(|1+<frac|1|4*<sqrt|\<nu\>>>|)>*t>. Note that the condition <eqref|eq:nu> can also be written as the fact that the function <math|F> is <math|<frac|1|\<nu\>>>-exp-concave, that is <math|x\<mapsto\>exp <around|(|-<frac|1|\<nu\>>*F<around|(|x|)>|)>> is concave. We arrive at the following definition.

  <\definition>
    <math|F> is a <math|\<nu\>>-self-concordant barrier if it is a standard self-concordant function, and it is <math|<frac|1|\<nu\>>>-exp-concave.
  </definition>

  Again the canonical example is the logarithmic function, <math|x\<mapsto\>-log x>, which is a <math|1>-self-concordant barrier for the set <math|<R><rsub|+>>. We state the next theorem without a proof (see <cite|BE14> for more on this result).

  <\theorem>
    Let <math|\<cal-X\>\<subset\><R><rsup|n>> be a closed convex set with non-empty interior. There exists <math|F> which is a <math|<around|(|c*n|)>>-self-concordant barrier for <math|\<cal-X\>> (where <math|c> is some universal constant).
  </theorem>

  A key property of <math|\<nu\>>-self-concordant barriers is the following inequality:

  <\equation>
    <label|eq:key>c<rsup|\<top\>>*x<rsup|\<ast\>><around|(|t|)>-min<rsub|x\<in\>\<cal-X\>> c<rsup|\<top\>>*x\<leq\><frac|\<nu\>|t>,
  </equation>

  see [Equation (4.2.17), <cite|Nes04>]. More generally using <eqref|eq:key> together with <eqref|eq:trucipm3> one obtains

  <\eqnarray>
    <tformat|<table|<row|<cell|c<rsup|\<top\>>*y-min<rsub|x\<in\>\<cal-X\>> c<rsup|\<top\>>*x>|<cell|\<leq\>>|<cell|<frac|\<nu\>|t>+c<rsup|\<top\>>*<around|(|y-x<rsup|\<ast\>><around|(|t|)>|)><eq-number>>>|<row|<cell|>|<cell|=>|<cell|<frac|\<nu\>|t>+<frac|1|t>*<around|(|\<nabla\>*F<rsub|t><around|(|y|)>-\<nabla\>*F<around|(|y|)>|)><rsup|\<top\>>*<around|(|y-x<rsup|\<ast\>><around|(|t|)>|)><eq-number>>>|<row|<cell|>|<cell|\<leq\>>|<cell|<frac|\<nu\>|t>+<frac|1|t>*<around|\<\|\|\>|\<nabla\>*F<rsub|t><around|(|y|)>-\<nabla\>*F<around|(|y|)>|\<\|\|\>><rsub|y><rsup|\<ast\>>\<cdot\><around|\<\|\|\>|y-x<rsup|\<ast\>><around|(|t|)>|\<\|\|\>><rsub|y><eq-number>>>|<row|<cell|>|<cell|\<leq\>>|<cell|<frac|\<nu\>|t>+<frac|1|t>*<around|(|\<lambda\><rsub|F<rsub|t>><around|(|y|)>+<sqrt|\<nu\>>|)>*<frac|\<lambda\><rsub|F<rsub|t>><around|(|y|)>|1-\<lambda\><rsub|F<rsub|t>><around|(|y|)>><eq-number><label|eq:trucipm4>>>>>
  </eqnarray>

  In the next section we describe a precise algorithm based on the ideas we developed above. As we will see one cannot ensure to be exactly on the central path, and thus it is useful to generalize the identity <eqref|eq:trucipm11> for a point <math|x> close to the central path. We do this as follows:

  <\eqnarray>
    <tformat|<table|<row|<cell|\<lambda\><rsub|F<rsub|t<rprime|'>>><around|(|x|)>>|<cell|=>|<cell|<around|\<\|\|\>|t<rprime|'>*c+\<nabla\>*F<around|(|x|)>|\<\|\|\>><rsub|x><rsup|\<ast\>><eq-number>>>|<row|<cell|>|<cell|=>|<cell|<around|\<\|\|\>|<around|(|t<rprime|'>/t|)>*<around|(|t*c+\<nabla\>*F<around|(|x|)>|)>+<around|(|1-t<rprime|'>/t|)>*\<nabla\>*F<around|(|x|)>|\<\|\|\>><rsub|x><rsup|\<ast\>><eq-number>>>|<row|<cell|>|<cell|\<leq\>>|<cell|<frac|t<rprime|'>|t>*\<lambda\><rsub|F<rsub|t>><around|(|x|)>+<around*|(|<frac|t<rprime|'>|t>-1|)>*<sqrt|\<nu\>>.<eq-number><label|eq:trucipm12>>>>>
  </eqnarray>

  <subsection|Path-following scheme>

  We can now formally describe and analyze the most basic IPM called the <with|font-shape|italic|path-following scheme>. Let <math|F> be <math|\<nu\>>-self-concordant barrier for <math|<cX>>. Assume that one can find <math|x<rsub|0>> such that <math|\<lambda\><rsub|F<rsub|t<rsub|0>>><around|(|x<rsub|0>|)>\<leq\>1/4> for some small value <math|t<rsub|0>\<gtr\>0> (we describe a method to find <math|x<rsub|0>> at the end of this subsection). Then for <math|k\<geq\>0>, let

  <\eqnarray*>
    <tformat|<table|<row|<cell|>|<cell|>|<cell|t<rsub|k+1>=<around*|(|1+<frac|1|13*<sqrt|\<nu\>>>|)>*t<rsub|k>,>>|<row|<cell|>|<cell|>|<cell|x<rsub|k+1>=x<rsub|k>-<around|[|\<nabla\><rsup|2>*F<around|(|x<rsub|k>|)>|]><rsup|-1>*<around|(|t<rsub|k+1>*c+\<nabla\>*F<around|(|x<rsub|k>|)>|)>.>>>>
  </eqnarray*>

  The next theorem shows that after <math|O<around*|(|<sqrt|\<nu\>>*log <frac|\<nu\>|t<rsub|0>*\<epsilon\>>|)>> iterations of the path-following scheme one obtains an <math|\<epsilon\>>-optimal point.

  <\theorem>
    The path-following scheme described above satisfies

    <\equation*>
      c<rsup|\<top\>>*x<rsub|k>-min<rsub|x\<in\>\<cal-X\>> c<rsup|\<top\>>*x\<leq\><frac|2*\<nu\>|t<rsub|0>>*exp <around*|(|-<frac|k|1+13*<sqrt|\<nu\>>>|)>.
    </equation*>
  </theorem>

  <\proof>
    We show that the iterates <math|<around|(|x<rsub|k>|)><rsub|k\<geq\>0>> remain close to the central path <math|<around|(|x<rsup|\<ast\>><around|(|t<rsub|k>|)>|)><rsub|k\<geq\>0>>. Precisely one can easily prove by induction that

    <\equation*>
      \<lambda\><rsub|F<rsub|t<rsub|k>>><around|(|x<rsub|k>|)>\<leq\>1/4.
    </equation*>

    Indeed using Theorem <reference|th:NMsc> and equation <eqref|eq:trucipm12> one immediately obtains

    <\eqnarray*>
      <tformat|<table|<row|<cell|\<lambda\><rsub|F<rsub|t<rsub|k+1>>><around|(|x<rsub|k+1>|)>>|<cell|\<leq\>>|<cell|2*\<lambda\><rsub|F<rsub|t<rsub|k+1>>><around|(|x<rsub|k>|)><rsup|2>>>|<row|<cell|>|<cell|\<leq\>>|<cell|2*<around*|(|<frac|t<rsub|k+1>|t<rsub|k>>*\<lambda\><rsub|F<rsub|t<rsub|k>>><around|(|x<rsub|k>|)>+<around*|(|<frac|t<rsub|k+1>|t<rsub|k>>-1|)>*<sqrt|\<nu\>>|)><rsup|2>>>|<row|<cell|>|<cell|\<leq\>>|<cell|1/4,>>>>
    </eqnarray*>

    where we used in the last inequality that <math|t<rsub|k+1>/t<rsub|k>=1+<frac|1|13*<sqrt|\<nu\>>>> and <math|\<nu\>\<geq\>1>.

    Thus using <eqref|eq:trucipm4> one obtains

    <\equation*>
      c<rsup|\<top\>>*x<rsub|k>-min<rsub|x\<in\>\<cal-X\>> c<rsup|\<top\>>*x\<leq\><frac|\<nu\>+<sqrt|\<nu\>>/3+1/12|t<rsub|k>>\<leq\><frac|2*\<nu\>|t<rsub|k>>.
    </equation*>

    Observe that <math|t<rsub|k>=<around*|(|1+<frac|1|13*<sqrt|\<nu\>>>|)><rsup|k>*t<rsub|0>>, which finally yields

    <\equation*>
      c<rsup|\<top\>>*x<rsub|k>-min<rsub|x\<in\>\<cal-X\>> c<rsup|\<top\>>*x\<leq\><frac|2*\<nu\>|t<rsub|0>>*<around*|(|1+<frac|1|13*<sqrt|\<nu\>>>|)><rsup|-k>.
    </equation*>
  </proof>

  At this point we still need to explain how one can get close to an intial point <math|x<rsup|\<ast\>><around|(|t<rsub|0>|)>> of the central path. This can be done with the following rather clever trick. Assume that one has some point <math|y<rsub|0>\<in\><cX>>. The observation is that <math|y<rsub|0>> is on the central path at <math|t=1> for the problem where <math|c> is replaced by <math|-\<nabla\>*F<around|(|y<rsub|0>|)>>. Now instead of following this central path as <math|t\<to\>+\<infty\>>, one follows it as <math|t\<to\>0>. Indeed for <math|t> small enough the central paths for <math|c> and for <math|-\<nabla\>*F<around|(|y<rsub|0>|)>> will be very close. Thus we iterate the following equations, starting with <math|t<rsub|0><rprime|'>=1>,

  <\eqnarray*>
    <tformat|<table|<row|<cell|>|<cell|>|<cell|t<rsub|k+1><rprime|'>=<around*|(|1-<frac|1|13*<sqrt|\<nu\>>>|)>*t<rsub|k><rprime|'>,>>|<row|<cell|>|<cell|>|<cell|y<rsub|k+1>=y<rsub|k>-<around|[|\<nabla\><rsup|2>*F<around|(|y<rsub|k>|)>|]><rsup|-1>*<around|(|-t<rsub|k+1><rprime|'>*\<nabla\>*F<around|(|y<rsub|0>|)>+\<nabla\>*F<around|(|y<rsub|k>|)>|)>.>>>>
  </eqnarray*>

  A straightforward analysis shows that for <math|k=O<around|(|<sqrt|\<nu\>>*log \<nu\>|)>>, which corresponds to <math|t<rsub|k><rprime|'>=1/\<nu\><rsup|O<around|(|1|)>>>, one obtains a point <math|y<rsub|k>> such that <math|\<lambda\><rsub|F<rsub|t<rsub|k><rprime|'>>><around|(|y<rsub|k>|)>\<leq\>1/4>. In other words one can initialize the path-following scheme with <math|t<rsub|0>=t<rsub|k><rprime|'>> and <math|x<rsub|0>=y<rsub|k>>.

  <subsection|IPMs for LPs and SDPs>

  We have seen that, roughly, the complexity of interior point methods with a <math|\<nu\>>-self-concordant barrier is <math|O<around*|(|M<sqrt|\<nu\>>*log <frac|\<nu\>|\<epsilon\>>|)>>, where <math|M> is the complexity of computing a Newton direction (which can be done by computing and inverting the Hessian of the barrier). Thus the efficiency of the method is directly related to the <with|font-shape|italic|form> of the self-concordant barrier that one can construct for <math|\<cal-X\>>. It turns out that for LPs and SDPs one has particularly nice self-concordant barriers. Indeed one can show that <math|F<around|(|x|)>=-<big|sum><rsub|i=1><rsup|n>log x<rsub|i>> is an <math|n>-self-concordant barrier on <math|<R><rsub|+><rsup|n>>, and <math|F<around|(|x|)>=-log <math-up|det><around|(|X|)>> is an <math|n>-self-concordant barrier on <math|\<bbb-S\><rsub|+><rsup|n>>. See also <cite|LS13> for a recent improvement of the basic logarithmic barrier for LPs.

  There is one important issue that we overlooked so far. In most interesting cases LPs and SDPs come with <with|font-shape|italic|equality constraints>, resulting in a set of constraints <math|<cX>> with empty interior. From a theoretical point of view there is an easy fix, which is to reparametrize the problem as to enforce the variables to live in the subspace spanned by <math|<cX>>. This modification also has algorithmic consequences, as the evaluation of the Newton direction will now be different. In fact, rather than doing a reparametrization, one can simply search for Newton directions such that the updated point will stay in <math|<cX>>. In other words one has now to solve a convex quadratic optimization problem under linear equality constraints. Luckily using Lagrange multipliers one can find a closed form solution to this problem, and we refer to previous references for more details.

  <chapter|Convex optimization and randomness><label|rand>

  In this chapter we explore the interplay between optimization and randomness. A key insight, going back to <cite|RM51>, is that first order methods are quite robust: the gradients do not have to be computed exactly to ensure progress towards the optimum. Indeed since these methods usually do many small steps, as long as the gradients are correct <with|font-shape|italic|on average>, the error introduced by the gradient approximations will eventually vanish. As we will see below this intuition is correct for non-smooth optimization (since the steps are indeed small) but the picture is more subtle in the case of smooth optimization (recall from Chapter <reference|dimfree> that in this case we take long steps).

  We introduce now the main object of this chapter: a (first order) <with|font-shape|italic|stochastic> oracle for a convex function <math|f:<cX>\<rightarrow\><R>> takes as input a point <math|x\<in\><cX>> and outputs a random variable <math|<tg><around|(|x|)>> such that <math|<E>*<tg><around|(|x|)>\<in\>\<partial\>*f<around|(|x|)>>. In the case where the query point <math|x> is a random variable (possibly obtained from previous queries to the oracle), one assumes that <math|<E><around|(|<tg><around|(|x|)>\|x|)>\<in\>\<partial\>*f<around|(|x|)>>.

  The unbiasedness assumption by itself is not enough to obtain rates of convergence, one also needs to make assumptions about the fluctuations of <math|<tg><around|(|x|)>>. Essentially in the non-smooth case we will assume that there exists <math|B\<gtr\>0> such that <math|<E><around|\<\|\|\>|<tg><around|(|x|)>|\<\|\|\>><rsub|\<ast\>><rsup|2>\<leq\>B<rsup|2>> for all <math|x\<in\><cX>>, while in the smooth case we assume that there exists <math|\<sigma\>\<gtr\>0> such that <math|<E>*<around|\<\|\|\>|<tg><around|(|x|)>-\<nabla\>*f<around|(|x|)>|\<\|\|\>><rsub|\<ast\>><rsup|2>\<leq\>\<sigma\><rsup|2>> for all <math|x\<in\><cX>>.

  We also note that the situation with a <with|font-shape|italic|biased> oracle is quite different, and we refer to <cite|Asp08|SLRB11> for some works in this direction.

  The two canonical examples of a stochastic oracle in machine learning are as follows.

  Let <math|f<around|(|x|)>=<E><rsub|\<xi\>>*\<ell\>*<around|(|x,\<xi\>|)>> where <math|\<ell\>*<around|(|x,\<xi\>|)>> should be interpreted as the loss of predictor <math|x> on the example <math|\<xi\>>. We assume that <math|\<ell\>*<around|(|\<cdummy\>,\<xi\>|)>> is a (differentiable<footnote|We assume differentiability only for sake of notation here.>) convex function for any <math|\<xi\>>. The goal is to find a predictor with minimal expected loss, that is to minimize <math|f>. When queried at <math|x> the stochastic oracle can draw <math|\<xi\>> from the unknown distribution and report <math|\<nabla\><rsub|x>*\<ell\>*<around|(|x,\<xi\>|)>>. One obviously has <math|<E><rsub|\<xi\>>*\<nabla\><rsub|x>*\<ell\>*<around|(|x,\<xi\>|)>\<in\>\<partial\>*f<around|(|x|)>>.

  The second example is the one described in Section <reference|sec:mlapps>, where one wants to minimize <math|f<around|(|x|)>=<frac|1|m>*<big|sum><rsub|i=1><rsup|m>f<rsub|i><around|(|x|)>>. In this situation a stochastic oracle can be obtained by selecting uniformly at random <math|I\<in\><around|[|m|]>> and reporting <math|\<nabla\>*f<rsub|I><around|(|x|)>>.

  Observe that the stochastic oracles in the two above cases are quite different. Consider the standard situation where one has access to a data set of i.i.d. samples <math|\<xi\><rsub|1>,\<ldots\>,\<xi\><rsub|m>>. Thus in the first case, where one wants to minimize the <with|font-shape|italic|expected loss>, one is limited to <math|m> queries to the oracle, that is to a <with|font-shape|italic|single pass> over the data (indeed one cannot ensure that the conditional expectations are correct if one uses twice a data point). On the contrary for the <with|font-shape|italic|empirical loss> where <math|f<rsub|i><around|(|x|)>=\<ell\>*<around|(|x,\<xi\><rsub|i>|)>> one can do as many passes as one wishes.

  <section|Non-smooth stochastic optimization><label|sec:smd>

  We initiate our study with stochastic mirror descent (S-MD) which is defined as follows: <math|x<rsub|1>\<in\><argmin><rsub|<cX>\<cap\><cD>>\<Phi\><around|(|x|)>>, and

  <\equation*>
    x<rsub|t+1>=<argmin><rsub|x\<in\>\<cal-X\>\<cap\>\<cal-D\>>\<eta\>*<wide|g|~><around|(|x<rsub|t>|)><rsup|\<top\>>*x+D<rsub|\<Phi\>>*<around|(|x,x<rsub|t>|)>.
  </equation*>

  In this case equation <eqref|eq:vfMD> rewrites

  <\equation*>
    <big|sum><rsub|s=1><rsup|t><tg><around|(|x<rsub|s>|)><rsup|\<top\>>*<around|(|x<rsub|s>-x|)>\<leq\><frac|R<rsup|2>|\<eta\>>+<frac|\<eta\>|2*\<rho\>>*<big|sum><rsub|s=1><rsup|t><around|\<\|\|\>|<tg><around|(|x<rsub|s>|)>|\<\|\|\>><rsub|\<ast\>><rsup|2>.
  </equation*>

  This immediately yields a rate of convergence thanks to the following simple observation based on the tower rule:

  <\eqnarray*>
    <tformat|<table|<row|<cell|<E>*f*<around*|(|<frac|1|t>*<big|sum><rsub|s=1><rsup|t>x<rsub|s>|)>-f<around|(|x|)>>|<cell|\<leq\>>|<cell|<frac|1|t>*<E>*<big|sum><rsub|s=1><rsup|t><around|(|f<around|(|x<rsub|s>|)>-f<around|(|x|)>|)>>>|<row|<cell|>|<cell|\<leq\>>|<cell|<frac|1|t>*<E>*<big|sum><rsub|s=1><rsup|t><E><around|(|<tg><around|(|x<rsub|s>|)>\|x<rsub|s>|)><rsup|\<top\>>*<around|(|x<rsub|s>-x|)>>>|<row|<cell|>|<cell|=>|<cell|<frac|1|t>*<E>*<big|sum><rsub|s=1><rsup|t><tg><around|(|x<rsub|s>|)><rsup|\<top\>>*<around|(|x<rsub|s>-x|)>.>>>>
  </eqnarray*>

  We just proved the following theorem.

  <\theorem>
    <label|th:SMD>Let <math|\<Phi\>> be a mirror map <math|1>-strongly convex on <math|\<cal-X\>\<cap\>\<cal-D\>> with respect to <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>>>, and let <math|R<rsup|2>=sup<rsub|x\<in\>\<cal-X\>\<cap\>\<cal-D\>> \<Phi\><around|(|x|)>-\<Phi\><around|(|x<rsub|1>|)>>. Let <math|f> be convex. Furthermore assume that the stochastic oracle is such that <math|<E><around|\<\|\|\>|<tg><around|(|x|)>|\<\|\|\>><rsub|\<ast\>><rsup|2>\<leq\>B<rsup|2>>. Then S-MD with <math|\<eta\>=<frac|R|B>*<sqrt|<frac|2|t>>> satisfies

    <\equation*>
      <E>*f*<around*|(|<frac|1|t>*<big|sum><rsub|s=1><rsup|t>x<rsub|s>|)>-min<rsub|x\<in\>\<cal-X\>> f<around|(|x|)>\<leq\>R*B*<sqrt|<frac|2|t>>.
    </equation*>
  </theorem>

  Similarly, in the Euclidean and strongly convex case, one can directly generalize Theorem <reference|th:LJSB12>. Precisely we consider stochastic gradient descent (SGD), that is S-MD with <math|\<Phi\><around|(|x|)>=<frac|1|2><around|\<\|\|\>|x|\<\|\|\>><rsub|2><rsup|2>>, with time-varying step size <math|<around|(|\<eta\><rsub|t>|)><rsub|t\<geq\>1>>, that is

  <\equation*>
    x<rsub|t+1>=\<Pi\><rsub|<cX>>*<around|(|x<rsub|t>-\<eta\><rsub|t>*<tg><around|(|x<rsub|t>|)>|)>.
  </equation*>

  <\theorem>
    <label|th:sgdstrong>Let <math|f> be <math|\<alpha\>>-strongly convex, and assume that the stochastic oracle is such that <math|<E><around|\<\|\|\>|<tg><around|(|x|)>|\<\|\|\>><rsub|\<ast\>><rsup|2>\<leq\>B<rsup|2>>. Then SGD with <math|\<eta\><rsub|s>=<frac|2|\<alpha\>*<around|(|s+1|)>>> satisfies

    <\equation*>
      f<around*|(|<big|sum><rsub|s=1><rsup|t><frac|2*s|t*<around|(|t+1|)>>*x<rsub|s>|)>-f<around|(|x<rsup|\<ast\>>|)>\<leq\><frac|2*B<rsup|2>|\<alpha\>*<around|(|t+1|)>>.
    </equation*>
  </theorem>

  <section|Smooth stochastic optimization and mini-batch SGD>

  In the previous section we showed that, for non-smooth optimization, there is basically no cost for having a stochastic oracle instead of an exact oracle. Unfortunately one can show (see e.g. <cite|Tsy03>) that smoothness does not bring any acceleration for a general stochastic oracle<footnote|While being true in general this statement does not say anything about specific functions/oracles. For example it was shown in <cite|BM13> that acceleration can be obtained for the square loss and the logistic loss.>. This is in sharp contrast with the exact oracle case where we showed that gradient descent attains a <math|1/t> rate (instead of <math|1/<sqrt|t>> for non-smooth), and this could even be improved to <math|1/t<rsup|2>> thanks to Nesterov's accelerated gradient descent.

  The next result interpolates between the <math|1/<sqrt|t>> for stochastic smooth optimization, and the <math|1/t> for deterministic smooth optimization. We will use it to propose a useful modification of SGD in the smooth case. The proof is extracted from <cite|DGBSX12>.

  <\theorem>
    <label|th:SMDsmooth>Let <math|\<Phi\>> be a mirror map <math|1>-strongly convex on <math|\<cal-X\>\<cap\>\<cal-D\>> w.r.t. <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>>>, and let <math|R<rsup|2>=sup<rsub|x\<in\>\<cal-X\>\<cap\>\<cal-D\>> \<Phi\><around|(|x|)>-\<Phi\><around|(|x<rsub|1>|)>>. Let <math|f> be convex and <math|\<beta\>>-smooth w.r.t. <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>>>. Furthermore assume that the stochastic oracle is such that <math|<E>*<around|\<\|\|\>|\<nabla\>*f<around|(|x|)>-<tg><around|(|x|)>|\<\|\|\>><rsub|\<ast\>><rsup|2>\<leq\>\<sigma\><rsup|2>>. Then S-MD with stepsize <math|<frac|1|\<beta\>+1/\<eta\>>> and <math|\<eta\>=<frac|R|\<sigma\>>*<sqrt|<frac|2|t>>> satisfies

    <\equation*>
      <E>*f*<around*|(|<frac|1|t>*<big|sum><rsub|s=1><rsup|t>x<rsub|s+1>|)>-f<around|(|x<rsup|\<ast\>>|)>\<leq\>R*\<sigma\><sqrt|<frac|2|t>>+<frac|\<beta\>*R<rsup|2>|t>.
    </equation*>
  </theorem>

  <\proof>
    Using <math|\<beta\>>-smoothness, Cauchy-Schwarz (with <math|2*a*b\<leq\>x*a<rsup|2>+b<rsup|2>/x> for any <math|x\<gtr\>0>), and the 1-strong convexity of <math|\<Phi\>>, one obtains

    <\align*>
      <tformat|<table|<row|<cell|>|<cell|f<around|(|x<rsub|s+1>|)>-f<around|(|x<rsub|s>|)>>>|<row|<cell|>|<cell|\<leq\>\<nabla\>*f<around|(|x<rsub|s>|)><rsup|\<top\>>*<around|(|x<rsub|s+1>-x<rsub|s>|)>+<frac|\<beta\>|2>*<around|\<\|\|\>|x<rsub|s+1>-x<rsub|s>|\<\|\|\>><rsup|2>>>|<row|<cell|>|<cell|=<tg><rsub|s><rsup|\<top\>>*<around|(|x<rsub|s+1>-x<rsub|s>|)>+<around|(|\<nabla\>*f<around|(|x<rsub|s>|)>-<tg><rsub|s>|)><rsup|\<top\>>*<around|(|x<rsub|s+1>-x<rsub|s>|)>+<frac|\<beta\>|2>*<around|\<\|\|\>|x<rsub|s+1>-x<rsub|s>|\<\|\|\>><rsup|2>>>|<row|<cell|>|<cell|\<leq\><tg><rsub|s><rsup|\<top\>>*<around|(|x<rsub|s+1>-x<rsub|s>|)>+<frac|\<eta\>|2>\<\|\|\>\<nabla\>*f<around|(|x<rsub|s>|)>-<tg><rsub|s>\<\|\|\><rsub|\<ast\>><rsup|2>+<frac|1|2>*<around|(|\<beta\>+1/\<eta\>|)>*<around|\<\|\|\>|x<rsub|s+1>-x<rsub|s>|\<\|\|\>><rsup|2>>>|<row|<cell|>|<cell|\<leq\><tg><rsub|s><rsup|\<top\>>*<around|(|x<rsub|s+1>-x<rsub|s>|)>+<frac|\<eta\>|2>\<\|\|\>\<nabla\>*f<around|(|x<rsub|s>|)>-<tg><rsub|s>\<\|\|\><rsub|\<ast\>><rsup|2>+<around|(|\<beta\>+1/\<eta\>|)>*D<rsub|\<Phi\>>*<around|(|x<rsub|s+1>,x<rsub|s>|)>.>>>>
    </align*>

    Observe that, using the same argument as to derive <eqref|eq:pourplustard1>, one has

    <\equation*>
      <frac|1|\<beta\>+1/\<eta\>>*<tg><rsub|s><rsup|\<top\>>*<around|(|x<rsub|s+1>-x<rsup|\<ast\>>|)>\<leq\>D<rsub|\<Phi\>>*<around|(|x<rsup|\<ast\>>,x<rsub|s>|)>-D<rsub|\<Phi\>>*<around|(|x<rsup|\<ast\>>,x<rsub|s+1>|)>-D<rsub|\<Phi\>>*<around|(|x<rsub|s+1>,x<rsub|s>|)>.
    </equation*>

    Thus

    <\align*>
      <tformat|<table|<row|<cell|>|<cell|f<around|(|x<rsub|s+1>|)>>>|<row|<cell|>|<cell|\<leq\>f<around|(|x<rsub|s>|)>+<tg><rsub|s><rsup|\<top\>>*<around|(|x<rsup|\<ast\>>-x<rsub|s>|)>+<around|(|\<beta\>+1/\<eta\>|)>*<around*|(|D<rsub|\<Phi\>>*<around|(|x<rsup|\<ast\>>,x<rsub|s>|)>-D<rsub|\<Phi\>>*<around|(|x<rsup|\<ast\>>,x<rsub|s+1>|)>|)>>>|<row|<cell|>|<cell|<space|2em>+<frac|\<eta\>|2>*<around|\<\|\|\>|\<nabla\>*f<around|(|x<rsub|s>|)>-<tg><rsub|s>|\<\|\|\>><rsub|\<ast\>><rsup|2>>>|<row|<cell|>|<cell|\<leq\>f<around|(|x<rsup|\<ast\>>|)>+<around|(|<tg><rsub|s>-\<nabla\>*f<around|(|x<rsub|s>|)>|)><rsup|\<top\>>*<around|(|x<rsup|\<ast\>>-x<rsub|s>|)>>>|<row|<cell|>|<cell|<space|2em>+<around|(|\<beta\>+1/\<eta\>|)>*<around*|(|D<rsub|\<Phi\>>*<around|(|x<rsup|\<ast\>>,x<rsub|s>|)>-D<rsub|\<Phi\>>*<around|(|x<rsup|\<ast\>>,x<rsub|s+1>|)>|)>+<frac|\<eta\>|2>*<around|\<\|\|\>|\<nabla\>*f<around|(|x<rsub|s>|)>-<tg><rsub|s>|\<\|\|\>><rsub|\<ast\>><rsup|2>.>>>>
    </align*>

    In particular this yields

    <\equation*>
      <E>*f<around|(|x<rsub|s+1>|)>-f<around|(|x<rsup|\<ast\>>|)>\<leq\><around|(|\<beta\>+1/\<eta\>|)>*<E>*<around*|(|D<rsub|\<Phi\>>*<around|(|x<rsup|\<ast\>>,x<rsub|s>|)>-D<rsub|\<Phi\>>*<around|(|x<rsup|\<ast\>>,x<rsub|s+1>|)>|)>+<frac|\<eta\>*\<sigma\><rsup|2>|2>.
    </equation*>

    By summing this inequality from <math|s=1> to <math|s=t> one can easily conclude with the standard argument.
  </proof>

  We can now propose the following modification of SGD based on the idea of <with|font-shape|italic|mini-batches>. Let <math|m\<in\><N>>, then mini-batch SGD iterates the following equation:

  <\equation*>
    x<rsub|t+1>=\<Pi\><rsub|<cX>>*<around*|(|x<rsub|t>-<frac|\<eta\>|m>*<big|sum><rsub|i=1><rsup|m><tg><rsub|i><around|(|x<rsub|t>|)>|)>.
  </equation*>

  where <math|<tg><rsub|i><around|(|x<rsub|t>|)>,i=1,\<ldots\>,m> are independent random variables (conditionally on <math|x<rsub|t>>) obtained from repeated queries to the stochastic oracle. Assuming that <math|f> is <math|\<beta\>>-smooth and that the stochastic oracle is such that <math|<around|\<\|\|\>|<tg><around|(|x|)>|\<\|\|\>><rsub|2>\<leq\>B>, one can obtain a rate of convergence for mini-batch SGD with Theorem <reference|th:SMDsmooth>. Indeed one can apply this result with the modified stochastic oracle that returns <math|<frac|1|m>*<big|sum><rsub|i=1><rsup|m><tg><rsub|i><around|(|x|)>>, it satisfies

  <\equation*>
    <E>*<around|\<\|\|\>|<frac|1|m>*<big|sum><rsub|i=1><rsup|m><tg><rsub|i><around|(|x|)>-\<nabla\>*f<around|(|x|)>|\<\|\|\>><rsub|2><rsup|2>=<frac|1|m>*<E>*<around|\<\|\|\>|<tg><rsub|1><around|(|x|)>-\<nabla\>*f<around|(|x|)>|\<\|\|\>><rsub|2><rsup|2>\<leq\><frac|2*B<rsup|2>|m>.
  </equation*>

  Thus one obtains that with <math|t> calls to the (original) stochastic oracle, that is <math|t/m> iterations of the mini-batch SGD, one has a suboptimality gap bounded by

  <\equation*>
    R*<sqrt|<frac|2*B<rsup|2>|m>>*<sqrt|<frac|2|t/m>>+<frac|\<beta\>*R<rsup|2>|t/m>=2*<frac|R*B|<sqrt|t>>+<frac|m*\<beta\>*R<rsup|2>|t>.
  </equation*>

  Thus as long as <math|m\<leq\><frac|B|R*\<beta\>>*<sqrt|t>> one obtains, with mini-batch SGD and <math|t> calls to the oracle, a point which is <math|3*<frac|R*B|<sqrt|t>>>-optimal.

  Mini-batch SGD can be a better option than basic SGD in at least two situations: (i) When the computation for an iteration of mini-batch SGD can be distributed between multiple processors. Indeed a central unit can send the message to the processors that estimates of the gradient at point <math|x<rsub|s>> have to be computed, then each processor can work independently and send back the estimate they obtained. (ii) Even in a serial setting mini-batch SGD can sometimes be advantageous, in particular if some calculations can be re-used to compute several estimated gradients at the same point.

  <section|Sum of smooth and strongly convex functions>

  Let us examine in more details the main example from Section <reference|sec:mlapps>. That is one is interested in the unconstrained minimization of

  <\equation*>
    f<around|(|x|)>=<frac|1|m>*<big|sum><rsub|i=1><rsup|m>f<rsub|i><around|(|x|)>,
  </equation*>

  where <math|f<rsub|1>,\<ldots\>,f<rsub|m>> are <math|\<beta\>>-smooth and convex functions, and <math|f> is <math|\<alpha\>>-strongly convex. Typically in machine learning <math|\<alpha\>> can be as small as <math|1/m>, while <math|\<beta\>> is of order of a constant. In other words the condition number <math|\<kappa\>=\<beta\>/\<alpha\>> can be as large as <math|\<Omega\><around|(|m|)>>. Let us now compare the basic gradient descent, that is

  <\equation*>
    x<rsub|t+1>=x<rsub|t>-<frac|\<eta\>|m>*<big|sum><rsub|i=1><rsup|m>\<nabla\>*f<rsub|i><around|(|x|)>,
  </equation*>

  to SGD

  <\equation*>
    x<rsub|t+1>=x<rsub|t>-\<eta\>*\<nabla\>*f<rsub|i<rsub|t>><around|(|x|)>,
  </equation*>

  where <math|i<rsub|t>> is drawn uniformly at random in <math|<around|[|m|]>> (independently of everything else). Theorem <reference|th:gdssc> shows that gradient descent requires <math|O<around|(|m*\<kappa\>*log <around|(|1/\<epsilon\>|)>|)>> gradient computations (which can be improved to <math|O<around|(|m*<sqrt|\<kappa\>>*log <around|(|1/\<epsilon\>|)>|)>> with Nesterov's accelerated gradient descent), while Theorem <reference|th:sgdstrong> shows that SGD (with appropriate averaging) requires <math|O<around|(|1/<around|(|\<alpha\>*\<epsilon\>|)>|)>> gradient computations. Thus one can obtain a low accuracy solution reasonably fast with SGD, but for high accuracy the basic gradient descent is more suitable. Can we get the best of both worlds? This question was answered positively in <cite|LRSB12> with SAG (Stochastic Averaged Gradient) and in <cite|SSZ13> with SDCA (Stochastic Dual Coordinate Ascent). These methods require only <math|O<around|(|<around|(|m+\<kappa\>|)>*log <around|(|1/\<epsilon\>|)>|)>> gradient computations. We describe below the SVRG (Stochastic Variance Reduced Gradient descent) algorithm from <cite|JZ13> which makes the main ideas of SAG and SDCA more transparent (see also <cite|DBLJ14> for more on the relation between these different methods). We also observe that a natural question is whether one can obtain a Nesterov's accelerated version of these algorithms that would need only <math|O<around|(|<around|(|m+<sqrt|m*\<kappa\>>|)>*log <around|(|1/\<epsilon\>|)>|)>>, see <cite|SSZ13b|ZX14|AB14> for recent works on this question.

  To obtain a linear rate of convergence one needs to make “big steps", that is the step-size should be of order of a constant. In SGD the step-size is typically of order <math|1/<sqrt|t>> because of the variance introduced by the stochastic oracle. The idea of SVRG is to “center" the output of the stochastic oracle in order to reduce the variance. Precisely instead of feeding <math|\<nabla\>*f<rsub|i><around|(|x|)>> into the gradient descent one would use <math|\<nabla\>*f<rsub|i><around|(|x|)>-\<nabla\>*f<rsub|i><around|(|y|)>+\<nabla\>*f<around|(|y|)>> where <math|y> is a centering sequence. This is a sensible idea since, when <math|x> and <math|y> are close to the optimum, one should have that <math|\<nabla\>*f<rsub|i><around|(|x|)>-\<nabla\>*f<rsub|i><around|(|y|)>> will have a small variance, and of course <math|\<nabla\>*f<around|(|y|)>> will also be small (note that <math|\<nabla\>*f<rsub|i><around|(|x|)>> by itself is not necessarily small). This intuition is made formal with the following lemma.

  <\lemma>
    <label|lem:SVRG>Let <math|f<rsub|1>,\<ldots\>*f<rsub|m>> be <math|\<beta\>>-smooth convex functions on <math|<R><rsup|n>>, and <math|i> be a random variable uniformly distributed in <math|<around|[|m|]>>. Then

    <\equation*>
      <E>*<around|\<\|\|\>|\<nabla\>*f<rsub|i><around|(|x|)>-\<nabla\>*f<rsub|i><around|(|x<rsup|\<ast\>>|)>|\<\|\|\>><rsub|2><rsup|2>\<leq\>2*\<beta\>*<around|(|f<around|(|x|)>-f<around|(|x<rsup|\<ast\>>|)>|)>.
    </equation*>
  </lemma>

  <\proof>
    Let <math|g<rsub|i><around|(|x|)>=f<rsub|i><around|(|x|)>-f<rsub|i><around|(|x<rsup|\<ast\>>|)>-\<nabla\>*f<rsub|i><around|(|x<rsup|\<ast\>>|)><rsup|\<top\>>*<around|(|x-x<rsup|\<ast\>>|)>>. By convexity of <math|f<rsub|i>> one has <math|g<rsub|i><around|(|x|)>\<geq\>0> for any <math|x> and in particular using <eqref|eq:onestepofgd> this yields <math|-g<rsub|i><around|(|x|)>\<leq\>-<frac|1|2*\<beta\>>*<around|\<\|\|\>|\<nabla\>*g<rsub|i><around|(|x|)>|\<\|\|\>><rsub|2><rsup|2>> which can be equivalently written as

    <\equation*>
      <around|\<\|\|\>|\<nabla\>*f<rsub|i><around|(|x|)>-\<nabla\>*f<rsub|i><around|(|x<rsup|\<ast\>>|)>|\<\|\|\>><rsub|2><rsup|2>\<leq\>2*\<beta\>*<around|(|f<rsub|i><around|(|x|)>-f<rsub|i><around|(|x<rsup|\<ast\>>|)>-\<nabla\>*f<rsub|i><around|(|x<rsup|\<ast\>>|)><rsup|\<top\>>*<around|(|x-x<rsup|\<ast\>>|)>|)>.
    </equation*>

    Taking expectation with respect to <math|i> and observing that <math|<E>\<nabla\>*f<rsub|i><around|(|x<rsup|\<ast\>>|)>=\<nabla\>*f<around|(|x<rsup|\<ast\>>|)>=0> yields the claimed bound.
  </proof>

  On the other hand the computation of <math|\<nabla\>*f<around|(|y|)>> is expensive (it requires <math|m> gradient computations), and thus the centering sequence should be updated more rarely than the main sequence. These ideas lead to the following epoch-based algorithm.

  Let <math|y<rsup|<around|(|1|)>>\<in\><R><rsup|n>> be an arbitrary initial point. For <math|s=1,2*\<ldots\>>, let <math|x<rsub|1><rsup|<around|(|s|)>>=y<rsup|<around|(|s|)>>>. For <math|t=1,\<ldots\>,k> let

  <\equation*>
    x<rsub|t+1><rsup|<around|(|s|)>>=x<rsub|t><rsup|<around|(|s|)>>-\<eta\>*<around*|(|\<nabla\>*f<rsub|i<rsub|t><rsup|<around|(|s|)>>><around|(|x<rsub|t><rsup|<around|(|s|)>>|)>-\<nabla\>*f<rsub|i<rsub|t><rsup|<around|(|s|)>>><around|(|y<rsup|<around|(|s|)>>|)>+\<nabla\>*f<around|(|y<rsup|<around|(|s|)>>|)>|)>,
  </equation*>

  where <math|i<rsub|t><rsup|<around|(|s|)>>> is drawn uniformly at random (and independently of everything else) in <math|<around|[|m|]>>. Also let

  <\equation*>
    y<rsup|<around|(|s+1|)>>=<frac|1|k>*<big|sum><rsub|t=1><rsup|k>x<rsub|t><rsup|<around|(|s|)>>.
  </equation*>

  <\theorem>
    <label|th:SVRG>Let <math|f<rsub|1>,\<ldots\>*f<rsub|m>> be <math|\<beta\>>-smooth convex functions on <math|<R><rsup|n>> and <math|f> be <math|\<alpha\>>-strongly convex. Then SVRG with <math|\<eta\>=<frac|1|10*\<beta\>>> and <math|k=20*\<kappa\>> satisfies

    <\equation*>
      <E>*f<around|(|y<rsup|<around|(|s+1|)>>|)>-f<around|(|x<rsup|\<ast\>>|)>\<leq\>0.9<rsup|s>*<around|(|f<around|(|y<rsup|<around|(|1|)>>|)>-f<around|(|x<rsup|\<ast\>>|)>|)>.
    </equation*>
  </theorem>

  <\proof>
    We fix a phase <math|s\<geq\>1> and we denote by <math|<E>> the expectation taken with respect to <math|i<rsub|1><rsup|<around|(|s|)>>,\<ldots\>,i<rsub|k><rsup|<around|(|s|)>>>. We show below that

    <\equation*>
      <E>*f<around|(|y<rsup|<around|(|s+1|)>>|)>-f<around|(|x<rsup|\<ast\>>|)>=<E>*f*<around*|(|<frac|1|k>*<big|sum><rsub|t=1><rsup|k>x<rsub|t><rsup|<around|(|s|)>>|)>-f<around|(|x<rsup|\<ast\>>|)>\<leq\>0.9*<around|(|f<around|(|y<rsup|<around|(|s|)>>|)>-f<around|(|x<rsup|\<ast\>>|)>|)>,
    </equation*>

    which clearly implies the theorem. To simplify the notation in the following we drop the dependency on <math|s>, that is we want to show that

    <\equation>
      <label|eq:SVRG0><E>*f*<around*|(|<frac|1|k>*<big|sum><rsub|t=1><rsup|k>x<rsub|t>|)>-f<around|(|x<rsup|\<ast\>>|)>\<leq\>0.9*<around|(|f<around|(|y|)>-f<around|(|x<rsup|\<ast\>>|)>|)>.
    </equation>

    We start as for the proof of Theorem <reference|th:gdssc> (analysis of gradient descent for smooth and strongly convex functions) with

    <\equation>
      <label|eq:SVRG1><around|\<\|\|\>|x<rsub|t+1>-x<rsup|\<ast\>>|\<\|\|\>><rsub|2><rsup|2>=<around|\<\|\|\>|x<rsub|t>-x<rsup|\<ast\>>|\<\|\|\>><rsub|2><rsup|2>-2*\<eta\>*v<rsub|t><rsup|\<top\>>*<around|(|x<rsub|t>-x<rsup|\<ast\>>|)>+\<eta\><rsup|2><around|\<\|\|\>|v<rsub|t>|\<\|\|\>><rsub|2><rsup|2>,
    </equation>

    where

    <\equation*>
      v<rsub|t>=\<nabla\>*f<rsub|i<rsub|t>><around|(|x<rsub|t>|)>-\<nabla\>*f<rsub|i<rsub|t>><around|(|y|)>+\<nabla\>*f<around|(|y|)>.
    </equation*>

    Using Lemma <reference|lem:SVRG>, we upper bound <math|<E><rsub|i<rsub|t>><around|\<\|\|\>|v<rsub|t>|\<\|\|\>><rsub|2><rsup|2>> as follows (also recall that <math|<E>*<around|\<\|\|\>|X-<E><around|(|X|)>|\<\|\|\>><rsub|2><rsup|2>\<leq\><E><around|\<\|\|\>|X|\<\|\|\>><rsub|2><rsup|2>>, and <math|<E><rsub|i<rsub|t>>*\<nabla\>*f<rsub|i<rsub|t>><around|(|x<rsup|\<ast\>>|)>=0>):

    <\align>
      <tformat|<table|<row|<cell|>|<cell|<E><rsub|i<rsub|t>><around|\<\|\|\>|v<rsub|t>|\<\|\|\>><rsub|2><rsup|2><eq-number>>>|<row|<cell|>|<cell|\<leq\>2*<E><rsub|i<rsub|t>>*<around|\<\|\|\>|\<nabla\>*f<rsub|i<rsub|t>><around|(|x<rsub|t>|)>-\<nabla\>*f<rsub|i<rsub|t>><around|(|x<rsup|\<ast\>>|)>*<around|\<\|\|\>|<rsub|2><rsup|2>+2*<E><rsub|i<rsub|t>>|\<\|\|\>>*\<nabla\>*f<rsub|i<rsub|t>><around|(|y|)>-\<nabla\>*f<rsub|i<rsub|t>><around|(|x<rsup|\<ast\>>|)>-\<nabla\>*f<around|(|y|)>|\<\|\|\>><rsub|2><rsup|2><eq-number>>>|<row|<cell|>|<cell|\<leq\>2*<E><rsub|i<rsub|t>>*<around|\<\|\|\>|\<nabla\>*f<rsub|i<rsub|t>><around|(|x<rsub|t>|)>-\<nabla\>*f<rsub|i<rsub|t>><around|(|x<rsup|\<ast\>>|)>*<around|\<\|\|\>|<rsub|2><rsup|2>+2*<E><rsub|i<rsub|t>>|\<\|\|\>>*\<nabla\>*f<rsub|i<rsub|t>><around|(|y|)>-\<nabla\>*f<rsub|i<rsub|t>><around|(|x<rsup|\<ast\>>|)>|\<\|\|\>><rsub|2><rsup|2><eq-number>>>|<row|<cell|>|<cell|\<leq\>4*\<beta\>*<around|(|f<around|(|x<rsub|t>|)>-f<around|(|x<rsup|\<ast\>>|)>+f<around|(|y|)>-f<around|(|x<rsup|\<ast\>>|)>|)>.<eq-number><label|eq:SVRG2>>>>>
    </align>

    Also observe that

    <\equation*>
      <E><rsub|i<rsub|t>>*v<rsub|t><rsup|\<top\>>*<around|(|x<rsub|t>-x<rsup|\<ast\>>|)>=\<nabla\>*f<around|(|x<rsub|t>|)><rsup|\<top\>>*<around|(|x<rsub|t>-x<rsup|\<ast\>>|)>\<geq\>f<around|(|x<rsub|t>|)>-f<around|(|x<rsup|\<ast\>>|)>,
    </equation*>

    and thus plugging this into <eqref|eq:SVRG1> together with <eqref|eq:SVRG2> one obtains

    <\eqnarray*>
      <tformat|<table|<row|<cell|<E><rsub|i<rsub|t>>*<around|\<\|\|\>|x<rsub|t+1>-x<rsup|\<ast\>>|\<\|\|\>><rsub|2><rsup|2>>|<cell|\<leq\>>|<cell|<around|\<\|\|\>|x<rsub|t>-x<rsup|\<ast\>>|\<\|\|\>><rsub|2><rsup|2>-2*\<eta\>*<around|(|1-2*\<beta\>*\<eta\>|)>*<around|(|f<around|(|x<rsub|t>|)>-f<around|(|x<rsup|\<ast\>>|)>|)>>>|<row|<cell|>|<cell|>|<cell|+4*\<beta\>*\<eta\><rsup|2>*<around|(|f<around|(|y|)>-f<around|(|x<rsup|\<ast\>>|)>|)>.>>>>
    </eqnarray*>

    Summing the above inequality over <math|t=1,\<ldots\>,k> yields

    <\eqnarray*>
      <tformat|<table|<row|<cell|<E>*<around|\<\|\|\>|x<rsub|k+1>-x<rsup|\<ast\>>|\<\|\|\>><rsub|2><rsup|2>>|<cell|\<leq\>>|<cell|<around|\<\|\|\>|x<rsub|1>-x<rsup|\<ast\>>|\<\|\|\>><rsub|2><rsup|2>-2*\<eta\>*<around|(|1-2*\<beta\>*\<eta\>|)>*<E>*<big|sum><rsub|t=1><rsup|k><around|(|f<around|(|x<rsub|t>|)>-f<around|(|x<rsup|\<ast\>>|)>|)>>>|<row|<cell|>|<cell|>|<cell|+4*\<beta\>*\<eta\><rsup|2>*k*<around|(|f<around|(|y|)>-f<around|(|x<rsup|\<ast\>>|)>|)>.>>>>
    </eqnarray*>

    Noting that <math|x<rsub|1>=y> and that by <math|\<alpha\>>-strong convexity one has <math|f<around|(|x|)>-f<around|(|x<rsup|\<ast\>>|)>\<geq\><frac|\<alpha\>|2>*<around|\<\|\|\>|x-x<rsup|\<ast\>>|\<\|\|\>><rsub|2><rsup|2>>, one can rearrange the above display to obtain

    <\equation*>
      <E>*f*<around*|(|<frac|1|k>*<big|sum><rsub|t=1><rsup|k>x<rsub|t>|)>-f<around|(|x<rsup|\<ast\>>|)>\<leq\><around*|(|<frac|1|\<alpha\>*\<eta\>*<around|(|1-2*\<beta\>*\<eta\>|)>*k>+<frac|2*\<beta\>*\<eta\>|1-2*\<beta\>*\<eta\>>|)>*<around|(|f<around|(|y|)>-f<around|(|x<rsup|\<ast\>>|)>|)>.
    </equation*>

    Using that <math|\<eta\>=<frac|1|10*\<beta\>>> and <math|k=20*\<kappa\>> finally yields <eqref|eq:SVRG0> which itself concludes the proof.
  </proof>

  <section|Random coordinate descent>

  We assume throughout this section that <math|f> is a convex and differentiable function on <math|<R><rsup|n>>, with a unique<footnote|Uniqueness is only assumed for sake of notation.> minimizer <math|x<rsup|\<ast\>>>. We investigate one of the simplest possible scheme to optimize <math|f>, the random coordinate descent (RCD) method. In the following we denote <math|\<nabla\><rsub|i>*f<around|(|x|)>=<frac|\<partial\>*f|\<partial\>*x<rsub|i>><around|(|x|)>>. RCD is defined as follows, with an arbitrary initial point <math|x<rsub|1>\<in\><R><rsup|n>>,

  <\equation*>
    x<rsub|s+1>=x<rsub|s>-\<eta\>*\<nabla\><rsub|i<rsub|s>>*f<around|(|x|)>*e<rsub|i<rsub|s>>,
  </equation*>

  where <math|i<rsub|s>> is drawn uniformly at random from <math|<around|[|n|]>> (and independently of everything else).

  One can view RCD as SGD with the specific oracle <math|<tg><around|(|x|)>=n*\<nabla\><rsub|I>*f<around|(|x|)>*e<rsub|I>> where <math|I> is drawn uniformly at random from <math|<around|[|n|]>>. Clearly <math|<E>*<tg><around|(|x|)>=\<nabla\>*f<around|(|x|)>>, and furthermore

  <\equation*>
    <E><around|\<\|\|\>|<tg><around|(|x|)>|\<\|\|\>><rsub|2><rsup|2>=<frac|1|n>*<big|sum><rsub|i=1><rsup|n><around|\<\|\|\>|n*\<nabla\><rsub|i>*f<around|(|x|)>*e<rsub|i>|\<\|\|\>><rsub|2><rsup|2>=n*<around|\<\|\|\>|\<nabla\>*f<around|(|x|)>|\<\|\|\>><rsub|2><rsup|2>.
  </equation*>

  Thus using Theorem <reference|th:SMD> (with <math|\<Phi\><around|(|x|)>=<frac|1|2><around|\<\|\|\>|x|\<\|\|\>><rsub|2><rsup|2>>, that is S-MD being SGD) one immediately obtains the following result.

  <\theorem>
    Let <math|f> be convex and <math|L>-Lipschitz on <math|<R><rsup|n>>, then RCD with <math|\<eta\>=<frac|R|L>*<sqrt|<frac|2|n*t>>> satisfies

    <\equation*>
      <E>*f*<around*|(|<frac|1|t>*<big|sum><rsub|s=1><rsup|t>x<rsub|s>|)>-min<rsub|x\<in\>\<cal-X\>> f<around|(|x|)>\<leq\>R*L*<sqrt|<frac|2*n|t>>.
    </equation*>
  </theorem>

  Somewhat unsurprisingly RCD requires <math|n> times more iterations than gradient descent to obtain the same accuracy. In the next section, we will see that this statement can be greatly improved by taking into account directional smoothness.

  <subsection|RCD for coordinate-smooth optimization>

  We assume now directional smoothness for <math|f>, that is there exists <math|\<beta\><rsub|1>,\<ldots\>,\<beta\><rsub|n>> such that for any <math|i\<in\><around|[|n|]>,x\<in\><R><rsup|n>> and <math|u\<in\><R>>,

  <\equation*>
    <around|\||\<nabla\><rsub|i>*f*<around|(|x+u*e<rsub|i>|)>-\<nabla\><rsub|i>*f<around|(|x|)>|\|>\<leq\>\<beta\><rsub|i><around|\||u|\|>.
  </equation*>

  If <math|f> is twice differentiable then this is equivalent to <math|<around|(|\<nabla\><rsup|2>*f<around|(|x|)>|)><rsub|i,i>\<leq\>\<beta\><rsub|i>>. In particular, since the maximal eigenvalue of a matrix is upper bounded by its trace, one can see that the directional smoothness implies that <math|f> is <math|\<beta\>>-smooth with <math|\<beta\>\<leq\><big|sum><rsub|i=1><rsup|n>\<beta\><rsub|i>>. We now study the following “aggressive" RCD, where the step-sizes are of order of the inverse smoothness:

  <\equation*>
    x<rsub|s+1>=x<rsub|s>-<frac|1|\<beta\><rsub|i<rsub|s>>>*\<nabla\><rsub|i<rsub|s>>*f<around|(|x|)>*e<rsub|i<rsub|s>>.
  </equation*>

  Furthermore we study a more general sampling distribution than uniform, precisely for <math|\<gamma\>\<geq\>0> we assume that <math|i<rsub|s>> is drawn (independently) from the distribution <math|p<rsub|\<gamma\>>> defined by

  <\equation*>
    p<rsub|\<gamma\>><around|(|i|)>=<frac|\<beta\><rsub|i><rsup|\<gamma\>>|<big|sum><rsub|j=1><rsup|n>\<beta\><rsub|j><rsup|\<gamma\>>>,i\<in\><around|[|n|]>.
  </equation*>

  This algorithm was proposed in <cite|Nes12>, and we denote it by RCD(<math|\<gamma\>>). Observe that, up to a preprocessing step of complexity <math|O<around|(|n|)>>, one can sample from <math|p<rsub|\<gamma\>>> in time <math|O<around|(|log <around|(|n|)>|)>>.

  The following rate of convergence is derived in <cite|Nes12>, using the dual norms <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>><rsub|<around|[|\<gamma\>|]>>,<around|\<\|\|\>|\<cdummy\>|\<\|\|\>><rsub|<around|[|\<gamma\>|]>><rsup|\<ast\>>> defined by

  <\equation*>
    <around|\<\|\|\>|x|\<\|\|\>><rsub|<around|[|\<gamma\>|]>>=<sqrt|<big|sum><rsub|i=1><rsup|n>\<beta\><rsub|i><rsup|\<gamma\>>*x<rsub|i><rsup|2>>,<space|0.27em><space|0.27em><text|and><space|0.27em><space|0.27em><around|\<\|\|\>|x|\<\|\|\>><rsub|<around|[|\<gamma\>|]>><rsup|\<ast\>>=<sqrt|<big|sum><rsub|i=1><rsup|n><frac|1|\<beta\><rsub|i><rsup|\<gamma\>>>*x<rsub|i><rsup|2>>.
  </equation*>

  <\theorem>
    <label|th:rcdgamma>Let <math|f> be convex and such that <math|u\<in\><R>\<mapsto\>f*<around|(|x+u*e<rsub|i>|)>> is <math|\<beta\><rsub|i>>-smooth for any <math|i\<in\><around|[|n|]>,x\<in\><R><rsup|n>>. Then RCD(<math|\<gamma\>>) satisfies for <math|t\<geq\>2>,

    <\equation*>
      <E>*f<around|(|x<rsub|t>|)>-f<around|(|x<rsup|\<ast\>>|)>\<leq\><frac|2*R<rsub|1-\<gamma\>><rsup|2><around|(|x<rsub|1>|)>*<big|sum><rsub|i=1><rsup|n>\<beta\><rsub|i><rsup|\<gamma\>>|t-1>,
    </equation*>

    where

    <\equation*>
      R<rsub|1-\<gamma\>><around|(|x<rsub|1>|)>=sup<rsub|x\<in\><R><rsup|n>:f<around|(|x|)>\<leq\>f<around|(|x<rsub|1>|)>><around|\<\|\|\>|x-x<rsup|\<ast\>>|\<\|\|\>><rsub|<around|[|1-\<gamma\>|]>>.
    </equation*>
  </theorem>

  Recall from Theorem <reference|th:gdsmooth> that in this context the basic gradient descent attains a rate of <math|\<beta\>*<around|\<\|\|\>|x<rsub|1>-x<rsup|\<ast\>>|\<\|\|\>><rsub|2><rsup|2>/t> where <math|\<beta\>\<leq\><big|sum><rsub|i=1><rsup|n>\<beta\><rsub|i>> (see the discussion above). Thus we see that RCD(<math|1>) greatly improves upon gradient descent for functions where <math|\<beta\>> is of order of <math|<big|sum><rsub|i=1><rsup|n>\<beta\><rsub|i>>. Indeed in this case both methods attain the same accuracy after a fixed number of iterations, but the iterations of coordinate descent are potentially much cheaper than the iterations of gradient descent.

  <\proof>
    By applying <eqref|eq:onestepofgd> to the <math|\<beta\><rsub|i>>-smooth function <math|u\<in\><R>\<mapsto\>f*<around|(|x+u*e<rsub|i>|)>> one obtains

    <\equation*>
      f*<around*|(|x-<frac|1|\<beta\><rsub|i>>*\<nabla\><rsub|i>*f<around|(|x|)>*e<rsub|i>|)>-f<around|(|x|)>\<leq\>-<frac|1|2*\<beta\><rsub|i>>*<around|(|\<nabla\><rsub|i>*f<around|(|x|)>|)><rsup|2>.
    </equation*>

    We use this as follows:

    <\eqnarray*>
      <tformat|<table|<row|<cell|<E><rsub|i<rsub|s>>*f<around|(|x<rsub|s+1>|)>-f<around|(|x<rsub|s>|)>>|<cell|=>|<cell|<big|sum><rsub|i=1><rsup|n>p<rsub|\<gamma\>><around|(|i|)>*<around*|(|f*<around*|(|x<rsub|s>-<frac|1|\<beta\><rsub|i>>*\<nabla\><rsub|i>*f<around|(|x<rsub|s>|)>*e<rsub|i>|)>-f<around|(|x<rsub|s>|)>|)>>>|<row|<cell|>|<cell|\<leq\>>|<cell|-<big|sum><rsub|i=1><rsup|n><frac|p<rsub|\<gamma\>><around|(|i|)>|2*\<beta\><rsub|i>>*<around|(|\<nabla\><rsub|i>*f<around|(|x<rsub|s>|)>|)><rsup|2>>>|<row|<cell|>|<cell|=>|<cell|-<frac|1|2*<big|sum><rsub|i=1><rsup|n>\<beta\><rsub|i><rsup|\<gamma\>>><around*|(|<around|\<\|\|\>|\<nabla\>*f<around|(|x<rsub|s>|)>|\<\|\|\>><rsub|<around|[|1-\<gamma\>|]>><rsup|\<ast\>>|)><rsup|2>.>>>>
    </eqnarray*>

    Denote <math|\<delta\><rsub|s>=<E>*f<around|(|x<rsub|s>|)>-f<around|(|x<rsup|\<ast\>>|)>>. Observe that the above calculation can be used to show that <math|f<around|(|x<rsub|s+1>|)>\<leq\>f<around|(|x<rsub|s>|)>> and thus one has, by definition of <math|R<rsub|1-\<gamma\>><around|(|x<rsub|1>|)>>,

    <\eqnarray*>
      <tformat|<table|<row|<cell|\<delta\><rsub|s>>|<cell|\<leq\>>|<cell|\<nabla\>*f<around|(|x<rsub|s>|)><rsup|\<top\>>*<around|(|x<rsub|s>-x<rsup|\<ast\>>|)>>>|<row|<cell|>|<cell|\<leq\>>|<cell|<around|\<\|\|\>|x<rsub|s>-x<rsup|\<ast\>>|\<\|\|\>><rsub|<around|[|1-\<gamma\>|]>>*<around|\<\|\|\>|\<nabla\>*f<around|(|x<rsub|s>|)>|\<\|\|\>><rsub|<around|[|1-\<gamma\>|]>><rsup|\<ast\>>>>|<row|<cell|>|<cell|\<leq\>>|<cell|R<rsub|1-\<gamma\>><around|(|x<rsub|1>|)>*<around|\<\|\|\>|\<nabla\>*f<around|(|x<rsub|s>|)>|\<\|\|\>><rsub|<around|[|1-\<gamma\>|]>><rsup|\<ast\>>.>>>>
    </eqnarray*>

    Thus putting together the above calculations one obtains

    <\equation*>
      \<delta\><rsub|s+1>\<leq\>\<delta\><rsub|s>-<frac|1|2*R<rsub|1-\<gamma\>><rsup|2><around|(|x<rsub|1>|)>*<big|sum><rsub|i=1><rsup|n>\<beta\><rsub|i><rsup|\<gamma\>>>*\<delta\><rsub|s><rsup|2>.
    </equation*>

    The proof can be concluded with similar computations than for Theorem <reference|th:gdsmooth>.
  </proof>

  We discussed above the specific case of <math|\<gamma\>=1>. Both <math|\<gamma\>=0> and <math|\<gamma\>=1/2> also have an interesting behavior, and we refer to <cite|Nes12> for more details. The latter paper also contains a discussion of high probability results and potential acceleration à la Nesterov. We also refer to <cite|RT12> for a discussion of RCD in a distributed setting.

  <subsection|RCD for smooth and strongly convex optimization>

  If in addition to directional smoothness one also assumes strong convexity, then RCD attains in fact a linear rate.

  <\theorem>
    <label|th:linearratercd>Let <math|\<gamma\>\<geq\>0>. Let <math|f> be <math|\<alpha\>>-strongly convex w.r.t. <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>><rsub|<around|[|1-\<gamma\>|]>>>, and such that <math|u\<in\><R>\<mapsto\>f*<around|(|x+u*e<rsub|i>|)>> is <math|\<beta\><rsub|i>>-smooth for any <math|i\<in\><around|[|n|]>,x\<in\><R><rsup|n>>. Let <math|\<kappa\><rsub|\<gamma\>>=<frac|<big|sum><rsub|i=1><rsup|n>\<beta\><rsub|i><rsup|\<gamma\>>|\<alpha\>>>, then RCD(<math|\<gamma\>>) satisfies

    <\equation*>
      <E>*f<around|(|x<rsub|t+1>|)>-f<around|(|x<rsup|\<ast\>>|)>\<leq\><around*|(|1-<frac|1|\<kappa\><rsub|\<gamma\>>>|)><rsup|t>*<around|(|f<around|(|x<rsub|1>|)>-f<around|(|x<rsup|\<ast\>>|)>|)>.
    </equation*>
  </theorem>

  We use the following elementary lemma.

  <\lemma>
    <label|lem:tittrucnes>Let <math|f> be <math|\<alpha\>>-strongly convex w.r.t. <math|<around|\<\|\|\>|\<cdummy\>|\<\|\|\>>> on <math|<R><rsup|n>>, then

    <\equation*>
      f<around|(|x|)>-f<around|(|x<rsup|\<ast\>>|)>\<leq\><frac|1|2*\<alpha\>>*<around|\<\|\|\>|\<nabla\>*f<around|(|x|)>|\<\|\|\>><rsub|\<ast\>><rsup|2>.
    </equation*>
  </lemma>

  <\proof>
    By strong convexity, Hölder's inequality, and an elementary calculation,

    <\eqnarray*>
      <tformat|<table|<row|<cell|f<around|(|x|)>-f<around|(|y|)>>|<cell|\<leq\>>|<cell|\<nabla\>*f<around|(|x|)><rsup|\<top\>>*<around|(|x-y|)>-<frac|\<alpha\>|2>*<around|\<\|\|\>|x-y|\<\|\|\>><rsub|2><rsup|2>>>|<row|<cell|>|<cell|\<leq\>>|<cell|<around|\<\|\|\>|\<nabla\>*f<around|(|x|)><around|\<\|\|\>|<rsub|\<ast\>>|\<\|\|\>>*x-y|\<\|\|\>>-<frac|\<alpha\>|2>*<around|\<\|\|\>|x-y|\<\|\|\>><rsub|2><rsup|2>>>|<row|<cell|>|<cell|\<leq\>>|<cell|<frac|1|2*\<alpha\>>*<around|\<\|\|\>|\<nabla\>*f<around|(|x|)>|\<\|\|\>><rsub|\<ast\>><rsup|2>,>>>>
    </eqnarray*>

    which concludes the proof by taking <math|y=x<rsup|\<ast\>>>.
  </proof>

  We can now prove Theorem <reference|th:linearratercd>.

  <\proof>
    In the proof of Theorem <reference|th:rcdgamma> we showed that

    <\equation*>
      \<delta\><rsub|s+1>\<leq\>\<delta\><rsub|s>-<frac|1|2*<big|sum><rsub|i=1><rsup|n>\<beta\><rsub|i><rsup|\<gamma\>>><around*|(|<around|\<\|\|\>|\<nabla\>*f<around|(|x<rsub|s>|)>|\<\|\|\>><rsub|<around|[|1-\<gamma\>|]>><rsup|\<ast\>>|)><rsup|2>.
    </equation*>

    On the other hand Lemma <reference|lem:tittrucnes> shows that

    <\equation*>
      <around*|(|<around|\<\|\|\>|\<nabla\>*f<around|(|x<rsub|s>|)>|\<\|\|\>><rsub|<around|[|1-\<gamma\>|]>><rsup|\<ast\>>|)><rsup|2>\<geq\>2*\<alpha\>*\<delta\><rsub|s>.
    </equation*>

    The proof is concluded with straightforward calculations.
  </proof>

  <section|Acceleration by randomization for saddle points>

  We explore now the use of randomness for saddle point computations. That is we consider the context of Section <reference|sec:sp> with a stochastic oracle of the following form: given <math|z=<around|(|x,y|)>\<in\><cX>\<times\><cY>> it outputs <math|<tg><around|(|z|)>=<around|(|<tg><rsub|<cX>>*<around|(|x,y|)>,<tg><rsub|<cY>>*<around|(|x,y|)>|)>> where <math|<E><around|(|<tg><rsub|<cX>>*<around|(|x,y|)>\|x,y|)>\<in\>\<partial\><rsub|x>*\<phi\>*<around|(|x,y|)>>, and <math|<E><around|(|<tg><rsub|<cY>>*<around|(|x,y|)>\|x,y|)>\<in\>\<partial\><rsub|y>*<around|(|-\<phi\>*<around|(|x,y|)>|)>>. Instead of using true subgradients as in SP-MD (see Section <reference|sec:spmd>) we use here the outputs of the stochastic oracle. We refer to the resulting algorithm as S-SP-MD (Stochastic Saddle Point Mirror Descent). Using the same reasoning than in Section <reference|sec:smd> and Section <reference|sec:spmd> one can derive the following theorem.

  <\theorem>
    <label|th:sspmd>Assume that the stochastic oracle is such that <math|<E><around*|(|<around|\<\|\|\>|<tg><rsub|<cX>>*<around|(|x,y|)>|\<\|\|\>><rsub|<cX>><rsup|\<ast\>>|)><rsup|2>\<leq\>B<rsub|<cX>><rsup|2>>, and <math|<E><around*|(|<around|\<\|\|\>|<tg><rsub|<cY>>*<around|(|x,y|)>|\<\|\|\>><rsub|<cY>><rsup|\<ast\>>|)><rsup|2>\<leq\>B<rsub|<cY>><rsup|2>>. Then S-SP-MD with <math|a=<frac|B<rsub|<cX>>|R<rsub|<cX>>>>, <math|b=<frac|B<rsub|<cY>>|R<rsub|<cY>>>>, and <math|\<eta\>=<sqrt|<frac|2|t>>> satisfies

    <\equation*>
      <E>*<around*|(|max<rsub|y\<in\>\<cal-Y\>> \<phi\>*<around*|(|<frac|1|t>*<big|sum><rsub|s=1><rsup|t>x<rsub|s>,y|)>-min<rsub|x\<in\>\<cal-X\>> \<phi\>*<around*|(|x,<frac|1|t>*<big|sum><rsub|s=1><rsup|t>y<rsub|s>|)>|)>\<leq\><around|(|R<rsub|<cX>>*B<rsub|<cX>>+R<rsub|<cY>>*B<rsub|<cY>>|)>*<sqrt|<frac|2|t>>.
    </equation*>
  </theorem>

  Using S-SP-MD we revisit the examples of Section <reference|sec:spex2> and Section <reference|sec:spex3>. In both cases one has <math|\<phi\>*<around|(|x,y|)>=x<rsup|\<top\>>*A*y> (with <math|A<rsub|i>> being the <math|i<rsup|t*h>> column of <math|A>), and thus <math|\<nabla\><rsub|x>*\<phi\>*<around|(|x,y|)>=A*y> and <math|\<nabla\><rsub|y>*\<phi\>*<around|(|x,y|)>=A<rsup|\<top\>>*x>.

  <no-indent><with|font-series|bold|Matrix games.> Here <math|x\<in\>\<Delta\><rsub|n>> and <math|y\<in\>\<Delta\><rsub|m>>. Thus there is a quite natural stochastic oracle:

  <\equation>
    <label|eq:oraclematrixgame><tg><rsub|<cX>>*<around|(|x,y|)>=A<rsub|I>,<space|0.27em><text|where><space|0.27em>I\<in\><around|[|m|]>*<space|0.27em><text|is drawn according to><space|0.27em>y\<in\>\<Delta\><rsub|m>,
  </equation>

  and <math|\<forall\>i\<in\><around|[|m|]>>,

  <\equation>
    <label|eq:oraclematrixgame2><tg><rsub|<cY>>*<around|(|x,y|)><around|(|i|)>=A<rsub|i><around|(|J|)>,<space|0.27em><text|where><space|0.27em>J\<in\><around|[|n|]>*<space|0.27em><text|is drawn according to><space|0.27em>x\<in\>\<Delta\><rsub|n>.
  </equation>

  Clearly <math|<around|\<\|\|\>|<tg><rsub|<cX>>*<around|(|x,y|)>|\<\|\|\>><rsub|\<infty\>>\<leq\><around|\<\|\|\>|A|\<\|\|\>><rsub|<math-up|max>>> and <math|<around|\<\|\|\>|<tg><rsub|<cX>>*<around|(|x,y|)>|\<\|\|\>><rsub|\<infty\>>\<leq\><around|\<\|\|\>|A|\<\|\|\>><rsub|<math-up|max>>>, which implies that S-SP-MD attains an <math|\<epsilon\>>-optimal pair of points with <math|O<around*|(|<around|\<\|\|\>|A|\<\|\|\>><rsub|<math-up|max>><rsup|2>*log <around|(|n+m|)>/\<epsilon\><rsup|2>|)>> iterations. Furthermore the computational complexity of a step of S-SP-MD is dominated by drawing the indices <math|I> and <math|J> which takes <math|O<around|(|n+m|)>>. Thus overall the complexity of getting an <math|\<epsilon\>>-optimal Nash equilibrium with S-SP-MD is <math|O<around*|(|<around|\<\|\|\>|A|\<\|\|\>><rsub|<math-up|max>><rsup|2>*<around|(|n+m|)>*log <around|(|n+m|)>/\<epsilon\><rsup|2>|)>>. While the dependency on <math|\<epsilon\>> is worse than for SP-MP (see Section <reference|sec:spex2>), the dependencies on the dimensions is <math|<wide|O|~><around|(|n+m|)>> instead of <math|<wide|O|~><around|(|n*m|)>>. In particular, quite astonishingly, this is <with|font-shape|italic|sublinear> in the size of the matrix <math|A>. The possibility of sublinear algorithms for this problem was first observed in <cite|GK95>.

  <no-indent><with|font-series|bold|Linear classification.> Here <math|x\<in\><mB><rsub|2,n>> and <math|y\<in\>\<Delta\><rsub|m>>. Thus the stochastic oracle for the <math|x>-subgradient can be taken as in <eqref|eq:oraclematrixgame> but for the <math|y>-subgradient we modify <eqref|eq:oraclematrixgame2> as follows. For a vector <math|x> we denote by <math|x<rsup|2>> the vector such that <math|x<rsup|2><around|(|i|)>=x<around|(|i|)><rsup|2>>. For all <math|i\<in\><around|[|m|]>>,

  <\equation*>
    <tg><rsub|<cY>>*<around|(|x,y|)><around|(|i|)>=<frac|<around|\<\|\|\>|x|\<\|\|\>><rsup|2>|x<around|(|j|)>>*A<rsub|i><around|(|J|)>,<space|0.27em><text|where><space|0.27em>J\<in\><around|[|n|]><space|0.27em><text|is drawn according to><space|0.27em><frac|x<rsup|2>|<around|\<\|\|\>|x|\<\|\|\>><rsub|2><rsup|2>>\<in\>\<Delta\><rsub|n>.
  </equation*>

  Note that one indeed has <math|<E><around|(|<tg><rsub|<cY>>*<around|(|x,y|)><around|(|i|)>\|x,y|)>=<big|sum><rsub|j=1><rsup|n>x<around|(|j|)>*A<rsub|i><around|(|j|)>=<around|(|A<rsup|\<top\>>*x|)><around|(|i|)>>. Furthermore <math|<around|\<\|\|\>|<tg><rsub|<cX>>*<around|(|x,y|)>|\<\|\|\>><rsub|2>\<leq\>B>, and

  <\equation*>
    <E><around|(|<around|\<\|\|\>|<tg><rsub|<cY>>*<around|(|x,y|)>|\<\|\|\>><rsub|\<infty\>><rsup|2>\|x,y|)>=<big|sum><rsub|j=1><rsup|n><frac|x<around|(|j|)><rsup|2>|<around|\<\|\|\>|x|\<\|\|\>><rsub|2><rsup|2>>*max<rsub|i\<in\><around|[|m|]>><around*|(|<frac|<around|\<\|\|\>|x|\<\|\|\>><rsup|2>|x<around|(|j|)>>*A<rsub|i><around|(|j|)>|)><rsup|2>\<leq\><big|sum><rsub|j=1><rsup|n>max<rsub|i\<in\><around|[|m|]>> A<rsub|i><around|(|j|)><rsup|2>.
  </equation*>

  Unfortunately this last term can be <math|O<around|(|n|)>>. However it turns out that one can do a more careful analysis of mirror descent in terms of local norms, which allows to prove that the “local variance" is dimension-free. We refer to <cite|BC12> for more details on these local norms, and to <cite|CHW12> for the specific details in the linear classification situation.

  <section|Convex relaxation and randomized rounding><label|sec:convexrelaxation>

  In this section we briefly discuss the concept of convex relaxation, and the use of randomization to find approximate solutions. By now there is an enormous literature on these topics, and we refer to <cite|Bar14> for further pointers.

  We study here the seminal example of <math|<math-up|MAXCUT>>. This problem can be described as follows. Let <math|A\<in\><R><rsub|+><rsup|n\<times\>n>> be a symmetric matrix of non-negative weights. The entry <math|A<rsub|i,j>> is interpreted as a measure of the “dissimilarity" between point <math|i> and point <math|j>. The goal is to find a partition of <math|<around|[|n|]>> into two sets, <math|S\<subset\><around|[|n|]>> and <math|S<rsup|c>>, so as to maximize the total dissimilarity between the two groups: <math|<big|sum><rsub|i\<in\>S,j\<in\>S<rsup|c>>A<rsub|i,j>>. Equivalently <math|<math-up|MAXCUT>> corresponds to the following optimization problem:

  <\equation>
    <label|eq:maxcut1>max<rsub|x\<in\><around|{|-1,1|}><rsup|n>> <frac|1|2>*<big|sum><rsub|i,j=1><rsup|n>A<rsub|i,j>*<around|(|x<rsub|i>-x<rsub|j>|)><rsup|2>.
  </equation>

  Viewing <math|A> as the (weighted) adjacency matrix of a graph, one can rewrite <eqref|eq:maxcut1> as follows, using the graph Laplacian <math|L=D-A> where <math|D> is the diagonal matrix with entries <math|<around|(|<big|sum><rsub|j=1><rsup|n>A<rsub|i,j>|)><rsub|i\<in\><around|[|n|]>>>,

  <\equation>
    <label|eq:maxcut2>max<rsub|x\<in\><around|{|-1,1|}><rsup|n>> x<rsup|\<top\>>*L*x.
  </equation>

  It turns out that this optimization problem is <math|<math-bf|NP>>-hard, that is the existence of a polynomial time algorithm to solve <eqref|eq:maxcut2> would prove that <math|<math-bf|P>=<math-bf|NP>>. The combinatorial difficulty of this problem stems from the hypercube constraint. Indeed if one replaces <math|<around|{|-1,1|}><rsup|n>> by the Euclidean sphere, then one obtains an efficiently solvable problem (it is the problem of computing the maximal eigenvalue of <math|L>).

  We show now that, while <eqref|eq:maxcut2> is a difficult optimization problem, it is in fact possible to find relatively good <with|font-shape|italic|approximate> solutions by using the power of randomization. Let <math|\<zeta\>> be uniformly drawn on the hypercube <math|<around|{|-1,1|}><rsup|n>>, then clearly

  <\equation*>
    <E>*\<zeta\><rsup|\<top\>>*L*\<zeta\>=<big|sum><rsub|i,j=1,i\<neq\>j><rsup|n>A<rsub|i,j>\<geq\><frac|1|2>*max<rsub|x\<in\><around|{|-1,1|}><rsup|n>> x<rsup|\<top\>>*L*x.
  </equation*>

  This means that, on average, <math|\<zeta\>> is a <math|1/2>-approximate solution to <eqref|eq:maxcut2>. Furthermore it is immediate that the above expectation bound implies that, with probability at least <math|\<epsilon\>>, <math|\<zeta\>> is a <math|<around|(|1/2-\<epsilon\>|)>>-approximate solution. Thus by repeatedly sampling uniformly from the hypercube one can get arbitrarily close (with probability approaching <math|1>) to a <math|1/2>-approximation of <math|<math-up|MAXCUT>>.

  Next we show that one can obtain an even better approximation ratio by combining the power of convex optimization and randomization. This approach was pioneered by <cite|GW95>. The Goemans-Williamson algorithm is based on the following inequality

  <\equation*>
    max<rsub|x\<in\><around|{|-1,1|}><rsup|n>> x<rsup|\<top\>>*L*x=max<rsub|x\<in\><around|{|-1,1|}><rsup|n>><around|\<langle\>|L,x*x<rsup|\<top\>>|\<rangle\>>\<leq\>max<rsub|X\<in\>\<bbb-S\><rsub|+><rsup|n>,X<rsub|i,i>=1,i\<in\><around|[|n|]>><around|\<langle\>|L,X|\<rangle\>>.
  </equation*>

  The right hand side in the above display is known as the <with|font-shape|italic|convex (or SDP) relaxation> of <math|<math-up|MAXCUT>>. The convex relaxation is an SDP and thus one can find its solution efficiently with Interior Point Methods (see Section <reference|sec:IPM>). The following result states both the Goemans-Williamson strategy and the corresponding approximation ratio.

  <\theorem>
    <label|th:GW>Let <math|\<Sigma\>> be the solution to the SDP relaxation of <math|<math-up|MAXCUT>>. Let <math|\<xi\>\<sim\><cN><around|(|0,\<Sigma\>|)>> and <math|\<zeta\>=<math-up|sign><around|(|\<xi\>|)>\<in\><around|{|-1,1|}><rsup|n>>. Then

    <\equation*>
      <E>*\<zeta\><rsup|\<top\>>*L*\<zeta\>\<geq\>0.878*max<rsub|x\<in\><around|{|-1,1|}><rsup|n>> x<rsup|\<top\>>*L*x.
    </equation*>
  </theorem>

  The proof of this result is based on the following elementary geometric lemma.

  <\lemma>
    <label|lem:GW>Let <math|\<xi\>\<sim\>\<cal-N\><around|(|0,\<Sigma\>|)>> with <math|\<Sigma\><rsub|i,i>=1> for <math|i\<in\><around|[|n|]>>, and <math|\<zeta\>=<math-up|sign><around|(|\<xi\>|)>>. Then

    <\equation*>
      <E>*\<zeta\><rsub|i>*\<zeta\><rsub|j>=<frac|2|\<pi\>><math-up|arcsin><around*|(|\<Sigma\><rsub|i,j>|)>.
    </equation*>
  </lemma>

  <\proof>
    Let <math|V\<in\><R><rsup|n\<times\>n>> (with <math|i<rsup|t*h>> row <math|V<rsub|i><rsup|\<top\>>>) be such that <math|\<Sigma\>=V*V<rsup|\<top\>>>. Note that since <math|\<Sigma\><rsub|i,i>=1> one has <math|<around|\<\|\|\>|V<rsub|i>|\<\|\|\>><rsub|2>=1> (remark also that necessarily <math|<around|\||\<Sigma\><rsub|i,j>|\|>\<leq\>1>, which will be important in the proof of Theorem <reference|th:GW>). Let <math|\<epsilon\>\<sim\>\<cal-N\><around|(|0,<mI><rsub|n>|)>> be such that <math|\<xi\>=V*\<epsilon\>>. Then <math|\<zeta\><rsub|i>=<math-up|sign><around|(|V<rsub|i><rsup|\<top\>>*\<epsilon\>|)>>, and in particular

    <\eqnarray*>
      <tformat|<table|<row|<cell|<E>*\<zeta\><rsub|i>*\<zeta\><rsub|j>>|<cell|=>|<cell|<paragraphsign><around|(|V<rsub|i><rsup|\<top\>>*\<epsilon\>\<geq\>0*<text|and>V<rsub|j><rsup|\<top\>>*\<epsilon\>\<geq\>0|)>+<paragraphsign>(V<rsub|i><rsup|\<top\>>*\<epsilon\>\<leq\>0*<text|and>V<rsub|j><rsup|\<top\>>*\<epsilon\>\<leq\>0>>|<row|<cell|>|<cell|>|<cell|-<paragraphsign><around|(|V<rsub|i><rsup|\<top\>>*\<epsilon\>\<geq\>0*<text|and>V<rsub|j><rsup|\<top\>>*\<epsilon\>\<less\>0|)>-<paragraphsign><around|(|V<rsub|i><rsup|\<top\>>*\<epsilon\>\<less\>0*<text|and>V<rsub|j><rsup|\<top\>>*\<epsilon\>\<geq\>0|)>>>|<row|<cell|>|<cell|=>|<cell|2<paragraphsign><around|(|V<rsub|i><rsup|\<top\>>*\<epsilon\>\<geq\>0*<text|and>V<rsub|j><rsup|\<top\>>*\<epsilon\>\<geq\>0|)>-2<paragraphsign><around|(|V<rsub|i><rsup|\<top\>>*\<epsilon\>\<geq\>0*<text|and>V<rsub|j><rsup|\<top\>>*\<epsilon\>\<less\>0|)>>>|<row|<cell|>|<cell|=>|<cell|<paragraphsign><around|(|V<rsub|j><rsup|\<top\>>*\<epsilon\>\<geq\>0\|V<rsub|i><rsup|\<top\>>*\<epsilon\>\<geq\>0|)>-<paragraphsign><around|(|V<rsub|j><rsup|\<top\>>*\<epsilon\>\<less\>0\|V<rsub|i><rsup|\<top\>>*\<epsilon\>\<geq\>0|)>>>|<row|<cell|>|<cell|=>|<cell|1-2<paragraphsign><around|(|V<rsub|j><rsup|\<top\>>*\<epsilon\>\<less\>0\|V<rsub|i><rsup|\<top\>>*\<epsilon\>\<geq\>0|)>.>>>>
    </eqnarray*>

    Now a quick picture shows that <math|<paragraphsign><around|(|V<rsub|j><rsup|\<top\>>*\<epsilon\>\<less\>0\|V<rsub|i><rsup|\<top\>>*\<epsilon\>\<geq\>0|)>=<frac|1|\<pi\>><math-up|arccos><around|(|V<rsub|i><rsup|\<top\>>*V<rsub|j>|)>> (recall that <math|\<epsilon\>/<around|\<\|\|\>|\<epsilon\>|\<\|\|\>><rsub|2>> is uniform on the Euclidean sphere). Using the fact that <math|V<rsub|i><rsup|\<top\>>*V<rsub|j>=\<Sigma\><rsub|i,j>> and <math|<math-up|arccos><around|(|x|)>=<frac|\<pi\>|2>-<math-up|arcsin><around|(|x|)>> conclude the proof.
  </proof>

  We can now get to the proof of Theorem <reference|th:GW>.

  <\proof>
    We shall use the following inequality:

    <\equation>
      <label|eq:dependsonL>1-<frac|2|\<pi\>><math-up|arcsin><around|(|t|)>\<geq\>0.878*<around|(|1-t|)>,\<forall\>t\<in\><around|[|-1,1|]>.
    </equation>

    Also remark that for <math|X\<in\><R><rsup|n\<times\>n>> such that <math|X<rsub|i,i>=1>, one has

    <\equation*>
      <around|\<langle\>|L,X|\<rangle\>>=<big|sum><rsub|i,j=1><rsup|n>A<rsub|i,j>*<around|(|1-X<rsub|i,j>|)>,
    </equation*>

    and in particular for <math|x\<in\><around|{|-1,1|}><rsup|n>>, <math|x<rsup|\<top\>>*L*x=<big|sum><rsub|i,j=1><rsup|n>A<rsub|i,j>*<around|(|1-x<rsub|i>*x<rsub|j>|)>>. Thus, using Lemma <reference|lem:GW>, and the facts that <math|A<rsub|i,j>\<geq\>0> and <math|<around|\||\<Sigma\><rsub|i,j>|\|>\<leq\>1> (see the proof of Lemma <reference|lem:GW>), one has

    <\eqnarray*>
      <tformat|<table|<row|<cell|<E>*\<zeta\><rsup|\<top\>>*L*\<zeta\>>|<cell|=>|<cell|<big|sum><rsub|i,j=1><rsup|n>A<rsub|i,j>*<around*|(|1-<frac|2|\<pi\>><math-up|arcsin><around*|(|\<Sigma\><rsub|i,j>|)>|)>>>|<row|<cell|>|<cell|\<geq\>>|<cell|0.878*<big|sum><rsub|i,j=1><rsup|n>A<rsub|i,j>*<around*|(|1-\<Sigma\><rsub|i,j>|)>>>|<row|<cell|>|<cell|=>|<cell|0.878*max<rsub|X\<in\>\<bbb-S\><rsub|+><rsup|n>,X<rsub|i,i>=1,i\<in\><around|[|n|]>><around|\<langle\>|L,X|\<rangle\>>>>|<row|<cell|>|<cell|\<geq\>>|<cell|0.878*max<rsub|x\<in\><around|{|-1,1|}><rsup|n>> x<rsup|\<top\>>*L*x.>>>>
    </eqnarray*>
  </proof>

  Theorem <reference|th:GW> depends on the form of the Laplacian <math|L> (insofar as <eqref|eq:dependsonL> was used). We show next a result from <cite|Nes97> that applies to any positive semi-definite matrix, at the expense of the constant of approximation. Precisely we are now interested in the following optimization problem:

  <\equation>
    <label|eq:quad>max<rsub|x\<in\><around|{|-1,1|}><rsup|n>> x<rsup|\<top\>>*B*x.
  </equation>

  The corresponding SDP relaxation is

  <\equation*>
    max<rsub|X\<in\>\<bbb-S\><rsub|+><rsup|n>,X<rsub|i,i>=1,i\<in\><around|[|n|]>><around|\<langle\>|B,X|\<rangle\>>.
  </equation*>

  <\theorem>
    Let <math|\<Sigma\>> be the solution to the SDP relaxation of <eqref|eq:quad>. Let <math|\<xi\>\<sim\><cN><around|(|0,\<Sigma\>|)>> and <math|\<zeta\>=<math-up|sign><around|(|\<xi\>|)>\<in\><around|{|-1,1|}><rsup|n>>. Then

    <\equation*>
      <E>*\<zeta\><rsup|\<top\>>*B*\<zeta\>\<geq\><frac|2|\<pi\>>*max<rsub|x\<in\><around|{|-1,1|}><rsup|n>> x<rsup|\<top\>>*B*x.
    </equation*>
  </theorem>

  <\proof>
    Lemma <reference|lem:GW> shows that

    <\equation*>
      <E>*\<zeta\><rsup|\<top\>>*B*\<zeta\>=<big|sum><rsub|i,j=1><rsup|n>B<rsub|i,j>*<frac|2|\<pi\>><math-up|arcsin><around*|(|X<rsub|i,j>|)>=<frac|2|\<pi\>>*<around|\<langle\>|B,<math-up|arcsin><around|(|X|)>|\<rangle\>>.
    </equation*>

    Thus to prove the result it is enough to show that <math|<around|\<langle\>|B,<math-up|arcsin><around|(|\<Sigma\>|)>|\<rangle\>>\<geq\><around|\<langle\>|B,\<Sigma\>|\<rangle\>>>, which is itself implied by <math|<math-up|arcsin><around|(|\<Sigma\>|)>\<succeq\>\<Sigma\>> (the implication is true since <math|B> is positive semi-definite, just write the eigendecomposition). Now we prove the latter inequality via a Taylor expansion. Indeed recall that <math|<around|\||\<Sigma\><rsub|i,j>|\|>\<leq\>1> and thus denoting by <math|A<rsup|\<circ\>\<alpha\>>> the matrix where the entries are raised to the power <math|\<alpha\>> one has

    <\equation*>
      <math-up|arcsin><around|(|\<Sigma\>|)>=<big|sum><rsub|k=0><rsup|+\<infty\>><frac|<choose|2*k|k>|4<rsup|k>*<around|(|2*k+1|)>>*\<Sigma\><rsup|\<circ\><around|(|2*k+1|)>>=\<Sigma\>+<big|sum><rsub|k=1><rsup|+\<infty\>><frac|<choose|2*k|k>|4<rsup|k>*<around|(|2*k+1|)>>*\<Sigma\><rsup|\<circ\><around|(|2*k+1|)>>.
    </equation*>

    Finally one can conclude using the fact if <math|A,B\<succeq\>0> then <math|A\<circ\>B\<succeq\>0>. This can be seen by writing <math|A=V*V<rsup|\<top\>>>, <math|B=U*U<rsup|\<top\>>>, and thus

    <\equation*>
      <around|(|A\<circ\>B|)><rsub|i,j>=V<rsub|i><rsup|\<top\>>*V<rsub|j>*U<rsub|i><rsup|\<top\>>*U<rsub|j>=<math-up|Tr><around|(|U<rsub|j>*V<rsub|j><rsup|\<top\>>*V<rsub|i>*U<rsub|i><rsup|\<top\>>|)>=<around|\<langle\>|V<rsub|i>*U<rsub|i><rsup|\<top\>>,V<rsub|j>*U<rsub|j><rsup|\<top\>>|\<rangle\>>.
    </equation*>

    In other words <math|A\<circ\>B> is a Gram-matrix and, thus it is positive semi-definite.
  </proof>

  <section|Random walk based methods><label|sec:rwmethod>

  Randomization naturally suggests itself in the center of gravity method (see Section <reference|sec:gravity>), as a way to circumvent the exact calculation of the center of gravity. This idea was proposed and developed in <cite|BerVem04>. We give below a condensed version of the main ideas of this paper.

  Assuming that one can draw independent points <math|X<rsub|1>,\<ldots\>,X<rsub|N>> uniformly at random from the current set <math|<cS><rsub|t>>, one could replace <math|c<rsub|t>> by <math|<wide|c|^><rsub|t>=<frac|1|N>*<big|sum><rsub|i=1><rsup|N>X<rsub|i>>. <cite|BerVem04> proved the following generalization of Lemma <reference|lem:Gru60> for the situation where one cuts a convex set through a point close the center of gravity. Recall that a convex set <math|<cK>> is in isotropic position if <math|<E>*X=0> and <math|<E>*X*X<rsup|\<top\>>=<mI><rsub|n>>, where <math|X> is a random variable drawn uniformly at random from <math|<cK>>. Note in particular that this implies <math|<E><around|\<\|\|\>|X|\<\|\|\>><rsub|2><rsup|2>=n>. We also say that <math|<cK>> is in near-isotropic position if <math|<frac|1|2><mI><rsub|n>\<preceq\><E>*X*X<rsup|\<top\>>\<preceq\><frac|3|2><mI><rsub|n>>.

  <\lemma>
    <label|lem:BerVem04>Let <math|<cK>> be a convex set in isotropic position. Then for any <math|w\<in\><R><rsup|n>,w\<neq\>0>, <math|z\<in\><R><rsup|n>>, one has

    <\equation*>
      <math-up|Vol><around*|(|<cK>\<cap\><around|{|x\<in\><R><rsup|n>:<around|(|x-z|)><rsup|\<top\>>*w\<geq\>0|}>|)>\<geq\><around*|(|<frac|1|e>-<around|\<\|\|\>|z|\<\|\|\>><rsub|2>|)><math-up|Vol><around|(|<cK>|)>.
    </equation*>
  </lemma>

  Thus if one can ensure that <math|<cS><rsub|t>> is in (near) isotropic position, and <math|<around|\<\|\|\>|c<rsub|t>-<wide|c|^><rsub|t>|\<\|\|\>><rsub|2>> is small (say smaller than <math|0.1>), then the randomized center of gravity method (which replaces <math|c<rsub|t>> by <math|<wide|c|^><rsub|t>>) will converge at the same speed than the original center of gravity method.

  Assuming that <math|<cS><rsub|t>> is in isotropic position one immediately obtains <math|<E>*<around|\<\|\|\>|c<rsub|t>-<wide|c|^><rsub|t>|\<\|\|\>><rsub|2><rsup|2>=<frac|n|N>>, and thus by Chebyshev's inequality one has <math|<paragraphsign><around|(|<around|\<\|\|\>|c<rsub|t>-<wide|c|^><rsub|t>|\<\|\|\>><rsub|2>\<gtr\>0.1|)>\<leq\>100*<frac|n|N>>. In other words with <math|N=O<around|(|n|)>> one can ensure that the randomized center of gravity method makes progress on a constant fraction of the iterations (to ensure progress at every step one would need a larger value of <math|N> because of an union bound, but this is unnecessary).

  Let us now consider the issue of putting <math|<cS><rsub|t>> in near-isotropic position. Let <math|<wide|\<Sigma\>|^><rsub|t>=<frac|1|N>*<big|sum><rsub|i=1><rsup|N><around|(|X<rsub|i>-<wide|c|^><rsub|t>|)>*<around|(|X<rsub|i>-<wide|c|^><rsub|t>|)><rsup|\<top\>>>. <cite|Rud99> showed that as long as <math|N=<wide|\<Omega\>|~><around|(|n|)>>, one has with high probability (say at least probability <math|1-1/n<rsup|2>>) that the set <math|<wide|\<Sigma\>|^><rsub|t><rsup|-1/2>*<around|(|<cS><rsub|t>-<wide|c|^><rsub|t>|)>> is in near-isotropic position.

  Thus it only remains to explain how to sample from a near-isotropic convex set <math|<cK>>. This is where random walk ideas come into the picture. The hit-and-run walk<footnote|Other random walks are known for this problem but hit-and-run is the one with the sharpest theoretical guarantees. Curiously we note that one of those walks is closely connected to projected gradient descent, see <cite|BEL15>.> is described as follows: at a point <math|x\<in\><cK>>, let <math|<cL>> be a line that goes through <math|x> in a direction taken uniformly at random, then move to a point chosen uniformly at random in <math|<cL>\<cap\><cK>>. <cite|Lov98> showed that if the starting point of the hit-and-run walk is chosen from a distribution “close enough" to the uniform distribution on <math|<cK>>, then after <math|O<around|(|n<rsup|3>|)>> steps the distribution of the last point is <math|\<epsilon\>> away (in total variation) from the uniform distribution on <math|<cK>>. In the randomized center of gravity method one can obtain a good initial distribution for <math|<cS><rsub|t>> by using the distribution that was obtained for <math|<cS><rsub|t-1>>. In order to initialize the entire process correctly we start here with <math|<cS><rsub|1>=<around|[|-L,L|]><rsup|n>\<supset\><cX>> (in Section <reference|sec:gravity> we used <math|<cS><rsub|1>=<cX>>), and thus we also have to use a <with|font-shape|italic|separation oracle> at iterations where <math|<wide|c|^><rsub|t>\<nin\><cX>>, just like we did for the ellipsoid method (see Section <reference|sec:ellipsoid>).

  Wrapping up the above discussion, we showed (informally) that to attain an <math|\<epsilon\>>-optimal point with the randomized center of gravity method one needs: <math|<wide|O|~><around|(|n|)>> iterations, each iterations requires <math|<wide|O|~><around|(|n|)>> random samples from <math|<cS><rsub|t>> (in order to put it in isotropic position) as well as a call to either the separation oracle or the first order oracle, and each sample costs <math|<wide|O|~><around|(|n<rsup|3>|)>> steps of the random walk. Thus overall one needs <math|<wide|O|~><around|(|n|)>> calls to the separation oracle and the first order oracle, as well as <math|<wide|O|~><around|(|n<rsup|5>|)>> steps of the random walk.\ 

  <appendix*|Acknowledgements>

  This text grew out of lectures given at Princeton University in 2013 and 2014. I would like to thank Mike Jordan for his support in this project. My gratitude goes to the four reviewers, and especially the non-anonymous referee Francis Bach, whose comments have greatly helped to situate this monograph in the vast optimization literature. Finally I am thankful to Philippe Rigollet for suggesting the new title (a previous version of the manuscript was titled ‘‘Theory of Convex Optimization for Machine Learning"), and to Yin-Tat Lee for many insightful discussions about cutting-plane methods.

  <\bibliography|bib|tm-plain|Bubeck15Journal>
    <\bib-list|89>
      <bibitem*|1><label|bib-AB14>A.<nbsp>Agarwal and L.<nbsp>Bottou. <newblock>A lower bound for the optimization of finite sums. <newblock><em|Arxiv preprint arXiv:1410.0723>, 2014.<newblock>

      <bibitem*|2><label|bib-ABL14>J.Y. Audibert, S.<nbsp>Bubeck, and G.<nbsp>Lugosi. <newblock>Regret in online combinatorial optimization. <newblock><em|Mathematics of Operations Research>, 39: 31–45, 2014.<newblock>

      <bibitem*|3><label|bib-ABM11>J.Y Audibert, S.<nbsp>Bubeck, and R.<nbsp>Munos. <newblock>Bandit view on noisy optimization. <newblock>In S.<nbsp>Sra, S.<nbsp>Nowozin, and S.<nbsp>Wright, editors, <em|Optimization for Machine Learning>. MIT press, 2011.<newblock>

      <bibitem*|4><label|bib-Ans98>K.<nbsp>M. Anstreicher. <newblock>Towards a practical volumetric cutting plane method for convex programming. <newblock><em|SIAM Journal on Optimization>, 9 (1): 190–206, 1998.<newblock>

      <bibitem*|5><label|bib-AO14>Z.<nbsp>Allen-Zhu and L.<nbsp>Orecchia. <newblock>Linear coupling: An ultimate unification of gradient and mirror descent. <newblock><em|Arxiv preprint arXiv:1407.1537>, 2014.<newblock>

      <bibitem*|6><label|bib-Asp08>A.<nbsp>d'Aspremont. <newblock>Smooth optimization with approximate gradient. <newblock><em|SIAM Journal on Optimization>, 19 (3): 1171–1183, 2008.<newblock>

      <bibitem*|7><label|bib-Bac13>F.<nbsp>Bach. <newblock>Learning with submodular functions: A convex optimization perspective. <newblock><em|Foundations and Trends\<circledR\> in Machine Learning>, 6 (2-3): 145–373, 2013.<newblock>

      <bibitem*|8><label|bib-Bar14>B.<nbsp>Barak. <newblock>Sum of squares upper bounds, lower bounds, and open questions. <newblock>Lecture Notes, 2014.<newblock>

      <bibitem*|9><label|bib-BC12>S.<nbsp>Bubeck and N.<nbsp>Cesa-Bianchi. <newblock>Regret analysis of stochastic and nonstochastic multi-armed bandit problems. <newblock><em|Foundations and Trends\<circledR\> in Machine Learning>, 5 (1): 1–122, 2012.<newblock>

      <bibitem*|10><label|bib-BE14>S.<nbsp>Bubeck and R.<nbsp>Eldan. <newblock>The entropic barrier: a simple and optimal universal self-concordant barrier. <newblock><em|Arxiv preprint arXiv:1412.1587>, 2014.<newblock>

      <bibitem*|11><label|bib-BEL15>S.<nbsp>Bubeck, R.<nbsp>Eldan, and J.<nbsp>Lehec. <newblock>Sampling from a log-concave distribution with projected langevin monte carlo. <newblock><em|Arxiv preprint arXiv:1507.02564>, 2015a.<newblock>

      <bibitem*|12><label|bib-BerVem04>D.<nbsp>Bertsimas and S.<nbsp>Vempala. <newblock>Solving convex programs by random walks. <newblock><em|Journal of the ACM>, 51: 540–556, 2004.<newblock>

      <bibitem*|13><label|bib-BJMO12>F.<nbsp>Bach, R.<nbsp>Jenatton, J.<nbsp>Mairal, and G.<nbsp>Obozinski. <newblock>Optimization with sparsity-inducing penalties. <newblock><em|Foundations and Trends\<circledR\> in Machine Learning>, 4 (1): 1–106, 2012.<newblock>

      <bibitem*|14><label|bib-BLS15>S.<nbsp>Bubeck, Y.-T. Lee, and M.<nbsp>Singh. <newblock>A geometric alternative to nesterov's accelerated gradient descent. <newblock><em|Arxiv preprint arXiv:1506.08187>, 2015b.<newblock>

      <bibitem*|15><label|bib-BM13>F.<nbsp>Bach and E.<nbsp>Moulines. <newblock>Non-strongly-convex smooth stochastic approximation with convergence rate o(1/n). <newblock>In <em|Advances in Neural Information Processing Systems (NIPS)>, 2013.<newblock>

      <bibitem*|16><label|bib-BN01>A.<nbsp>Ben-Tal and A.<nbsp>Nemirovski. <newblock><em|Lectures on modern convex optimization: analysis, algorithms, and engineering applications>. <newblock>Society for Industrial and Applied Mathematics (SIAM), 2001.<newblock>

      <bibitem*|17><label|bib-BPCPE11>S.<nbsp>Boyd, N.<nbsp>Parikh, E.<nbsp>Chu, B.<nbsp>Peleato, and J.<nbsp>Eckstein. <newblock>Distributed optimization and statistical learning via the alternating direction method of multipliers. <newblock><em|Foundations and Trends\<circledR\> in Machine Learning>, 3 (1): 1–122, 2011.<newblock>

      <bibitem*|18><label|bib-BT03>A.<nbsp>Beck and M.<nbsp>Teboulle. <newblock>Mirror Descent and nonlinear projected subgradient methods for convex optimization. <newblock><em|Operations Research Letters>, 31 (3): 167–175, 2003.<newblock>

      <bibitem*|19><label|bib-BT09>A.<nbsp>Beck and M.<nbsp>Teboulle. <newblock>A fast iterative shrinkage-thresholding algorithm for linear inverse problems. <newblock><em|SIAM Journal on Imaging Sciences>, 2 (1): 183–202, 2009.<newblock>

      <bibitem*|20><label|bib-Bub11>S.<nbsp>Bubeck. <newblock>Introduction to online optimization. <newblock>Lecture Notes, 2011.<newblock>

      <bibitem*|21><label|bib-BV04>S.<nbsp>Boyd and L.<nbsp>Vandenberghe. <newblock><em|Convex Optimization>. <newblock>Cambridge University Press, 2004.<newblock>

      <bibitem*|22><label|bib-Cau47>A.<nbsp>Cauchy. <newblock>Méthode générale pour la résolution des systemes d'équations simultanées. <newblock><em|Comp. Rend. Sci. Paris>, 25 (1847): 536–538, 1847.<newblock>

      <bibitem*|23><label|bib-CHW12>K.<nbsp>Clarkson, E.<nbsp>Hazan, and D.<nbsp>Woodruff. <newblock>Sublinear optimization for machine learning. <newblock><em|Journal of the ACM>, 2012.<newblock>

      <bibitem*|24><label|bib-CL06>N.<nbsp>Cesa-Bianchi and G.<nbsp>Lugosi. <newblock><em|Prediction, Learning, and Games>. <newblock>Cambridge University Press, 2006.<newblock>

      <bibitem*|25><label|bib-Cov92>T.<nbsp>M. Cover. <newblock>1990 shannon lecture. <newblock><em|IEEE information theory society newsletter>, 42 (4), 1992.<newblock>

      <bibitem*|26><label|bib-CP11>A.<nbsp>Chambolle and T.<nbsp>Pock. <newblock>A first-order primal-dual algorithm for convex problems with applications to imaging. <newblock><em|Journal of Mathematical Imaging and Vision>, 40 (1): 120–145, 2011.<newblock>

      <bibitem*|27><label|bib-CR09>E.<nbsp>Candès and B.<nbsp>Recht. <newblock>Exact matrix completion via convex optimization. <newblock><em|Foundations of Computational mathematics>, 9 (6): 717–772, 2009.<newblock>

      <bibitem*|28><label|bib-CSV09>A.<nbsp>Conn, K.<nbsp>Scheinberg, and L.<nbsp>Vicente. <newblock><em|Introduction to Derivative-Free Optimization>. <newblock>Society for Industrial and Applied Mathematics (SIAM), 2009.<newblock>

      <bibitem*|29><label|bib-DBLJ14>A.<nbsp>Defazio, F.<nbsp>Bach, and S.<nbsp>Lacoste-Julien. <newblock>Saga: A fast incremental gradient method with support for non-strongly convex composite objectives. <newblock>In <em|Advances in Neural Information Processing Systems (NIPS)>, 2014.<newblock>

      <bibitem*|30><label|bib-DGBSX12>O.<nbsp>Dekel, R.<nbsp>Gilad-Bachrach, O.<nbsp>Shamir, and L.<nbsp>Xiao. <newblock>Optimal distributed online prediction using mini-batches. <newblock><em|Journal of Machine Learning Research>, 13: 165–202, 2012.<newblock>

      <bibitem*|31><label|bib-DH78>J.<nbsp>C. Dunn and S.<nbsp>Harshbarger. <newblock>Conditional gradient algorithms with open loop step size rules. <newblock><em|Journal of Mathematical Analysis and Applications>, 62 (2): 432–444, 1978.<newblock>

      <bibitem*|32><label|bib-DSSST10>J.<nbsp>Duchi, S.<nbsp>Shalev-Shwartz, Y.<nbsp>Singer, and A.<nbsp>Tewari. <newblock>Composite objective mirror descent. <newblock>In <em|Proceedings of the 23rd Annual Conference on Learning Theory (COLT)>, 2010.<newblock>

      <bibitem*|33><label|bib-FT07>M.<nbsp>P. Friedlander and P.<nbsp>Tseng. <newblock>Exact regularization of convex programs. <newblock><em|SIAM Journal on Optimization>, 18 (4): 1326–1350, 2007.<newblock>

      <bibitem*|34><label|bib-FW56>M.<nbsp>Frank and P.<nbsp>Wolfe. <newblock>An algorithm for quadratic programming. <newblock><em|Naval research logistics quarterly>, 3 (1-2): 95–110, 1956.<newblock>

      <bibitem*|35><label|bib-GK95>M.<nbsp>D. Grigoriadis and L.<nbsp>G. Khachiyan. <newblock>A sublinear-time randomized approximation algorithm for matrix games. <newblock><em|Operations Research Letters>, 18: 53–58, 1995.<newblock>

      <bibitem*|36><label|bib-Gru60>B.<nbsp>Grünbaum. <newblock>Partitions of mass-distributions and of convex bodies by hyperplanes. <newblock><em|Pacific J. Math>, 10 (4): 1257–1261, 1960.<newblock>

      <bibitem*|37><label|bib-GW95>M.<nbsp>Goemans and D.<nbsp>Williamson. <newblock>Improved approximation algorithms for maximum cut and satisfiability problems using semidefinite programming. <newblock><em|Journal of the ACM>, 42 (6): 1115–1145, 1995.<newblock>

      <bibitem*|38><label|bib-Haz11>E.<nbsp>Hazan. <newblock>The convex optimization approach to regret minimization. <newblock>In S.<nbsp>Sra, S.<nbsp>Nowozin, and S.<nbsp>Wright, editors, <em|Optimization for Machine Learning>, pages 287–303. MIT press, 2011.<newblock>

      <bibitem*|39><label|bib-HTF01>T.<nbsp>Hastie, R.<nbsp>Tibshirani, and J.<nbsp>Friedman. <newblock><em|The Elements of Statistical Learning>. <newblock>Springer, 2001.<newblock>

      <bibitem*|40><label|bib-Jag13>M.<nbsp>Jaggi. <newblock>Revisiting frank-wolfe: Projection-free sparse convex optimization. <newblock>In <em|Proceedings of the 30th International Conference on Machine Learning (ICML)>, pages 427–435, 2013.<newblock>

      <bibitem*|41><label|bib-JN11a>A.<nbsp>Juditsky and A.<nbsp>Nemirovski. <newblock>First-order methods for nonsmooth convex large-scale optimization, i: General purpose methods. <newblock>In S.<nbsp>Sra, S.<nbsp>Nowozin, and S.<nbsp>Wright, editors, <em|Optimization for Machine Learning>, pages 121–147. MIT press, 2011a.<newblock>

      <bibitem*|42><label|bib-JN11b>A.<nbsp>Juditsky and A.<nbsp>Nemirovski. <newblock>First-order methods for nonsmooth convex large-scale optimization, ii: Utilizing problem's structure. <newblock>In S.<nbsp>Sra, S.<nbsp>Nowozin, and S.<nbsp>Wright, editors, <em|Optimization for Machine Learning>, pages 149–183. MIT press, 2011b.<newblock>

      <bibitem*|43><label|bib-JNS13>P.<nbsp>Jain, P.<nbsp>Netrapalli, and S.<nbsp>Sanghavi. <newblock>Low-rank matrix completion using alternating minimization. <newblock>In <em|Proceedings of the Forty-fifth Annual ACM Symposium on Theory of Computing>, STOC '13, pages 665–674, 2013.<newblock>

      <bibitem*|44><label|bib-Jon92>L.<nbsp>K. Jones. <newblock>A simple lemma on greedy approximation in hilbert space and convergence rates for projection pursuit regression and neural network training. <newblock><em|Annals of Statistics>, pages 608–613, 1992.<newblock>

      <bibitem*|45><label|bib-JZ13>R.<nbsp>Johnson and T.<nbsp>Zhang. <newblock>Accelerating stochastic gradient descent using predictive variance reduction. <newblock>In <em|Advances in Neural Information Processing Systems (NIPS)>, 2013.<newblock>

      <bibitem*|46><label|bib-Kar84>N.<nbsp>Karmarkar. <newblock>A new polynomial-time algorithm for linear programming. <newblock><em|Combinatorica>, 4: 373–395, 1984.<newblock>

      <bibitem*|47><label|bib-Lev65>A.<nbsp>Levin. <newblock>On an algorithm for the minimization of convex functions. <newblock>In <em|Soviet Mathematics Doklady>, volume 160, pages 1244–1247, 1965.<newblock>

      <bibitem*|48><label|bib-LJSB12>S.<nbsp>Lacoste-Julien, M.<nbsp>Schmidt, and F.<nbsp>Bach. <newblock>A simpler approach to obtaining an o (1/t) convergence rate for the projected stochastic subgradient method. <newblock><em|arXiv preprint arXiv:1212.2002>, 2012.<newblock>

      <bibitem*|49><label|bib-Lov98>L.<nbsp>Lovász. <newblock>Hit-and-run mixes fast. <newblock><em|Math. Prog.>, 86: 443–461, 1998.<newblock>

      <bibitem*|50><label|bib-LRSB12>N.<nbsp>Le Roux, M.<nbsp>Schmidt, and F.<nbsp>Bach. <newblock>A stochastic gradient method with an exponential convergence rate for strongly-convex optimization with finite training sets. <newblock>In <em|Advances in Neural Information Processing Systems (NIPS)>, 2012.<newblock>

      <bibitem*|51><label|bib-LS13>Y.-T. Lee and A.<nbsp>Sidford. <newblock>Path finding i :solving linear programs with Õ(sqrt(rank)) linear system solves. <newblock><em|Arxiv preprint arXiv:1312.6677>, 2013.<newblock>

      <bibitem*|52><label|bib-LSW15>Y.-T. Lee, A.<nbsp>Sidford, and S.<nbsp>C.-W Wong. <newblock>A faster cutting plane method and its implications for combinatorial and convex optimization. <newblock><em|abs/1508.04874>, 2015.<newblock>

      <bibitem*|53><label|bib-Lug10>G.<nbsp>Lugosi. <newblock>Comment on: <math|\<ell\><rsub|1>>-penalization for mixture regression models. <newblock><em|Test>, 19 (2): 259–263, 2010.<newblock>

      <bibitem*|54><label|bib-MP89>N.<nbsp>Maculan and G.<nbsp>G. de<nbsp>Paula. <newblock>A linear-time median-finding algorithm for projecting a vector on the simplex of rn. <newblock><em|Operations research letters>, 8 (4): 219–222, 1989.<newblock>

      <bibitem*|55><label|bib-Nem04>A.<nbsp>Nemirovski. <newblock>Prox-method with rate of convergence o (1/t) for variational inequalities with lipschitz continuous monotone operators and smooth convex-concave saddle point problems. <newblock><em|SIAM Journal on Optimization>, 15 (1): 229–251, 2004a.<newblock>

      <bibitem*|56><label|bib-Nem04b>A.<nbsp>Nemirovski. <newblock>Interior point polynomial time methods in convex programming. <newblock><em|Lecture Notes>, 2004b.<newblock>

      <bibitem*|57><label|bib-Nem82>A.<nbsp>Nemirovski. <newblock>Orth-method for smooth convex optimization. <newblock><em|Izvestia AN SSSR, Ser. Tekhnicheskaya Kibernetika>, 2, 1982.<newblock>

      <bibitem*|58><label|bib-Nem95>A.<nbsp>Nemirovski. <newblock>Information-based complexity of convex programming. <newblock><em|Lecture Notes>, 1995.<newblock>

      <bibitem*|59><label|bib-Nes04>Y.<nbsp>Nesterov. <newblock><em|Introductory lectures on convex optimization: A basic course>. <newblock>Kluwer Academic Publishers, 2004a.<newblock>

      <bibitem*|60><label|bib-Nes04b>Y.<nbsp>Nesterov. <newblock>Smooth minimization of non-smooth functions. <newblock><em|Mathematical programming>, 103 (1): 127–152, 2004b.<newblock>

      <bibitem*|61><label|bib-Nes07>Y.<nbsp>Nesterov. <newblock>Gradient methods for minimizing composite objective function. <newblock>Core discussion papers, Université catholique de Louvain, Center for Operations Research and Econometrics (CORE), 2007.<newblock>

      <bibitem*|62><label|bib-Nes12>Y.<nbsp>Nesterov. <newblock>Efficiency of coordinate descent methods on huge-scale optimization problems. <newblock><em|SIAM Journal on Optimization>, 22: 341–362, 2012.<newblock>

      <bibitem*|63><label|bib-Nes83>Y.<nbsp>Nesterov. <newblock>A method of solving a convex programming problem with convergence rate o(<math|1/k<rsup|2>>). <newblock><em|Soviet Mathematics Doklady>, 27 (2): 372–376, 1983.<newblock>

      <bibitem*|64><label|bib-Nes97>Y.<nbsp>Nesterov. <newblock>Quality of semidefinite relaxation for nonconvex quadratic optimization. <newblock>CORE Discussion Papers 1997019, Université catholique de Louvain, Center for Operations Research and Econometrics (CORE), 1997.<newblock>

      <bibitem*|65><label|bib-New65>D.<nbsp>Newman. <newblock>Location of the maximum on unimodal surfaces. <newblock><em|Journal of the ACM>, 12 (3): 395–398, 1965.<newblock>

      <bibitem*|66><label|bib-NN94>Y.<nbsp>Nesterov and A.<nbsp>Nemirovski. <newblock><em|Interior-point polynomial algorithms in convex programming>. <newblock>Society for Industrial and Applied Mathematics (SIAM), 1994.<newblock>

      <bibitem*|67><label|bib-NW06>J.<nbsp>Nocedal and S.<nbsp>J. Wright. <newblock><em|Numerical Optimization>. <newblock>Springer, 2006.<newblock>

      <bibitem*|68><label|bib-NY83>A.<nbsp>Nemirovski and D.<nbsp>Yudin. <newblock><em|Problem Complexity and Method Efficiency in Optimization>. <newblock>Wiley Interscience, 1983.<newblock>

      <bibitem*|69><label|bib-PB13>N.<nbsp>Parikh and S.<nbsp>Boyd. <newblock>Proximal algorithms. <newblock><em|Foundations and Trends\<circledR\> in Optimization>, 1 (3): 123–231, 2013.<newblock>

      <bibitem*|70><label|bib-Rak09>A.<nbsp>Rakhlin. <newblock>Lecture notes on online learning. <newblock>2009.<newblock>

      <bibitem*|71><label|bib-Ren01>J.<nbsp>Renegar. <newblock><em|A mathematical view of interior-point methods in convex optimization>, volume<nbsp>3. <newblock>Siam, 2001.<newblock>

      <bibitem*|72><label|bib-RM51>H.<nbsp>Robbins and S.<nbsp>Monro. <newblock>A stochastic approximation method. <newblock><em|Annals of Mathematical Statistics>, 22: 400–407, 1951.<newblock>

      <bibitem*|73><label|bib-Roc70>R.<nbsp>Rockafellar. <newblock><em|Convex Analysis>. <newblock>Princeton University Press, 1970.<newblock>

      <bibitem*|74><label|bib-RT12>P.<nbsp>Richtárik and M.<nbsp>Takác. <newblock>Parallel coordinate descent methods for big data optimization. <newblock><em|Arxiv preprint arXiv:1212.0873>, 2012.<newblock>

      <bibitem*|75><label|bib-Rud99>M.<nbsp>Rudelson. <newblock>Random vectors in the isotropic position. <newblock><em|Journal of Functional Analysis>, 164: 60–72, 1999.<newblock>

      <bibitem*|76><label|bib-SBC14>W.<nbsp>Su, S.<nbsp>Boyd, and E.<nbsp>Candès. <newblock>A differential equation for modeling nesterov's accelerated gradient method: Theory and insights. <newblock>In <em|Advances in Neural Information Processing Systems (NIPS)>, 2014.<newblock>

      <bibitem*|77><label|bib-SLRB11>M.<nbsp>Schmidt, N.<nbsp>Le<nbsp>Roux, and F.<nbsp>Bach. <newblock>Convergence rates of inexact proximal-gradient methods for convex optimization. <newblock>In <em|Advances in neural information processing systems>, pages 1458–1466, 2011.<newblock>

      <bibitem*|78><label|bib-SS02>B.<nbsp>Schölkopf and A.<nbsp>Smola. <newblock><em|Learning with kernels>. <newblock>MIT Press, 2002.<newblock>

      <bibitem*|79><label|bib-SSS14>S.<nbsp>Shalev-Shwartz and S.<nbsp>Ben-David. <newblock><em|Understanding Machine Learning: From Theory to Algorithms>. <newblock>Cambridge University Press, 2014.<newblock>

      <bibitem*|80><label|bib-SSZ13>S.<nbsp>Shalev-Shwartz and T.<nbsp>Zhang. <newblock>Stochastic dual coordinate ascent methods for regularized loss minimization. <newblock><em|Journal of Machine Learning Research>, 14: 567–599, 2013a.<newblock>

      <bibitem*|81><label|bib-SSZ13b>S.<nbsp>Shalev-Shwartz and T.<nbsp>Zhang. <newblock>Accelerated mini-batch stochastic dual coordinate ascent. <newblock>In <em|Advances in Neural Information Processing Systems (NIPS)>, 2013b.<newblock>

      <bibitem*|82><label|bib-Tib96>R.<nbsp>Tibshirani. <newblock>Regression shrinkage and selection via the lasso. <newblock><em|Journal of the Royal Statistical Society. Series B (Methodological)>, 58 (1): pp. 267–288, 1996.<newblock>

      <bibitem*|83><label|bib-Tse08>P.<nbsp>Tseng. <newblock>On accelerated proximal gradient methods for convex-concave optimization. <newblock>2008.<newblock>

      <bibitem*|84><label|bib-Tsy03>A.<nbsp>Tsybakov. <newblock>Optimal rates of aggregation. <newblock>In <em|Conference on Learning Theory (COLT)>, pages 303–313. 2003.<newblock>

      <bibitem*|85><label|bib-Vai89>P.<nbsp>M. Vaidya. <newblock>A new algorithm for minimizing convex functions over convex sets. <newblock>In <em|Foundations of Computer Science, 1989., 30th Annual Symposium on>, pages 338–343, 1989.<newblock>

      <bibitem*|86><label|bib-Vai96>P.<nbsp>M. Vaidya. <newblock>A new algorithm for minimizing convex functions over convex sets. <newblock><em|Mathematical programming>, 73 (3): 291–341, 1996.<newblock>

      <bibitem*|87><label|bib-WNF09>S.<nbsp>J. Wright, R.<nbsp>D. Nowak, and M.<nbsp>A.<nbsp>T. Figueiredo. <newblock>Sparse reconstruction by separable approximation. <newblock><em|IEEE Transactions on Signal Processing>, 57 (7): 2479–2493, 2009.<newblock>

      <bibitem*|88><label|bib-Xia10>L.<nbsp>Xiao. <newblock>Dual averaging methods for regularized stochastic learning and online optimization. <newblock><em|Journal of Machine Learning Research>, 11: 2543–2596, 2010.<newblock>

      <bibitem*|89><label|bib-ZX14>Y.<nbsp>Zhang and L.<nbsp>Xiao. <newblock>Stochastic primal-dual coordinate method for regularized empirical risk minimization. <newblock><em|Arxiv preprint arXiv:1409.3257>, 2014.<newblock>
    </bib-list>
  </bibliography>

  \;
</body>

<\initial>
  <\collection>
    <associate|page-medium|paper>
    <associate|page-screen-margin|false>
  </collection>
</initial>

<\references>
  <\collection>
    <associate|auto-1|<tuple|?|7|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-10|<tuple|2|15|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-11|<tuple|2.1|15|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-12|<tuple|2.2|16|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-13|<tuple|2.3|18|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-14|<tuple|2.3.1|19|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-15|<tuple|2.3.2|19|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-16|<tuple|2.3.3|19|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-17|<tuple|2.3.4|20|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-18|<tuple|2.4|23|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-19|<tuple|3|25|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-2|<tuple|1|9|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-20|<tuple|3.1|25|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-21|<tuple|3.1|25|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-22|<tuple|3.2|26|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-23|<tuple|3.2|27|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-24|<tuple|3.6|29|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-25|<tuple|3.3|30|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-26|<tuple|3.3|30|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-27|<tuple|3.4|31|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-28|<tuple|3.4|32|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-29|<tuple|3.4.1|33|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-3|<tuple|1.1|9|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-30|<tuple|3.4.2|33|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-31|<tuple|3.5|34|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-32|<tuple|3.6|37|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-33|<tuple|3.6.1|38|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-34|<tuple|3.4|38|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-35|<tuple|3.6.2|38|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-36|<tuple|3.5|38|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-37|<tuple|3.6.3|39|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-38|<tuple|3.7|40|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-39|<tuple|3.7.1|40|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-4|<tuple|1.2|10|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-40|<tuple|3.6|40|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-41|<tuple|3.7.2|42|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-42|<tuple|4|45|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-43|<tuple|4.1|46|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-44|<tuple|4.2|47|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-45|<tuple|4.1|47|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-46|<tuple|4.3|48|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-47|<tuple|4.4|49|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-48|<tuple|4.5|50|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-49|<tuple|4.2|50|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-5|<tuple|1.3|11|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-50|<tuple|4.6|51|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-51|<tuple|5|53|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-52|<tuple|5.1|53|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-53|<tuple|5.1|53|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-54|<tuple|5.2|54|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-55|<tuple|5.2|54|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-56|<tuple|5.2|54|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-57|<tuple|5.2.1|55|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-58|<tuple|5.2.2|55|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-59|<tuple|5.2.3|56|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-6|<tuple|1.4|12|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-60|<tuple|5.2.4|56|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-61|<tuple|5.2.4.1|57|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-62|<tuple|5.2.4.2|57|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-63|<tuple|5.2.4.3|57|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-64|<tuple|5.3|58|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-65|<tuple|5.3.1|58|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-66|<tuple|5.3.2|59|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-67|<tuple|5.3.3|60|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-68|<tuple|5.3.4|61|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-69|<tuple|5.3.5|62|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-7|<tuple|1.5|13|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-70|<tuple|5.3.6|63|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-71|<tuple|6|65|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-72|<tuple|6.1|65|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-73|<tuple|6.2|66|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-74|<tuple|6.3|68|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-75|<tuple|6.4|70|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-76|<tuple|6.4.1|70|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-77|<tuple|6.4.2|71|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-78|<tuple|6.5|72|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-79|<tuple|6.6|73|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-8|<tuple|1.6|13|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-80|<tuple|6.7|75|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-81|<tuple|6.4|77|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-82|<tuple|6.4|79|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|auto-9|<tuple|1.1|14|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|beyond|<tuple|5|53|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-AB14|<tuple|1|79|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-ABL14|<tuple|2|79|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-ABM11|<tuple|3|79|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-AO14|<tuple|5|79|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Ans98|<tuple|4|79|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Asp08|<tuple|6|79|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-BC12|<tuple|9|79|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-BE14|<tuple|10|79|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-BEL15|<tuple|11|79|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-BJMO12|<tuple|13|79|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-BLS15|<tuple|14|79|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-BM13|<tuple|15|79|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-BN01|<tuple|16|79|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-BPCPE11|<tuple|17|79|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-BT03|<tuple|18|79|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-BT09|<tuple|19|79|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-BV04|<tuple|21|79|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Bac13|<tuple|7|79|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Bar14|<tuple|8|79|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-BerVem04|<tuple|12|79|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Bub11|<tuple|20|79|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-CHW12|<tuple|23|79|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-CL06|<tuple|24|79|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-CP11|<tuple|26|79|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-CR09|<tuple|27|79|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-CSV09|<tuple|28|79|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Cau47|<tuple|22|79|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Cov92|<tuple|25|79|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-DBLJ14|<tuple|29|79|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-DGBSX12|<tuple|30|79|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-DH78|<tuple|31|79|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-DSSST10|<tuple|32|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-FT07|<tuple|33|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-FW56|<tuple|34|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-GK95|<tuple|35|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-GW95|<tuple|37|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Gru60|<tuple|36|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-HTF01|<tuple|39|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Haz11|<tuple|38|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-JN11a|<tuple|41|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-JN11b|<tuple|42|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-JNS13|<tuple|43|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-JZ13|<tuple|45|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Jag13|<tuple|40|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Jon92|<tuple|44|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Kar84|<tuple|46|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-LJSB12|<tuple|48|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-LRSB12|<tuple|50|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-LS13|<tuple|51|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-LSW15|<tuple|52|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Lev65|<tuple|47|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Lov98|<tuple|49|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Lug10|<tuple|53|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-MP89|<tuple|54|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-NN94|<tuple|66|81|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-NW06|<tuple|67|81|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-NY83|<tuple|68|81|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Nem04|<tuple|55|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Nem04b|<tuple|56|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Nem82|<tuple|57|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Nem95|<tuple|58|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Nes04|<tuple|59|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Nes04b|<tuple|60|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Nes07|<tuple|61|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Nes12|<tuple|62|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Nes83|<tuple|63|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Nes97|<tuple|64|80|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-New65|<tuple|65|81|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-PB13|<tuple|69|81|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-RM51|<tuple|72|81|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-RT12|<tuple|74|81|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Rak09|<tuple|70|81|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Ren01|<tuple|71|81|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Roc70|<tuple|73|81|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Rud99|<tuple|75|81|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-SBC14|<tuple|76|81|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-SLRB11|<tuple|77|81|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-SS02|<tuple|78|81|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-SSS14|<tuple|79|81|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-SSZ13|<tuple|80|81|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-SSZ13b|<tuple|81|81|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Tib96|<tuple|82|81|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Tse08|<tuple|83|81|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Tsy03|<tuple|84|81|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Vai89|<tuple|85|81|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Vai96|<tuple|86|81|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-WNF09|<tuple|87|81|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-Xia10|<tuple|88|81|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|bib-ZX14|<tuple|89|81|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|dimfree|<tuple|3|25|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:1|<tuple|3.30|42|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:2|<tuple|3.31|42|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:3|<tuple|3.34|43|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:5|<tuple|3.37|43|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:AGD0|<tuple|3.20|40|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:AGD1|<tuple|3.21|40|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:AGD2|<tuple|3.22|40|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:AGD3|<tuple|3.24|41|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:AGD4|<tuple|3.25|41|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:AGD5|<tuple|3.27|41|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:CG1|<tuple|2.19|23|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:CG2|<tuple|2.20|23|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:CG3|<tuple|2.22|23|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:CG3prime|<tuple|2.21|23|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:CG4|<tuple|2.23|23|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:CG5|<tuple|2.24|24|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:CG6|<tuple|2.25|24|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:Cau47|<tuple|3.1|25|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:DA0|<tuple|4.8|49|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:DA1|<tuple|4.9|50|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:DA2|<tuple|4.10|50|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:FW1|<tuple|3.8|30|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:FW2|<tuple|3.9|30|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:MD1|<tuple|4.2|47|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:MD2|<tuple|4.3|47|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:MD3|<tuple|4.5|48|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:MDproxview|<tuple|4.7|48|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:PGD1|<tuple|3.2|25|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:PGD2|<tuple|3.3|25|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:SM|<tuple|2.14|20|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:SVRG0|<tuple|6.1|69|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:SVRG1|<tuple|6.2|69|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:SVRG2|<tuple|6.6|69|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:V21|<tuple|2.17|22|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:V22|<tuple|2.18|22|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:analysis1|<tuple|2.12|19|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:analysis2|<tuple|2.13|20|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:ass1|<tuple|3.16|34|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:ball2|<tuple|3.17|38|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:centerofgravity1|<tuple|2.2|16|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:chap3eq1|<tuple|3.7|29|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:coercive1|<tuple|3.6|28|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:defaltsmooth|<tuple|3.4|27|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:defstrongconv|<tuple|3.14|32|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:dependsonL|<tuple|6.11|74|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:ellipsoidlemma1|<tuple|2.3|16|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:ellipsoidlemma2|<tuple|2.4|16|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:ellipsoidlemma3|<tuple|2.5|16|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:ellipsoidlemma4|<tuple|2.6|16|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:ellipsoidlemma5|<tuple|2.7|17|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:ellipsoidlemma6|<tuple|2.9|17|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:gradvol|<tuple|2.10|19|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:hessianvol|<tuple|2.11|19|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:improvedstrongsmooth|<tuple|3.15|33|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:key|<tuple|5.11|62|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:keysp|<tuple|5.4|55|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:linearclassif|<tuple|5.5|57|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:maxcut1|<tuple|6.9|73|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:maxcut2|<tuple|6.10|73|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:nu|<tuple|5.10|61|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:onestepofgd|<tuple|3.5|27|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:oraclematrixgame|<tuple|6.7|73|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:oraclematrixgame2|<tuple|6.8|73|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:pourplustard1|<tuple|4.14|51|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:proxoperator|<tuple|5.2|53|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:quad|<tuple|6.12|75|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:sprepresentation|<tuple|5.3|54|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:structuredsparsity|<tuple|3.10|31|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:structuredsparsity2|<tuple|3.12|32|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:structuredsparsity3|<tuple|3.13|32|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:supphyp|<tuple|1.2|11|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:thV11|<tuple|2.15|21|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:thV12|<tuple|2.16|21|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:trucipm1|<tuple|5.7|61|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:trucipm11|<tuple|5.8|61|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:trucipm12|<tuple|5.18|62|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:trucipm2|<tuple|5.9|61|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:trucipm3|<tuple|5.6|61|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:trucipm4|<tuple|5.15|62|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:useful1|<tuple|4.1|46|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:veryfirst|<tuple|1.1|9|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:vfMD|<tuple|4.16|51|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|eq:vfMP|<tuple|4.17|52|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|fig:FW|<tuple|3.3|30|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|fig:MD|<tuple|4.1|47|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|fig:mp|<tuple|4.2|50|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|fig:nesterovacc|<tuple|3.6|40|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|fig:one_ball|<tuple|3.4|38|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|fig:pgd|<tuple|3.2|26|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|fig:pythagore|<tuple|3.1|25|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|fig:two_ball|<tuple|3.5|38|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|finitedim|<tuple|2|15|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|footnote-1.1|<tuple|1.1|14|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|footnote-2.1|<tuple|2.1|15|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|footnote-3.1|<tuple|3.1|25|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|footnote-3.2|<tuple|3.2|25|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|footnote-3.3|<tuple|3.3|26|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|footnote-3.4|<tuple|3.4|28|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|footnote-4.1|<tuple|4.1|46|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|footnote-4.2|<tuple|4.2|50|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|footnote-5.1|<tuple|5.1|53|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|footnote-5.2|<tuple|5.2|55|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|footnote-6.1|<tuple|6.1|65|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|footnote-6.2|<tuple|6.2|66|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|footnote-6.3|<tuple|6.3|70|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|footnote-6.4|<tuple|6.4|76|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|footnr-1.1|<tuple|1.1|14|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|footnr-2.1|<tuple|2.1|15|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|footnr-3.1|<tuple|3.1|25|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|footnr-3.2|<tuple|3.2|25|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|footnr-3.3|<tuple|3.3|26|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|footnr-3.4|<tuple|3.4|28|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|footnr-4.1|<tuple|4.1|46|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|footnr-4.2|<tuple|4.2|50|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|footnr-5.1|<tuple|5.1|53|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|footnr-5.2|<tuple|5.2|55|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|footnr-6.1|<tuple|6.1|65|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|footnr-6.2|<tuple|6.2|66|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|footnr-6.3|<tuple|6.3|70|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|footnr-6.4|<tuple|6.4|76|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|intro|<tuple|1|9|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|lem:2|<tuple|3.3|28|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|lem:BerVem04|<tuple|6.4|76|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|lem:GW|<tuple|6.3|74|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|lem:Gru60|<tuple|2.1|16|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|lem:SVRG|<tuple|6.1|68|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|lem:V1|<tuple|2.3|20|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|lem:V2|<tuple|2.4|22|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|lem:coercive2|<tuple|3.5|34|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|lem:geom|<tuple|3.6|39|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|lem:geomellipsoid|<tuple|2.2|16|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|lem:sand|<tuple|3.2|27|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|lem:smoothconst|<tuple|3.4|29|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|lem:tittrucnes|<tuple|6.2|72|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|lem:todonow|<tuple|3.1|25|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|lem:todonow2|<tuple|4.1|47|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|mirror|<tuple|4|45|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|prop:existencesubgradients|<tuple|1.1|10|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|prop:firstorder|<tuple|1.3|12|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|rand|<tuple|6|65|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:AGD|<tuple|3.7|40|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:CG|<tuple|2.4|23|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:FW|<tuple|3.3|30|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:GeoD|<tuple|3.6|37|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:GeoDmethod|<tuple|3.6.3|39|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:IPM|<tuple|5.3|58|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:MD|<tuple|4.2|47|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:accafterwarmup|<tuple|3.6.2|38|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:analysis|<tuple|2.3.3|19|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:barriermethod|<tuple|5.3.1|58|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:blackbox|<tuple|1.4|12|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:chap3LB|<tuple|3.5|34|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:constraintsvolumetric|<tuple|2.3.4|20|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:convexrelaxation|<tuple|6.6|73|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:ellipsoid|<tuple|2.2|16|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:gdsmooth|<tuple|3.2|27|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:gravity|<tuple|2.1|15|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:mdsetups|<tuple|4.3|48|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:mlapps|<tuple|1.1|9|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:mm|<tuple|4.1|46|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:psgd|<tuple|3.1|25|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:rwmethod|<tuple|6.7|75|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:simplenonsmooth|<tuple|5.1|53|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:smd|<tuple|6.1|65|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:sp|<tuple|5.2.1|55|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:spex|<tuple|5.2.4|56|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:spex1|<tuple|5.2.4.1|57|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:spex2|<tuple|5.2.4.2|57|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:spex3|<tuple|5.2.4.3|57|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:spmd|<tuple|5.2.2|55|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:sprepresentation|<tuple|5.2|54|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:structured|<tuple|1.5|13|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:tradanalysisNM|<tuple|5.3.2|59|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:vectorfield|<tuple|4.6|51|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|sec:warmup|<tuple|3.6.1|38|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|table|<tuple|1.1|14|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|th:GW|<tuple|6.9|74|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|th:LJSB12|<tuple|3.5|33|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|th:MD|<tuple|4.1|47|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|th:NM|<tuple|5.3|59|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|th:NMsc|<tuple|5.4|61|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|th:SMD|<tuple|6.1|66|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|th:SMDsmooth|<tuple|6.3|66|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|th:SVRG|<tuple|6.4|69|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|th:V0|<tuple|2.3|21|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|th:V1|<tuple|2.4|21|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|th:centerofgravity|<tuple|2.1|15|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|th:gdsmooth|<tuple|3.2|27|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|th:gdsmoothconstrained|<tuple|3.3|29|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|th:gdssc|<tuple|3.6|33|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|th:lb1|<tuple|3.8|35|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|th:lb2|<tuple|3.9|36|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|th:lb3|<tuple|3.10|36|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|th:linearratercd|<tuple|6.7|72|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|th:pgd|<tuple|3.1|26|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|th:rcdgamma|<tuple|6.6|71|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|th:sgdstrong|<tuple|6.2|66|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|th:spmd|<tuple|5.1|55|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|th:spmp|<tuple|5.2|56|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|th:sspmd|<tuple|6.8|72|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
    <associate|thm:main|<tuple|3.11|39|../../../Library/Application Support/liiilabs/texts/scratch/no_name_212.tm>>
  </collection>
</references>

<\auxiliary>
  <\collection>
    <\associate|bib>
      HTF01

      SS02

      SSS14

      Tib96

      CR09

      Roc70

      BV04

      NY83

      Nem95

      CSV09

      ABM11

      BN01

      Bac13

      JNS13

      NW06

      BPCPE11

      NW06

      Cov92

      Lev65

      New65

      NY83

      Gru60

      Vai89

      Vai96

      LSW15

      Vai89

      Vai96

      Nes04

      Ans98

      Vai96

      NW06

      NW06

      Cau47

      Nes04

      MP89

      FW56

      Jag13

      DH78

      Lug10

      Jon92

      FT07

      LJSB12

      NY83

      Nes04

      BLS15

      NY83

      Nem82

      Nes83

      BLS15

      SBC14

      AO14

      BT09

      Tse08

      NY83

      BT03

      CL06

      Rak09

      Haz11

      Bub11

      ABL14

      BT03

      Nem04

      Bub11

      BT09

      Nes07

      WNF09

      PB13

      BJMO12

      DSSST10

      Xia10

      Nes04b

      Nem04

      CP11

      JN11a

      JN11b

      Kar84

      NN94

      Nes04

      Ren01

      Nem04b

      NW06

      Nes04

      Nes04

      Nes04

      BE14

      Nes04

      LS13

      RM51

      Asp08

      SLRB11

      Tsy03

      BM13

      DGBSX12

      LRSB12

      SSZ13

      JZ13

      DBLJ14

      SSZ13b

      ZX14

      AB14

      Nes12

      Nes12

      Nes12

      RT12

      GK95

      BC12

      CHW12

      Bar14

      GW95

      Nes97

      BerVem04

      BerVem04

      Rud99

      BEL15

      Lov98
    </associate>
    <\associate|figure>
      <tuple|normal|<surround|<hidden-binding|<tuple>|3.1>||Illustration of Lemma <reference|lem:todonow>.>|<pageref|auto-20>>

      <tuple|normal|<surround|<hidden-binding|<tuple>|3.2>||Illustration of the projected subgradient descent method.>|<pageref|auto-22>>

      <tuple|normal|<surround|<hidden-binding|<tuple>|3.3>||Illustration of conditional gradient descent.>|<pageref|auto-26>>

      <tuple|normal|<surround|<hidden-binding|<tuple>|3.4>||One ball shrinks.>|<pageref|auto-34>>

      <tuple|normal|<surround|<hidden-binding|<tuple>|3.5>||Two balls shrink.>|<pageref|auto-36>>

      <tuple|normal|<surround|<hidden-binding|<tuple>|3.6>||Illustration of Nesterov's accelerated gradient descent.>|<pageref|auto-40>>

      <tuple|normal|<surround|<hidden-binding|<tuple>|4.1>||Illustration of mirror descent.>|<pageref|auto-45>>

      <tuple|normal|<surround|<hidden-binding|<tuple>|4.2>||Illustration of mirror prox.>|<pageref|auto-49>>
    </associate>
    <\associate|table>
      <tuple|normal|<surround|<hidden-binding|<tuple>|1.1>||Summary of the results proved in Chapter <reference|finitedim> to Chapter <reference|beyond> and some of the results in Chapter <reference|rand>.>|<pageref|auto-9>>
    </associate>
    <\associate|toc>
      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|Abstract> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-1><vspace|0.5fn>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|1<space|2spc>Introduction> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-2><vspace|0.5fn>

      1.1<space|2spc>Some convex optimization problems in machine learning <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-3>

      1.2<space|2spc>Basic properties of convexity <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-4>

      1.3<space|2spc>Why convexity? <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-5>

      1.4<space|2spc>Black-box model <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-6>

      1.5<space|2spc>Structured optimization <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-7>

      1.6<space|2spc>Overview of the results and disclaimer <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-8>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|2<space|2spc>Convex optimization in finite dimension> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-10><vspace|0.5fn>

      2.1<space|2spc>The center of gravity method <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-11>

      2.2<space|2spc>The ellipsoid method <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-12>

      2.3<space|2spc>Vaidya's cutting plane method <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-13>

      <with|par-left|<quote|1tab>|2.3.1<space|2spc>The volumetric barrier <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-14>>

      <with|par-left|<quote|1tab>|2.3.2<space|2spc>Vaidya's algorithm <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-15>>

      <with|par-left|<quote|1tab>|2.3.3<space|2spc>Analysis of Vaidya's method <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-16>>

      <with|par-left|<quote|1tab>|2.3.4<space|2spc>Constraints and the volumetric barrier <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-17>>

      2.4<space|2spc>Conjugate gradient <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-18>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|3<space|2spc>Dimension-free convex optimization> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-19><vspace|0.5fn>

      3.1<space|2spc>Projected subgradient descent for Lipschitz functions <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-21>

      3.2<space|2spc>Gradient descent for smooth functions <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-23>

      <with|par-left|<quote|1tab>|The constrained case <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-24>>

      3.3<space|2spc>Conditional gradient descent, aka Frank-Wolfe <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-25>

      <with|par-left|<quote|1tab>|An application of conditional gradient descent: Least-squares regression with structured sparsity <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-27>>

      3.4<space|2spc>Strong convexity <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-28>

      <with|par-left|<quote|1tab>|3.4.1<space|2spc>Strongly convex and Lipschitz functions <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-29>>

      <with|par-left|<quote|1tab>|3.4.2<space|2spc>Strongly convex and smooth functions <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-30>>

      3.5<space|2spc>Lower bounds <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-31>

      3.6<space|2spc>Geometric descent <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-32>

      <with|par-left|<quote|1tab>|3.6.1<space|2spc>Warm-up: a geometric alternative to gradient descent <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-33>>

      <with|par-left|<quote|1tab>|3.6.2<space|2spc>Acceleration <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-35>>

      <with|par-left|<quote|1tab>|3.6.3<space|2spc>The geometric descent method <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-37>>

      3.7<space|2spc>Nesterov's accelerated gradient descent <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-38>

      <with|par-left|<quote|1tab>|3.7.1<space|2spc>The smooth and strongly convex case <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-39>>

      <with|par-left|<quote|1tab>|3.7.2<space|2spc>The smooth case <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-41>>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|4<space|2spc>Almost dimension-free convex optimization in non-Euclidean spaces> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-42><vspace|0.5fn>

      4.1<space|2spc>Mirror maps <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-43>

      4.2<space|2spc>Mirror descent <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-44>

      4.3<space|2spc>Standard setups for mirror descent <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-46>

      4.4<space|2spc>Lazy mirror descent, aka Nesterov's dual averaging <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-47>

      4.5<space|2spc>Mirror prox <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-48>

      4.6<space|2spc>The vector field point of view on MD, DA, and MP <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-50>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|5<space|2spc>Beyond the black-box model> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-51><vspace|0.5fn>

      5.1<space|2spc>Sum of a smooth and a simple non-smooth term <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-52>

      <with|par-left|<quote|1tab>|ISTA (Iterative Shrinkage-Thresholding Algorithm) <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-53>>

      <with|par-left|<quote|1tab>|FISTA (Fast ISTA) <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-54>>

      <with|par-left|<quote|1tab>|CMD and RDA <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-55>>

      5.2<space|2spc>Smooth saddle-point representation of a non-smooth function <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-56>

      <with|par-left|<quote|1tab>|5.2.1<space|2spc>Saddle point computation <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-57>>

      <with|par-left|<quote|1tab>|5.2.2<space|2spc>Saddle Point Mirror Descent (SP-MD) <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-58>>

      <with|par-left|<quote|1tab>|5.2.3<space|2spc>Saddle Point Mirror Prox (SP-MP) <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-59>>

      <with|par-left|<quote|1tab>|5.2.4<space|2spc>Applications <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-60>>

      <with|par-left|<quote|2tab>|5.2.4.1<space|2spc>Minimizing a maximum of smooth functions <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-61>>

      <with|par-left|<quote|2tab>|5.2.4.2<space|2spc>Matrix games <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-62>>

      <with|par-left|<quote|2tab>|5.2.4.3<space|2spc>Linear classification <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-63>>

      5.3<space|2spc>Interior point methods <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-64>

      <with|par-left|<quote|1tab>|5.3.1<space|2spc>The barrier method <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-65>>

      <with|par-left|<quote|1tab>|5.3.2<space|2spc>Traditional analysis of Newton's method <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-66>>

      <with|par-left|<quote|1tab>|5.3.3<space|2spc>Self-concordant functions <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-67>>

      <with|par-left|<quote|1tab>|5.3.4<space|2spc><with|mode|<quote|math>|\<nu\>>-self-concordant barriers <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-68>>

      <with|par-left|<quote|1tab>|5.3.5<space|2spc>Path-following scheme <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-69>>

      <with|par-left|<quote|1tab>|5.3.6<space|2spc>IPMs for LPs and SDPs <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-70>>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|6<space|2spc>Convex optimization and randomness> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-71><vspace|0.5fn>

      6.1<space|2spc>Non-smooth stochastic optimization <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-72>

      6.2<space|2spc>Smooth stochastic optimization and mini-batch SGD <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-73>

      6.3<space|2spc>Sum of smooth and strongly convex functions <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-74>

      6.4<space|2spc>Random coordinate descent <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-75>

      <with|par-left|<quote|1tab>|6.4.1<space|2spc>RCD for coordinate-smooth optimization <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-76>>

      <with|par-left|<quote|1tab>|6.4.2<space|2spc>RCD for smooth and strongly convex optimization <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-77>>

      6.5<space|2spc>Acceleration by randomization for saddle points <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-78>

      6.6<space|2spc>Convex relaxation and randomized rounding <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-79>

      6.7<space|2spc>Random walk based methods <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-80>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|Appendix<space|2spc>Acknowledgements> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-81><vspace|0.5fn>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|Bibliography> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>> <no-break><pageref|auto-82><vspace|0.5fn>
    </associate>
  </collection>
</auxiliary>
